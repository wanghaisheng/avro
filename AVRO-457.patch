Index: lang/java/pom.xml
===================================================================
--- lang/java/pom.xml	(revision 1618621)
+++ lang/java/pom.xml	(working copy)
@@ -63,6 +63,8 @@
     <easymock.version>3.0</easymock.version>
     <hamcrest.version>1.1</hamcrest.version>
     <commons-httpclient.version>3.1</commons-httpclient.version>
+    <xmlschema.version>2.1.0</xmlschema.version>
+    <xmlunit.version>1.5</xmlunit.version>
 
     <!-- version properties for plugins -->
     <checkstyle-plugin.version>2.8</checkstyle-plugin.version>
@@ -93,6 +95,7 @@
     <module>protobuf</module>
     <module>thrift</module>
     <module>archetypes</module>
+    <module>xml</module>
   </modules>
 
   <build>
Index: lang/java/xml/pom.xml
===================================================================
--- lang/java/xml/pom.xml	(revision 0)
+++ lang/java/xml/pom.xml	(working copy)
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>avro-parent</artifactId>
+    <groupId>org.apache.avro</groupId>
+    <version>1.7.8-SNAPSHOT</version>
+    <relativePath>../</relativePath>
+  </parent>
+
+  <artifactId>avro-xml</artifactId>
+
+  <name>Apache Avro XML Compatibility</name>
+  <description>Serialize an XML Document as Avro data.</description>
+
+  <properties>
+    <osgi.import>
+      !org.apache.avro.xml*,
+      org.apache.avro*;version="${project.version}",
+    </osgi.import>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.ws.xmlschema</groupId>
+      <artifactId>xmlschema-core</artifactId>
+      <version>${xmlschema.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>avro</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>xmlunit</groupId>
+      <artifactId>xmlunit</artifactId>
+      <version>${xmlunit.version}</version>
+    </dependency>
+  </dependencies>
+</project>
\ No newline at end of file
Index: lang/java/xml/src/main/java/org/apache/avro/xml/AvroPathNode.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/AvroPathNode.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/AvroPathNode.java	(working copy)
@@ -0,0 +1,150 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.avro.xml;
+
+import javax.xml.namespace.QName;
+
+/**
+ * Information about a {@link XmlSchemaPathNode} representing
+ * an Avro MAP or a CONTENT node in a mixed-content element.
+ *
+ * <p>
+ * When XML elements are best represented by a map, sibling elements are
+ * grouped together under one common MAP instance.  This keeps track of
+ * whether a new element represents the start of a new MAP or the start
+ * of an item in an existing MAP.  A later path node will signify when
+ * the map ends.
+ * </p>
+ *
+ * <p>
+ * We also need to keep track of the content nodes that are part of mixed
+ * elements, as they will be added to the corresponding RECORD's ARRAY of
+ * children.
+ * </p>
+ */
+final class AvroPathNode {
+
+  private final XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> pathNode;
+  private final QName qName;
+  private final int occurrence;
+  private final Type type;
+  private final int contentUnionIndex;
+
+  private int mapSize;
+
+  enum Type {
+    MAP_START,
+    ITEM_START,
+    MAP_END,
+    CONTENT
+  }
+
+  /**
+   * Constructor for creating a new {@link AvroPathNode} to represent a MAP.
+   *
+   * @param pathNode  The path node representing the start or end of the map
+   *                  or one if its items.
+   *
+   * @param pathIndex The index of the path itself.
+   * @param type
+   * @param qName
+   * @param occurrence
+   */
+  AvroPathNode(
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> pathNode,
+      Type type,
+      QName qName,
+      int occurrence) {
+
+    if (type.equals(Type.CONTENT)) {
+      throw new IllegalArgumentException(
+          "Use the AvroPathNode(unionIndex) constructor "
+          + "for adding CONTENT nodes.");
+    }
+
+    this.pathNode = pathNode;
+    this.qName = qName;
+    this.type = type;
+    this.occurrence = occurrence;
+    this.mapSize = -1;
+    this.contentUnionIndex = -1;
+  }
+
+  AvroPathNode(
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> pathNode,
+      Type type) {
+
+    this(pathNode, type, null, 0);
+  }
+
+  AvroPathNode(int unionIndex) {
+    this.type = Type.CONTENT;
+    this.contentUnionIndex = unionIndex;
+
+    this.pathNode = null;
+    this.qName = null;
+    this.occurrence = -1;
+    this.mapSize = -1;
+  }
+
+  QName getQName() {
+    if (qName != null) {
+      return qName;
+    } else if (pathNode
+                 .getStateMachineNode()
+                 .getNodeType()
+                 .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      return pathNode.getStateMachineNode().getElement().getQName();
+    } else {
+      return null;
+    }
+  }
+
+  XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> getPathNode() {
+    return pathNode;
+  }
+
+  int getOccurrence() {
+    return occurrence;
+  }
+
+  Type getType() {
+    return type;
+  }
+
+  int getMapSize() {
+    return mapSize;
+  }
+
+  void setMapSize(int mapSize) {
+    this.mapSize = mapSize;
+  }
+
+  int getContentUnionIndex() {
+    return contentUnionIndex;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder str = new StringBuilder("[");
+    str.append(type).append(": ").append( pathNode.getDirection() );
+    str.append(" ").append( pathNode.getStateMachineNode() );
+    str.append("]");
+    return str.toString();
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/AvroRecordInfo.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/AvroRecordInfo.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/AvroRecordInfo.java	(working copy)
@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import org.apache.avro.Schema;
+
+/**
+ * Represents information about an Avro type
+ * representing a node in the document hierarchy.
+ */
+final class AvroRecordInfo {
+
+  private final Schema avroSchema;
+  private final int unionIndex;
+  private final int mapUnionIndex;
+
+  private int numChildren;
+
+  public AvroRecordInfo(Schema avroSchema) {
+    this.avroSchema = avroSchema;
+    this.unionIndex = -1;
+    this.mapUnionIndex = -1;
+    this.numChildren = 0;
+  }
+
+  public AvroRecordInfo(Schema avroSchema, int unionIndex, int mapUnionIndex) {
+    this.avroSchema = avroSchema;
+    this.unionIndex = unionIndex;
+    this.mapUnionIndex = mapUnionIndex;
+    this.numChildren = 0;
+  }
+
+  Schema getAvroSchema() {
+    return avroSchema;
+  }
+
+  int getUnionIndex() {
+    return unionIndex;
+  }
+
+  int getMapUnionIndex() {
+    return mapUnionIndex;
+  }
+
+  int getNumChildren() {
+    return numChildren;
+  }
+
+  void incrementChildCount() {
+    ++numChildren;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/AvroSchemaApplier.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/AvroSchemaApplier.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/AvroSchemaApplier.java	(working copy)
@@ -0,0 +1,1181 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedMap;
+
+import javax.xml.namespace.QName;
+
+import org.apache.avro.Schema;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaUse;
+
+/**
+ * Applies an Avro schema to a tree described by
+ * {@link XmlSchemaDocumentNode}s and {@link XmlSchemaDocumentPathNode}s.
+ *
+ * <p>
+ * Schema evolution is handled with the following conversions:
+ * <ul>
+ *   <li>STRING, BOOLEAN, ENUM, DOUBLE, FLOAT, LONG, INT -> STRING</li>
+ *   <li>DOUBLE, FLOAT, LONG, INT -> DOUBLE</li>
+ *   <li>FLOAT, LONG, INT -> FLOAT</li>
+ *   <li>LONG, INT -> LONG</li>
+ *   <li>INT -> INT</li>
+ *   <li>BOOLEAN -> BOOLEAN</li>
+ *   <li>BYTES -> BYTES</li>
+ *   <li>ENUM -> ENUM when destination ENUM is a superset of the source.</li>
+ *   <li>RECORD -> RECORD when all the fields can be converted as well.</li>
+ * </ul>
+ * </p>
+ *
+ * <p>
+ * Also joins sibling map elements under the same map,
+ * and tracks the content nodes of a mixed element.
+ * </p>
+ */
+final class AvroSchemaApplier {
+
+  private List<Schema> unionOfValidElementsStack;
+  private List<AvroRecordInfo> avroRecordStack;
+
+  private final Schema avroSchema;
+  private final Map<Schema.Type, Set<Schema.Type>> conversionCache;
+  private final boolean xmlIsWritten;
+
+  /**
+   * {@link XmlSchemaPathNode} contain their destination
+   * {@link XmlSchemaDocumentNode}, but not their originating
+   * one.  Since we do not "leave" a {@link XmlSchemaDocumentNode}
+   * until we traverse to its parent, we need to track the parent
+   * node in addition to the current one.
+   */
+  private static class StackEntry {
+    StackEntry(XmlSchemaDocumentNode<AvroRecordInfo> docNode) {
+      this.docNode = docNode;
+      this.parentNode = docNode.getParent();
+    }
+
+    final XmlSchemaDocumentNode<AvroRecordInfo> docNode;
+    final XmlSchemaDocumentNode<AvroRecordInfo> parentNode;
+    int occurrence;
+  }
+
+  /**
+   * Creates a new <code>AvroSchemaApplier</code>
+   * with the provided root node.
+   */
+  AvroSchemaApplier(Schema avroSchema, boolean xmlIsWritten) {
+    this.avroSchema = avroSchema;
+    this.xmlIsWritten = xmlIsWritten;
+
+    conversionCache = new HashMap<Schema.Type, Set<Schema.Type>>();
+    unionOfValidElementsStack = new ArrayList<Schema>();
+    avroRecordStack = new ArrayList<AvroRecordInfo>();
+
+    if ( avroSchema.getType().equals(Schema.Type.ARRAY) ) {
+      // ARRAY of UNION of RECORDs/MAPs is not valid when writing XML.
+      if (xmlIsWritten) {
+        throw new IllegalArgumentException(
+            "The Avro Schema cannot be an ARRAY of UNION of MAPs/RECORDs when "
+            + "writing XML; it must conform to the corresponding XML schema.");
+      }
+
+      /* The user is only looking to retrieve specific elements from the XML
+       * document.  Likewise, the next valid elements are only the ones in
+       * that list.
+       *
+       * (The expected format is Array<Union<Type>>)
+       */
+      if ( !avroSchema.getElementType().getType().equals(Schema.Type.UNION) ) {
+        throw new IllegalArgumentException(
+            "If retrieving only a subset of elements in the document, the Avro"
+            + " Schema must be an ARRAY of UNION of those types, not an ARRAY"
+            + " of "
+            + avroSchema.getElementType().getType());
+      }
+
+      // Confirm all of the elements in the UNION are either RECORDs or MAPs.
+      verifyIsUnionOfMapsAndRecords(avroSchema.getElementType(), true);
+
+      unionOfValidElementsStack.add(avroSchema.getElementType());
+
+    } else if ( avroSchema.getType().equals(Schema.Type.UNION) ) {
+      /* It is possible for the root element to actually be the root of a
+       * substitution group.  If this happens, the root element could be
+       * one of many different record types.
+       *
+       * This can only be valid if the schema is a union of records.
+       */
+      verifyIsUnionOfMapsAndRecords(avroSchema, true);
+
+      unionOfValidElementsStack.add(avroSchema);
+
+    } else if ( avroSchema.getType().equals(Schema.Type.RECORD)
+        || avroSchema.getType().equals(Schema.Type.MAP) ) {
+      // This is a definition of the root element.
+      List<Schema> union = new ArrayList<Schema>(1);
+      union.add(avroSchema);
+      unionOfValidElementsStack.add( Schema.createUnion(union) );
+
+    } else {
+      throw new IllegalArgumentException(
+          "The Avro Schema must be one of the following types: RECORD, MAP,"
+          + " UNION of RECORDs/MAPs, or ARRAY of UNION of RECORDs/MAPs.");
+      
+    }
+  }
+
+  void apply(
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> pathStart) {
+
+    // Add schema information to the document tree.
+    apply(pathStart.getDocumentNode());
+
+    // Count maps.
+    findMaps(pathStart);
+
+    // Update child count for mixed elements.
+    applyContent(pathStart);
+  }
+
+  private void apply(XmlSchemaDocumentNode<AvroRecordInfo> docNode) {
+    switch (docNode.getStateMachineNode().getNodeType()) {
+    case ELEMENT:
+      processElement(docNode);
+      break;
+    case ALL:
+    case CHOICE:
+    case SEQUENCE:
+    case SUBSTITUTION_GROUP:
+      processGroup(docNode);
+      break;
+    case ANY:
+      // Ignored
+      break;
+    default:
+      throw new IllegalArgumentException(
+          "Document node has an unrecognized type of "
+          + docNode.getStateMachineNode().getNodeType()
+          + '.');
+    }
+  }
+
+  private void processElement(XmlSchemaDocumentNode<AvroRecordInfo> doc) {
+    if (!doc
+           .getStateMachineNode()
+           .getNodeType()
+           .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      throw new IllegalStateException(
+          "Attempted to process an element when the node type is "
+          + doc.getStateMachineNode().getNodeType());
+    }
+
+    final XmlSchemaElement element = doc.getStateMachineNode().getElement();
+
+    final List<Schema> validNextElements =
+        unionOfValidElementsStack
+          .get(unionOfValidElementsStack.size() - 1)
+          .getTypes();
+
+    Schema elemSchema = null;
+    int schemaIndex = 0;
+    int mapSchemaIndex = -1;
+
+    if (validNextElements != null) {
+      for (; schemaIndex < validNextElements.size(); ++schemaIndex) {
+        Schema possibleSchema = validNextElements.get(schemaIndex);
+        Schema valueType = possibleSchema;
+
+        if ( possibleSchema.getType().equals(Schema.Type.MAP) ) {
+          valueType = possibleSchema.getValueType();
+
+          if ( valueType.getType().equals(Schema.Type.UNION) ) {
+            /* This XML document has multiple sibling tags representable as
+             * MAPs.  We need to cycle through them and find the best fit.
+             */
+            for (mapSchemaIndex = 0;
+                mapSchemaIndex < valueType.getTypes().size();
+                ++mapSchemaIndex) {
+              final Schema unionType = valueType.getTypes().get(mapSchemaIndex);
+              if ( !unionType.getType().equals(Schema.Type.RECORD) ) {
+                throw new IllegalStateException(
+                    "MAPs in Avro Schemas for XML documents must have a value"
+                    + " type of either RECORD or UNION of RECORD, not UNION"
+                    + " with "
+                    + unionType.getType());
+              }
+              if (typeMatchesElement(unionType, element)) {
+                elemSchema = possibleSchema;
+                break;
+              }
+            }
+
+            /* If we walked through all of the map elements and did
+             * not find a matching UNION, reset the mapSchemaIndex
+             * and check the next candidate.
+             */
+            if (elemSchema == null) {
+              mapSchemaIndex = -1;
+              continue;
+            } else {
+              // We found the element!  Stop looking.
+              break;
+            }
+          }
+        }
+
+        if ( !valueType.getType().equals(Schema.Type.RECORD) ) {
+          throw new IllegalStateException(
+              "RECORD, MAP of RECORD, and MAP of UNION of RECORD are allowed. "
+              + valueType.getType()
+              + " cannot exist in any level of that hierarchy.");
+        }
+
+        /* If we reach here, we have not found the schema, and valueType is of
+         * type RECORD (either the original RECORD or the child of a MAP) and
+         * needs to be checked.
+         */
+        if (typeMatchesElement(valueType, element)) {
+          elemSchema = possibleSchema;
+          break;
+        }
+      }
+    }
+
+    if (xmlIsWritten && (elemSchema == null)) {
+      throw new IllegalStateException(
+          "Element \""
+          + element.getQName()
+          + "\" does not have a corresponding Avro schema.  One is needed when"
+          + " writing XML.");
+    }
+
+    final XmlSchemaTypeInfo typeInfo =
+        doc.getStateMachineNode().getElementType();
+
+    Schema unionOfChildrenTypes = null;
+
+    if (elemSchema != null) {
+      final List<XmlSchemaStateMachineNode.Attribute> attributes =
+          doc.getStateMachineNode().getAttributes();
+
+      // Match the element's attributes against the element's schema.
+      for (XmlSchemaStateMachineNode.Attribute attribute : attributes) {
+        processAttribute(
+            element.getQName(),
+            elemSchema,
+            attribute.getAttribute(),
+            attribute.getType(),
+            mapSchemaIndex);
+      }
+
+      /* Child elements are in a field under the same name as the element.
+       *
+       * In the Avro schema, they may be NULL (no children), a
+       * primitive type, or an ARRAY of UNION of MAPs and RECORDs.
+       */
+      Schema valueType = elemSchema;
+      if (elemSchema.getType().equals(Schema.Type.MAP)) {
+        valueType = elemSchema.getValueType();
+        if (mapSchemaIndex >= 0) {
+          valueType = valueType.getTypes().get(mapSchemaIndex);
+        }
+      }
+
+      Schema.Field childrenField = valueType.getField( element.getName() );
+
+      /* If the element has no children, a NULL placeholder is used instead.
+       * Likewise, if the children field is null, it means the children have
+       * been removed in order to be filtered out. 
+       */
+      if (xmlIsWritten && (childrenField == null)) {
+        throw new IllegalStateException(
+            "The children of "
+            + element.getQName()
+            + " in Avro Schema {"
+            + elemSchema.getNamespace()
+            + "}"
+            + elemSchema.getName()
+            + " must exist.  If there are no children, an Avro NULL"
+            + " placeholder is required.");
+      }
+
+      if (childrenField != null) {
+        final Schema childrenSchema = childrenField.schema();
+        switch (childrenSchema.getType()) {
+        case ARRAY:
+          {
+            if (typeInfo.getType().equals(XmlSchemaTypeInfo.Type.LIST)) {
+              break;
+            }
+
+            // All group types are ARRAY of UNION of MAP/RECORD.
+            if ( !childrenSchema
+                    .getElementType()
+                    .getType()
+                    .equals(Schema.Type.UNION) ) {
+              throw new IllegalStateException(
+                  "If the children of "
+                  + element.getQName()
+                  + " in Avro Schema {"
+                  + elemSchema.getNamespace()
+                  + "}"
+                  + elemSchema.getName()
+                  + " are in a group, the corresponding Avro Schema MUST BE an"
+                  + " ARRAY of UNION of MAPs/RECORDs, not "
+                  + childrenSchema.getElementType().getType());
+            }
+
+            verifyIsUnionOfMapsAndRecords(
+                childrenSchema.getElementType(),
+                typeInfo.isMixed());
+
+            unionOfChildrenTypes = childrenSchema.getElementType();
+          }
+          break;
+        case BOOLEAN:
+        case BYTES:
+        case DOUBLE:
+        case ENUM:
+        case FLOAT:
+        case INT:
+        case LONG:
+        case STRING:
+        case RECORD:
+          {
+            if (!confirmEquivalent(
+                    typeInfo,
+                    element.getQName(),
+                    childrenSchema) ) {
+              throw new IllegalStateException(
+                  "Cannot convert between "
+                  + typeInfo
+                  + " and "
+                  + childrenSchema
+                  + " for simple content of "
+                  + element.getQName()
+                  + " in Avro Schema {"
+                  + elemSchema.getNamespace()
+                  + "}"
+                  + elemSchema.getName());
+            }
+          }
+          break;
+        case NULL:
+          // There are no children, so no further types are valid.
+          break;
+        case UNION:
+          if (typeInfo.getType().equals(XmlSchemaTypeInfo.Type.UNION)) {
+            break;
+          } else if (element.isNillable()
+                      && (childrenSchema.getTypes().size() == 2)) {
+            break;
+          }
+        default:
+          throw new IllegalStateException(
+              "Children of element "
+              + element.getQName()
+              + " in Avro Schema {"
+              + elemSchema.getNamespace()
+              + "}"
+              + elemSchema.getName()
+              + " must be either an ARRAY of UNION of MAP/RECORD or a"
+              + " primitive type, not "
+              + childrenSchema.getType());
+        }
+      }
+
+      AvroRecordInfo recordInfo = null;
+      if (avroRecordStack.isEmpty() && (doc.getParent() == null)) {
+        recordInfo = new AvroRecordInfo(elemSchema);
+        avroRecordStack.add(recordInfo);
+      } else {
+        recordInfo =
+            new AvroRecordInfo(elemSchema, schemaIndex, mapSchemaIndex);
+
+        /* Maps will be counted separately, as their
+         * children are not part of this array.
+         *
+         * The stack will be empty if the root element
+         * is part of a substitution group.
+         */
+        if (!elemSchema.getType().equals(Schema.Type.MAP)
+            && !avroRecordStack.isEmpty()) {
+
+          for (int docIter = 0; docIter < doc.getIteration(); ++docIter) {
+            avroRecordStack
+              .get(avroRecordStack.size() - 1)
+              .incrementChildCount();
+          }
+        }
+        avroRecordStack.add(recordInfo);
+      }
+      doc.setUserDefinedContent(recordInfo);
+    }
+
+    /* If the root schema is an ARRAY of UNION, then the next valid
+     * element will be one of its entries.  Otherwise, there are no
+     * next valid entries.
+     *
+     * We want to push that on the stack for when we exit children
+     * of the current element.
+     */
+    if ((unionOfChildrenTypes == null)
+          && avroSchema.getType().equals(Schema.Type.ARRAY) ) {
+      unionOfChildrenTypes = avroSchema.getElementType();
+    }
+
+    // Process the children, if any.
+    if (unionOfChildrenTypes != null) {
+      unionOfValidElementsStack.add(unionOfChildrenTypes);
+      processChildren(doc);
+      unionOfValidElementsStack.remove(unionOfValidElementsStack.size() - 1);
+    }
+
+    if (elemSchema != null) {
+      avroRecordStack.remove(avroRecordStack.size() - 1);
+    }
+  }
+
+  private void processAttribute(
+      QName elementName,
+      Schema elementSchema,
+      XmlSchemaAttribute attribute,
+      XmlSchemaTypeInfo attributeType,
+      int mapUnionIndex) {
+
+    Schema valueType = elementSchema;
+    if ( valueType.getType().equals(Schema.Type.MAP) ) {
+      valueType = valueType.getValueType();
+      if (mapUnionIndex >= 0) {
+        valueType = valueType.getTypes().get(mapUnionIndex);
+      }
+    }
+
+    final Schema.Field attrField = valueType.getField( attribute.getName() );
+
+    if (xmlIsWritten
+        && (attrField == null)
+        && !attribute.getUse().equals(XmlSchemaUse.OPTIONAL)
+        && !attribute.getUse().equals(XmlSchemaUse.PROHIBITED)) {
+      throw new IllegalStateException(
+          "Element "
+          + elementName
+          + " has a "
+          + attribute.getUse()
+          + " attribute named "
+          + attribute.getQName()
+          + " - when writing to XML, a field in the Avro record must exist.");
+    }
+
+    if (attrField != null) {
+      Schema attrType = attrField.schema();
+
+      if ( attribute.getUse().equals(XmlSchemaUse.OPTIONAL) 
+          && attrType.getType().equals(Schema.Type.UNION) ) {
+
+        /* The XML Schema Attribute may have already been a union, so we
+         * need to walk all of the subtypes and pull out the non-NULL ones.
+         */
+        final ArrayList<Schema> subset =
+            new ArrayList<Schema>(attrType.getTypes().size() - 1);
+
+        for (Schema unionSchema : attrType.getTypes()) {
+          if ( !unionSchema.getType().equals(Schema.Type.NULL) ) {
+            subset.add(unionSchema);
+          }
+        }
+
+        if (subset.size() == 1) {
+          attrType = subset.get(0);
+        } else {
+          attrType = Schema.createUnion(subset);
+        }
+      }
+
+      if (!confirmEquivalent(
+          attributeType,
+          attribute.getQName(),
+          attrType)) {
+        throw new IllegalStateException(
+            "Cannot convert element "
+            + elementName
+            + " attribute "
+            + attribute.getQName()
+            + " types between "
+            + attributeType.getBaseType()
+            + " and "
+            + attrField.schema());
+      }
+    }
+  }
+
+  private void processChildren(XmlSchemaDocumentNode<AvroRecordInfo> doc) {
+    for (int iteration = 1; iteration <= doc.getIteration(); ++iteration) {
+      final SortedMap<Integer, XmlSchemaDocumentNode<AvroRecordInfo>>
+        children = doc.getChildren(iteration);
+
+      if (children != null) {
+        for (Map.Entry<Integer, XmlSchemaDocumentNode<AvroRecordInfo>> child :
+              children.entrySet()) {
+          apply(child.getValue());
+        }
+      }
+    }
+  }
+
+  private void processGroup(XmlSchemaDocumentNode<AvroRecordInfo> doc) {
+    /* The union of valid types is already on the stack from
+     * the owning element.  We just need to walk the children.
+     */
+    switch( doc.getStateMachineNode().getNodeType() ) {
+    case SUBSTITUTION_GROUP:
+    case ALL:
+    case CHOICE:
+    case SEQUENCE:
+      processChildren(doc);
+      break;
+    default:
+      throw new IllegalStateException(
+          "Attempted to process a group, but the document node is of type "
+          + doc.getStateMachineNode().getNodeType());
+    }
+  }
+
+  // Confirms the root-level Schema is a UNION of MAPs, RECORDs, or both.
+  private static void verifyIsUnionOfMapsAndRecords(
+      Schema schema,
+      boolean isMixed) {
+
+    for (Schema unionType : schema.getTypes()) {
+      if (!unionType.getType().equals(Schema.Type.RECORD)
+          && !unionType.getType().equals(Schema.Type.MAP)
+          && !(isMixed && unionType.getType().equals(Schema.Type.STRING))) {
+
+        throw new IllegalArgumentException(
+            "The Avro Schema may either be a UNION or an ARRAY of UNION, but"
+            + " only if all of the elements in the UNION are of either type"
+            + " RECORD or MAP, not "
+            + unionType.getType());
+
+      } else if (unionType.getType().equals(Schema.Type.MAP)) {
+        if ( unionType.getValueType().getType().equals(Schema.Type.UNION) ) {
+          for (Schema mapUnionType : unionType.getValueType().getTypes()) {
+            if (!mapUnionType.getType().equals(Schema.Type.RECORD)) {
+              throw new IllegalArgumentException(
+                  "If using a UNION of MAP of UNION, all of the UNION types"
+                  + " must be RECORD, not "
+                  + mapUnionType.getType());
+            }
+          }
+        } else if (
+            !unionType
+               .getValueType()
+               .getType()
+               .equals(Schema.Type.RECORD)) {
+
+          throw new IllegalArgumentException(
+              "If the Avro Schema is a UNION of MAPs or an ARRAY of UNION of"
+              + " MAPs, all MAP value types must be RECORD or UNION of RECORD,"
+              + " not "
+              + unionType.getValueType().getType());
+        }
+      }
+    }
+  }
+
+  private static boolean typeMatchesElement(Schema type, XmlSchemaElement element) {
+    boolean match = false;
+
+    if (type.getName().equals( element.getName() )) {
+      // Confirm the namespaces match.
+      String ns = element.getQName().getNamespaceURI();
+      if ((ns != null) && !ns.isEmpty()) {
+        try {
+          if (Utils.getAvroNamespaceFor(ns).equals(
+                type.getNamespace()))
+          {
+            // Namespaces match.
+            match = true;
+          }
+        } catch (URISyntaxException e) {
+          throw new IllegalStateException(
+              "Element \""
+              + element.getQName()
+              + "\" has a namespace that is not a valid URI.",
+              e);
+        }
+      } else {
+        // There is no namespace; auto-match.
+        match = true;
+      }
+    }
+
+    return match;
+  }
+
+  /* Confirms two XML Schema simple types are equivalent.  Supported types are:
+   *
+   * BOOLEAN
+   * BYTES
+   * DOUBLE
+   * ENUM
+   * FLOAT
+   * INT
+   * LONG
+   * STRING
+   */
+  private boolean confirmEquivalent(
+      XmlSchemaTypeInfo xmlType,
+      QName xmlTypeQName,
+      Schema avroType) {
+
+    final Schema xmlAvroType =
+        Utils.getAvroSchemaFor(xmlType, xmlTypeQName, false);
+
+    if ((avroType != null) && (xmlAvroType == null)) {
+      return false;
+
+    } else if ((avroType == null) && (xmlAvroType != null)) {
+      return false;
+
+    } else if ((avroType == null) && (xmlAvroType == null)) {
+      return true;
+
+    }
+
+    if (xmlIsWritten) {
+      return confirmEquivalent(avroType, xmlAvroType);
+    } else {
+      return confirmEquivalent(xmlAvroType, avroType);
+    }
+  }
+
+  /* Confirms two XML Schema simple types are equivalent.  Supported types are:
+   *
+   * BOOLEAN
+   * BYTES
+   * DOUBLE
+   * ENUM
+   * FLOAT
+   * INT
+   * LONG
+   * STRING
+   */
+  private boolean confirmEquivalent(Schema readerType, Schema writerType) {
+
+    if (readerType.getType().equals(Schema.Type.ARRAY)
+        && (writerType.getType().equals(Schema.Type.ARRAY))) {
+      return confirmEquivalent(
+          readerType.getElementType(),
+          writerType.getElementType());
+
+    } else if (readerType.getType().equals(Schema.Type.UNION)
+        && writerType.getType().equals(Schema.Type.UNION)) {
+
+      // O(N^2) cross-examination.
+      int numFound = 0;
+      for (Schema readerUnionType : writerType.getTypes()) {
+        for (Schema writerUnionType : readerType.getTypes()) {
+          if ( confirmEquivalent(readerUnionType, writerUnionType) ) {
+            ++numFound;
+            break;
+          }
+        }
+      }
+
+      return (readerType.getTypes().size() == numFound);
+    }
+
+    if ( conversionCache.containsKey(writerType.getType()) ) {
+      return conversionCache.get( writerType.getType() )
+                            .contains( readerType.getType() );
+    }
+
+    final HashSet<Schema.Type> convertibleFrom = new HashSet<Schema.Type>();
+    switch ( writerType.getType() ) {
+    case STRING:
+      // STRING, BOOLEAN, ENUM, DOUBLE, FLOAT, LONG, INT -> STRING
+      convertibleFrom.add(Schema.Type.STRING);
+      convertibleFrom.add(Schema.Type.BOOLEAN);
+      convertibleFrom.add(Schema.Type.ENUM);
+      /* falls through */
+    case DOUBLE:
+      // DOUBLE, FLOAT, LONG, INT -> DOUBLE
+      convertibleFrom.add(Schema.Type.DOUBLE);
+      /* falls through */
+    case FLOAT:
+      // FLOAT, LONG, INT -> FLOAT
+      convertibleFrom.add(Schema.Type.FLOAT);
+      /* falls through */
+    case LONG:
+      // LONG, INT -> LONG
+      convertibleFrom.add(Schema.Type.LONG);
+      /* falls through */
+    case INT:
+      // INT -> INT
+      convertibleFrom.add(Schema.Type.INT);
+      break;
+
+    case BOOLEAN:
+      // BOOLEAN -> BOOLEAN
+      convertibleFrom.add(Schema.Type.BOOLEAN);
+      break;
+
+    case BYTES:
+      // BYTES -> BYTES
+      convertibleFrom.add(Schema.Type.BYTES);
+      break;
+
+    case ENUM:
+    case RECORD:
+      // These are more complex.
+      break;
+
+    default:
+      throw new IllegalArgumentException(
+          "Cannot confirm the equivalency of a reader of type "
+          + readerType.getType()
+          + " and a writer of type "
+          + writerType.getType());
+    }
+
+    if ( !convertibleFrom.isEmpty() ) {
+      conversionCache.put(writerType.getType(), convertibleFrom);
+      return convertibleFrom.contains( readerType.getType() );
+    }
+
+    /* If we're here, it's because the writer is either an ENUM or a RECORD.
+     * For ENUMs, confirm the writer elements are a superset of the reader
+     * elements.  For RECORDs, confirm the fields are convertible. 
+     */
+    if (writerType.getType().equals(Schema.Type.ENUM)
+        && readerType.getType().equals(Schema.Type.ENUM) ) {
+
+      final List<String> writerSymbols = writerType.getEnumSymbols();
+      final List<String> readerSymbols = readerType.getEnumSymbols();
+
+      for (String readerSymbol : readerSymbols) {
+        if ( !writerSymbols.contains(readerSymbol) ) {
+          return false;
+        }
+      }
+
+      return true;
+
+    } else if (
+        writerType.getType().equals(Schema.Type.RECORD)
+        && readerType.getType().equals(Schema.Type.RECORD) ) {
+
+      final List<Schema.Field> writerFields = writerType.getFields();
+      final List<Schema.Field> readerFields = readerType.getFields();
+
+      if (readerFields.size() == writerFields.size()) {
+        boolean equivalent = true;
+
+        for (int fieldIdx = 0; fieldIdx < writerFields.size(); ++fieldIdx) {
+          equivalent =
+              confirmEquivalent(
+                  readerFields.get(fieldIdx).schema(),
+                  writerFields.get(fieldIdx).schema());
+          if (!equivalent) {
+            break;
+          }
+        }
+
+        return equivalent;
+      }
+
+    }
+
+    return false;
+  }
+
+  /**
+   * Avro maps are tricky because they must be defined all at once, but
+   * depending on the schema, their elements may be scattered all across
+   * the document.
+   *
+   * This implementation looks for map nodes that are clustered together,
+   * and counts them for when {@link XmlDatumWriter} takes over.  A cluster
+   * starts the first time we reach a path node whose underlying Avro schema
+   * is of type {@link Schema.Type#MAP}.  A cluster ends when the next
+   * traversal out of a map node is to its parent element.  (Intermediary
+   * groups do not count as the end of the cluster.)
+   *
+   * @param path The path to check if is a map node.
+   */
+  private static void findMaps(
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path) {
+
+    Map<QName, List<List<AvroPathNode>>> occurrencesByName =
+        new HashMap<QName, List<List<AvroPathNode>>>();
+
+    final ArrayList<StackEntry> docNodeStack =
+        new ArrayList<StackEntry>();
+
+    AvroPathNode mostRecentlyLeftMap = null;
+
+    while(path != null) {
+
+      final boolean isElement =
+          path
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ELEMENT);
+
+      final AvroRecordInfo record =
+          path.getDocumentNode().getUserDefinedContent();
+
+      final boolean isMapNode =
+          (record != null)
+          && record.getAvroSchema().getType().equals(Schema.Type.MAP);
+
+      switch (path.getDirection()) {
+      case SIBLING:
+        {
+          if (isElement) {
+            /* This is an element increasing its own occurrence.
+             * This means we need to pop the previous element off
+             * of the stack and start a new one.
+             */
+            final StackEntry stackEntry =
+                docNodeStack.remove(docNodeStack.size() - 1);
+
+            if (mostRecentlyLeftMap != null) {
+              addEndNode(occurrencesByName, mostRecentlyLeftMap);
+            }
+
+            mostRecentlyLeftMap = null;
+
+            if (stackEntry
+                  .docNode
+                  .getUserDefinedContent()
+                  .getAvroSchema()
+                  .getType().equals(Schema.Type.MAP) ) {
+
+              mostRecentlyLeftMap =
+                  new AvroPathNode(
+                      path,
+                      AvroPathNode.Type.MAP_END,
+                      stackEntry
+                        .docNode
+                        .getStateMachineNode()
+                        .getElement()
+                        .getQName(),
+                      stackEntry.occurrence);
+            }
+          }
+        }
+        /* falls through */
+      case CHILD:
+        {
+          if (isElement) {
+            StackEntry entry = new StackEntry(path.getDocumentNode());
+
+            if (isMapNode) {
+              final QName currQName =
+                  path
+                    .getStateMachineNode()
+                    .getElement()
+                    .getQName();
+
+              List<List<AvroPathNode>> occurrences = null;
+              if ((mostRecentlyLeftMap == null)
+                  || !currQName.equals( mostRecentlyLeftMap.getQName() )) {
+
+                if (mostRecentlyLeftMap != null) {
+                  addEndNode(occurrencesByName, mostRecentlyLeftMap);
+                }
+
+                final ArrayList<AvroPathNode> pathIndices =
+                    new ArrayList<AvroPathNode>();
+                pathIndices.add(
+                    new AvroPathNode(
+                        path,
+                        AvroPathNode.Type.MAP_START));
+                incrementMapParentChildCount(path);
+
+                if (!occurrencesByName.containsKey(currQName)) {
+                  occurrences = new ArrayList<List<AvroPathNode>>();
+                  occurrencesByName.put(currQName, occurrences);
+                } else {
+                  occurrences = occurrencesByName.get(currQName);
+                }
+                occurrences.add(pathIndices);
+              } else {
+                occurrences = occurrencesByName.get(currQName);
+                occurrences
+                  .get(occurrences.size() - 1)
+                  .add(
+                      new AvroPathNode(
+                          path,
+                          AvroPathNode.Type.ITEM_START));
+              }
+
+              entry.occurrence = occurrences.size() - 1;
+              mostRecentlyLeftMap = null;
+            }
+
+            docNodeStack.add(entry);
+          }
+          break;
+        }
+      case PARENT:
+        {
+          final StackEntry stackEntry =
+              docNodeStack.get(docNodeStack.size() - 1);
+
+          if (stackEntry.parentNode == path.getDocumentNode()) {
+            docNodeStack.remove(docNodeStack.size() - 1);
+
+            if (mostRecentlyLeftMap != null) {
+              addEndNode(occurrencesByName, mostRecentlyLeftMap);
+            }
+
+            mostRecentlyLeftMap = null;
+            if (stackEntry
+                  .docNode
+                  .getUserDefinedContent()
+                  .getAvroSchema()
+                  .getType().equals(Schema.Type.MAP) ) {
+
+              mostRecentlyLeftMap =
+                  new AvroPathNode(
+                      path,
+                      AvroPathNode.Type.MAP_END,
+                      stackEntry
+                        .docNode
+                        .getStateMachineNode()
+                        .getElement()
+                        .getQName(),
+                      stackEntry.occurrence);
+            }
+          }
+          break;
+        }
+      case CONTENT:
+        break;
+      default:
+        throw new IllegalStateException(
+            "Path of "
+            + path.getStateMachineNode()
+            + " has an unrecognized direction of "
+            + path.getDirection()
+            + ".");
+      }
+
+      path = path.getNext();
+    }
+
+    /* Will be 1 if the root is an element,
+     * and 0 if the root is a substitution group.
+     */
+    if (docNodeStack.size() > 1) {
+      throw new IllegalStateException(
+          "Expected the stack to have no more than one "
+          + "element in it at the end, but found "
+          + docNodeStack.size()
+          + ".");
+    }
+
+    for (Map.Entry<QName, List<List<AvroPathNode>>> entry :
+           occurrencesByName.entrySet()) {
+      for (List<AvroPathNode> avroMapNodes : entry.getValue()) {
+        // The MAP_END node doesn't count as a child.
+        avroMapNodes.get(0).setMapSize(avroMapNodes.size() - 1);
+        for (AvroPathNode avroMapNode : avroMapNodes) {
+          avroMapNode.getPathNode().setUserDefinedContent(avroMapNode);
+        }
+      }
+    }
+  }
+
+  private static void addEndNode(
+      Map<QName, List<List<AvroPathNode>>> occurrencesByName,
+      AvroPathNode mostRecentlyLeftMap) {
+
+    final List<List<AvroPathNode>> occurrences =
+        occurrencesByName.get(mostRecentlyLeftMap.getQName());
+    final List<AvroPathNode> nodes =
+        occurrences.get(mostRecentlyLeftMap.getOccurrence());
+    nodes.add(mostRecentlyLeftMap);
+  }
+
+  /* All of the elements in a map are grouped together, and likewise cannot be
+   * counted as part of the MAP's parent's children.  Likewise, each time we
+   * find a new MAP, we only increment the parent's child count by one.
+   */
+  private static void incrementMapParentChildCount(
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path) {
+
+    if (!path.getStateMachineNode()
+                .getNodeType()
+                .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      throw new IllegalArgumentException(
+          "Starting node should be at an element, not a "
+          + path.getStateMachineNode().getNodeType()
+          + '.');
+    }
+
+    XmlSchemaDocumentNode<AvroRecordInfo> docNode = path.getDocumentNode();
+    do {
+      docNode = docNode.getParent();
+    } while (!docNode
+                .getStateMachineNode()
+                .getNodeType()
+                .equals(XmlSchemaStateMachineNode.Type.ELEMENT));
+
+    if (docNode.getUserDefinedContent() == null) {
+      throw new IllegalStateException(
+          "Reached a node representing "
+          + docNode.getStateMachineNode()
+          + ", but it contains no Avro record information.");
+    }
+
+    docNode.getUserDefinedContent().incrementChildCount();
+  }
+
+  private static void applyContent(
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> startNode) {
+
+    XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path = startNode;
+
+    final ArrayList<StackEntry> docNodeStack =
+        new ArrayList<StackEntry>();
+
+    while (path != null) {
+      final boolean isElement =
+          path
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ELEMENT);
+
+      switch(path.getDirection()) {
+      case SIBLING:
+        if (isElement) {
+          /* This is an element increasing its own occurrence.
+           * This means we need to pop the previous element off
+           * of the stack and start a new one.
+           */
+          docNodeStack.remove(docNodeStack.size() - 1);
+        }
+        /* falls through */
+      case CHILD:
+        if (isElement) {
+          StackEntry entry = new StackEntry(path.getDocumentNode());
+          docNodeStack.add(entry);
+        }
+        break;
+      case PARENT:
+        {
+          final StackEntry stackEntry =
+              docNodeStack.get(docNodeStack.size() - 1);
+
+          if (stackEntry.parentNode == path.getDocumentNode()) {
+            docNodeStack.remove(docNodeStack.size() - 1);
+          }
+          break;
+        }
+      case CONTENT:
+        {
+          final StackEntry entry = docNodeStack.get(docNodeStack.size() - 1);
+          final AvroRecordInfo recordInfo =
+              entry.docNode.getUserDefinedContent();
+
+          Schema schema = recordInfo.getAvroSchema();
+          if (schema.getType().equals(Schema.Type.MAP)) {
+            schema = schema.getValueType();
+            if (recordInfo.getMapUnionIndex() >= 0) {
+              schema = schema.getTypes().get(recordInfo.getMapUnionIndex());
+            }
+          }
+
+          final XmlSchemaElement elem =
+              entry.docNode.getStateMachineNode().getElement();
+
+          final XmlSchemaTypeInfo elemType =
+              entry.docNode.getStateMachineNode().getElementType();
+
+          final Schema.Field childField =
+              schema.getField(elem.getQName().getLocalPart());
+
+          if (elemType.isMixed() && (childField != null)) {
+            schema = childField.schema();
+            int unionIdx = -1;
+            if (schema.getType().equals(Schema.Type.ARRAY)
+                && schema
+                     .getElementType()
+                     .getType()
+                     .equals(Schema.Type.UNION)) {
+              final List<Schema> unionTypes =
+                  schema.getElementType().getTypes();
+
+              for (unionIdx = 0; unionIdx < unionTypes.size(); ++unionIdx) {
+                if (unionTypes
+                      .get(unionIdx)
+                      .getType()
+                      .equals(Schema.Type.STRING)) {
+                  break;
+                }
+              }
+              if (unionIdx == unionTypes.size()) {
+                throw new IllegalStateException(
+                    "Element "
+                    + elem.getQName()
+                    + " is a mixed type, but its internal"
+                    + " union does not have a STRING!");
+              }
+              recordInfo.incrementChildCount();
+
+              final AvroPathNode pathNode = path.getUserDefinedContent();
+              if (pathNode == null) {
+                path.setUserDefinedContent(new AvroPathNode(unionIdx));
+              } else {
+                throw new IllegalStateException(
+                    "The path node is for CONTENT, but an "
+                    + "AvroPathNode already exists!");
+              }
+            }
+          }
+
+          break;
+        }
+      default:
+        throw new IllegalStateException(
+            "Path of "
+            + path.getStateMachineNode()
+            + " has an unrecognized direction of "
+            + path.getDirection()
+            + ".");
+      }
+
+      path = path.getNext();
+    }
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/AvroSchemaGenerator.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/AvroSchemaGenerator.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/AvroSchemaGenerator.java	(working copy)
@@ -0,0 +1,838 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+
+import org.apache.avro.Schema;
+import org.apache.avro.Schema.Type;
+import org.apache.ws.commons.schema.XmlSchemaAll;
+import org.apache.ws.commons.schema.XmlSchemaAnnotation;
+import org.apache.ws.commons.schema.XmlSchemaAnnotationItem;
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaAnyAttribute;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaChoice;
+import org.apache.ws.commons.schema.XmlSchemaDocumentation;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaUse;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.codehaus.jackson.node.ArrayNode;
+import org.codehaus.jackson.node.JsonNodeFactory;
+import org.codehaus.jackson.node.ObjectNode;
+import org.w3c.dom.NodeList;
+
+/**
+ * Generates an Avro schema based on the walked XML Schema.
+ */
+final class AvroSchemaGenerator implements XmlSchemaVisitor {
+
+  private Schema root;
+
+  private final List<URL> schemaUrls;
+  private final List<File> schemaFiles;
+  private final String baseUri;
+
+  private final ArrayList<StackEntry> stack;
+  private final Map<QName, Schema> schemasByElement;
+  private final Map<QName, List<Schema>> substitutionGroups;
+  private final Map<QName, List<Schema>> fieldsByElement;
+  private final Map<QName, List<AttributeEntry>> attributesByElement; 
+
+  private static class StackEntry {
+    final QName elementQName;
+    final boolean isSubstitutionGroup;
+
+    public StackEntry(
+        final QName elementQName,
+        final boolean isSubstitutionGroup) {
+
+      this.elementQName = elementQName;
+      this.isSubstitutionGroup = isSubstitutionGroup;
+    }
+  }
+
+  private static class AttributeEntry {
+    private final Schema.Field schemaField;
+    private final boolean isNonOptionalIdField;
+
+    AttributeEntry(Schema.Field field, boolean isNonOptionalIdField) {
+      this.schemaField = field;
+      this.isNonOptionalIdField = isNonOptionalIdField;
+    }
+
+    Schema.Field getField() {
+      return schemaField;
+    }
+
+    boolean isNonOptionalIdField() {
+      return isNonOptionalIdField;
+    }
+  }
+
+  AvroSchemaGenerator(
+      String baseUri,
+      List<URL> schemaUrls,
+      List<File> schemaFiles) {
+
+    this.baseUri = baseUri;
+    this.schemaUrls = schemaUrls;
+    this.schemaFiles = schemaFiles;
+
+    root = null;
+    stack = new ArrayList<StackEntry>();
+    schemasByElement = new HashMap<QName, Schema>();
+    substitutionGroups = new HashMap<QName, List<Schema>>();
+    fieldsByElement = new HashMap<QName, List<Schema>>();
+    attributesByElement = new HashMap<QName, List<AttributeEntry>>();
+  }
+
+  /**
+   * Clears the internal state of the {@link AvroSchemaGenerator}
+   * so a new Avro {@link Schema} can be generated from a new
+   * {@link org.apache.ws.commons.schema.XmlSchema}.
+   */
+  void clear() {
+    root = null;
+    stack.clear();
+    schemasByElement.clear();
+    substitutionGroups.clear();
+    fieldsByElement.clear();
+    attributesByElement.clear();
+  }
+
+  /**
+   * The generated {@link Schema}, or <code>null</code> if none.
+   *
+   * @return The generated {@link Schema}, or <code>null</code> if none.
+   */
+  Schema getSchema() {
+    return root;
+  }
+
+  /**
+   * If this element was not added previously, registers a new schema for it.
+   * If this element was added previously, and it is not part of a substitution
+   * group, add it to its parent.
+   *
+   * @see XmlSchemaVisitor#onEnterElement(XmlSchemaElement, XmlSchemaTypeInfo, boolean)
+   */
+  @Override
+  public void onEnterElement(
+      final XmlSchemaElement element,
+      final XmlSchemaTypeInfo typeInfo,
+      final boolean previouslyVisited) {
+
+    final QName elemQName = element.getQName();
+    final StackEntry substGrp = getSubstitutionGroup();
+
+    if (previouslyVisited) {
+      if (substGrp == null) {
+        /* This element is not part of a substitution group, so
+         * it is simply a child of its parent.  Add it as such.
+         *
+         * If this were a member of a substitution group, then it
+         * would have been added to that substitution group the first
+         * time it was encountered.  Once the substitution group has
+         * been fully processed, all of its elements will be added
+         * to the proper parent(s) at once.  Likewise, nothing needs
+         * to be done here.
+         */
+        final Schema schema = schemasByElement.get(elemQName);
+        if (schema == null) {
+          throw new IllegalStateException(
+              "Element \""
+              + element.getQName()
+              + "\" was previously visited, but has no schema.");
+        }
+
+        addSchemaToParent(schema);
+      }
+
+      return;
+    }
+
+    /* If this element is abstract, it is not
+     * a member of the substitution group.
+     */
+    if ((substGrp != null) && element.isAbstract()) {
+      return;
+    }
+
+    // If documentation is available, makes it the record's documentation.
+    final String documentation =
+        getDocumentationFor( element.getAnnotation() );
+
+    // Create the record.
+    Schema record = null;
+    String avroNamespace = null;
+
+    try {
+      avroNamespace = Utils.getAvroNamespaceFor( elemQName.getNamespaceURI() );
+    } catch (URISyntaxException e) {
+      throw new IllegalArgumentException(
+          "Element \""
+          + elemQName
+          + "\" has an invalid namespace of \""
+          + elemQName.getNamespaceURI() + "\"", e);
+    }
+
+    record =
+        Schema.createRecord(
+            elemQName.getLocalPart(),
+            documentation,
+            avroNamespace,
+            false);
+
+    schemasByElement.put(elemQName, record);
+  }
+
+  /**
+   * If this element was not visited previously, retrieves all of the fields
+   * associated with the record corresponding to the element, and adds them.
+   *
+   * @see XmlSchemaVisitor#onExitElement(XmlSchemaElement, XmlSchemaTypeInfo, boolean)
+   */
+  @Override
+  public void onExitElement(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo typeInfo,
+      boolean previouslyVisited) {
+
+    if (previouslyVisited) {
+      /* No element was added to the stack, so no element should be removed
+       * from the stack. This element either has been processed already or
+       * will be processed later.
+       */
+      return;
+
+    } else if ((getSubstitutionGroup() != null) && element.isAbstract()) {
+
+      /* This element is part of a substitution group and was declared
+       * abstract, so it will not be a valid child element.
+       */
+      return;
+    }
+
+    final StackEntry entry = pop(element.getQName(), false);
+
+    Schema record = schemasByElement.get(entry.elementQName);
+    if (record == null) {
+      throw new IllegalStateException(
+          "No schema found for element \"" + entry.elementQName + "\".");
+
+    } else if (record.getType().equals(Schema.Type.MAP)) {
+      record = record.getValueType();
+    }
+
+    final List<AttributeEntry> fields =
+        attributesByElement.get(entry.elementQName);
+
+    ArrayList<Schema.Field> schemaFields = null; 
+
+    if (fields == null) {
+      schemaFields = new ArrayList<Schema.Field>(1);
+    } else {
+      schemaFields = new ArrayList<Schema.Field>( fields.size() );
+      for (AttributeEntry attrEntry : fields) {
+        schemaFields.add( attrEntry.getField() );
+      }
+    }
+
+    final List<Schema> children = fieldsByElement.get(entry.elementQName);
+
+    /* If there are multiple maps in the children, merge
+     * them together under one MAP of UNION of children.
+     */
+    if ((children != null) && !children.isEmpty()) {
+      int mapIndex = -1;
+      ArrayList<Schema> mapUnion = null;
+      ArrayList<Integer> indicesToRemove = null;
+      for (int i = 0; i < children.size(); ++i) {
+        Schema currSchema = children.get(i);
+        if (currSchema.getType().equals(Schema.Type.MAP)) {
+          if (mapIndex < 0) {
+            // This is the first map.
+            mapIndex = i;
+          } else if (mapUnion == null) {
+            // This is the second map.
+            mapUnion = new ArrayList<Schema>();
+            final Schema mapSchema = children.get(mapIndex);
+            mapUnion.add( mapSchema.getValueType() );
+            mapUnion.add( currSchema.getValueType() );
+
+            indicesToRemove = new ArrayList<Integer>();
+            indicesToRemove.add(i);
+
+          } else {
+            // These are maps 3+.
+            mapUnion.add( currSchema.getValueType() );
+            indicesToRemove.add(i);
+          }
+        }
+      }
+
+      if (mapUnion != null) {
+        // 1. Create a union of all MAP children.
+        children.set(
+            mapIndex,
+            Schema.createMap( Schema.createUnion(mapUnion) ));
+
+        // 2. Remove all other indices with MAPs in them.
+        ListIterator<Integer> iter =
+            indicesToRemove.listIterator(indicesToRemove.size());
+
+        while ( iter.hasPrevious() ) {
+          children.remove( iter.previous().intValue() );
+        }
+      }
+
+      // Now, remove duplicate children.
+      final HashSet<String> duplicates = new HashSet<String>();
+
+      if (indicesToRemove != null) {
+        indicesToRemove.clear();
+      }
+
+      for (int childIndex = 0; childIndex < children.size(); ++childIndex) {
+        Schema child = children.get(childIndex);
+        if ( duplicates.contains( child.getFullName() ) ) {
+          if (indicesToRemove == null) {
+            indicesToRemove = new ArrayList<Integer>();
+          }
+          indicesToRemove.add(childIndex);
+        } else {
+          duplicates.add( child.getFullName() );
+        }
+      }
+
+      if ((indicesToRemove != null) && !indicesToRemove.isEmpty()) {
+        ListIterator<Integer> iter =
+            indicesToRemove.listIterator(indicesToRemove.size());
+
+        while ( iter.hasPrevious() ) {
+          children.remove( iter.previous().intValue() );
+        }
+      }
+    }
+
+    if ((children != null)
+          && !children.isEmpty()
+          && (typeInfo != null)
+          && (typeInfo.getUserRecognizedType() != null)) {
+      throw new IllegalStateException(
+          "Element \"" + entry.elementQName + "\" has both a type ("
+          + typeInfo.getUserRecognizedType() + ") and " + children.size()
+          + " child elements.");
+
+    } else if ((children != null) && !children.isEmpty()) {
+      boolean isMixedType = false;
+      if (typeInfo != null) {
+        isMixedType = typeInfo.isMixed();
+      }
+
+      if (isMixedType) {
+        boolean foundString = false;
+        for (Schema child : children) {
+          if ( child.getType().equals(Schema.Type.STRING) ) {
+            foundString = true;
+            break;
+          }
+        }
+        if (!foundString) {
+          children.add( Schema.create(Schema.Type.STRING) );
+        }
+      }
+
+      final Schema schema = Schema.createArray( Schema.createUnion(children) );
+      final Schema.Field field =
+          new Schema.Field(
+              entry.elementQName.getLocalPart(),
+              schema,
+              "Children of " + entry.elementQName,
+              null);
+      schemaFields.add(field);
+
+    } else if ((typeInfo != null)
+                && (typeInfo.getType().equals(XmlSchemaTypeInfo.Type.LIST)
+                    || typeInfo.getType().equals(XmlSchemaTypeInfo.Type.UNION)
+                    || typeInfo.isMixed()
+                    || (typeInfo.getUserRecognizedType() != null))) {
+
+      final Schema childSchema =
+          Utils.getAvroSchemaFor(
+              typeInfo,
+              element.getQName(),
+              element.isNillable());
+
+      final Schema.Field field =
+          new Schema.Field(
+              entry.elementQName.getLocalPart(),
+              childSchema,
+              "Simple type " + typeInfo.getUserRecognizedType(),
+              null);
+
+      schemaFields.add(field);
+
+    } else if (((children == null) || children.isEmpty())
+               && ((typeInfo == null)
+                   || (typeInfo.getUserRecognizedType() == null))) {
+
+      // This element has no children.  Set a null placeholder.
+      final Schema.Field field =
+          new Schema.Field(
+              entry.elementQName.getLocalPart(),
+              Schema.create(Type.NULL),
+              "This element contains no attributes and no children.",
+              null);
+      schemaFields.add(field);
+    }
+
+    record.setFields(schemaFields);
+  }
+
+  /**
+   * Processes the attribute of the provided element,
+   * adding it as a field to the corresponding record.
+   *
+   * @see XmlSchemaVisitor#onVisitAttribute(XmlSchemaElement, XmlSchemaAttribute, XmlSchemaTypeInfo)
+   */
+  @Override
+  public void onVisitAttribute(
+      XmlSchemaElement element,
+      XmlSchemaAttribute attribute,
+      XmlSchemaTypeInfo attributeType) {
+
+    if ((getSubstitutionGroup() != null) && element.isAbstract()) {
+      // Abstract elements are ignored.
+      return;
+    }
+
+    if ( attribute.getUse().equals(XmlSchemaUse.PROHIBITED) ) {
+      // This attribute is prohibited and cannot be part of the record.
+      return;
+    }
+
+    final QName elemQName = element.getQName();
+    final QName attrQName = attribute.getQName();
+
+    final String documentation =
+        getDocumentationFor( attribute.getAnnotation() );
+
+    boolean isOptional = false;
+
+    // Optional types are unions of the real type and null.
+    if (attribute.getUse().equals(XmlSchemaUse.OPTIONAL)
+        && (attribute.getDefaultValue() == null)
+        && (attribute.getFixedValue() == null)) {
+      isOptional = true;
+    }
+
+    boolean isIdField = false;
+    if ((attributeType.getUserRecognizedType() != null)
+        && attributeType.getUserRecognizedType().equals(Constants.XSD_ID)) {
+      isIdField = true;
+    }
+
+    Schema attrSchema =
+        Utils.getAvroSchemaFor(
+            attributeType,
+            attribute.getQName(),
+            isOptional);
+
+    final Schema.Field attr =
+        new Schema.Field(
+            attrQName.getLocalPart(),
+            attrSchema,
+            documentation,
+            null);
+
+    List<AttributeEntry> attrs = attributesByElement.get(elemQName);
+    if (attrs == null) {
+      attrs = new ArrayList<AttributeEntry>();
+      attributesByElement.put(elemQName, attrs);
+    }
+    attrs.add( new AttributeEntry(attr, isIdField && !isOptional) );
+  }
+
+  @Override
+  public void onEndAttributes(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo elemTypeInfo) {
+
+    final QName elemQName = element.getQName();
+    final StackEntry substGrp = getSubstitutionGroup();
+
+    if ((substGrp != null) && element.isAbstract()) {
+      return;
+    }
+
+    final List<AttributeEntry> fields =
+        attributesByElement.get(elemQName);
+
+    Schema record = schemasByElement.get(elemQName);
+    if (record == null) {
+      throw new IllegalStateException(
+          "No schema found for element \"" + elemQName + "\".");
+    }
+
+    /* If this RECORD contains exactly one non-optional ID attribute, it is
+     * better served as a MAP.  However, the root element of a document cannot
+     * be a map; it would have no siblings.
+     */
+    if (!stack.isEmpty()
+        && ((stack.size() > 1)
+            || !stack.get(0).isSubstitutionGroup)
+        && isMap(fields)) {
+      record = Schema.createMap(record);
+      schemasByElement.put(elemQName, record);
+    }
+
+    if (substGrp != null) {
+      /* This element is part of a substitution group.
+       * It will be added to its parent(s) later.
+       */
+      List<Schema> substitutionSchemas =
+          substitutionGroups.get(substGrp.elementQName);
+      if (substitutionSchemas == null) {
+        substitutionSchemas = new ArrayList<Schema>();
+        substitutionGroups.put(substGrp.elementQName, substitutionSchemas);
+      }
+      substitutionSchemas.add(record);
+
+    } else if ( stack.isEmpty() ) {
+      // This is the root element!
+      root = record;
+      addXmlSchemasListToRoot( element.getQName() );
+
+    } else {
+      /* This is not part of a substitution group,
+       * and not the root.  Add it to its parent.
+       */
+      addSchemaToParent(record);
+    }
+
+    stack.add( new StackEntry(elemQName, false) );
+  }
+
+  /**
+   * Adds a new stack entry for this substitution group.
+   *
+   * @see XmlSchemaVisitor#onEnterSubstitutionGroup(XmlSchemaElement)
+   */
+  @Override
+  public void onEnterSubstitutionGroup(XmlSchemaElement base) {
+    stack.add( new StackEntry(base.getQName(), true) );
+  }
+
+  /**
+   * Retrieves all of the members of this substitution
+   * group and adds them to the parent as children.
+   *
+   * @see XmlSchemaVisitor#onExitSubstitutionGroup(XmlSchemaElement)
+   */
+  @Override
+  public void onExitSubstitutionGroup(XmlSchemaElement base) {
+    final StackEntry entry = pop(base.getQName(), true);
+    final List<Schema> substitutes =
+        substitutionGroups.get(entry.elementQName);
+
+    if ((substitutes == null) || substitutes.isEmpty()) {
+      /* This happens when an abstract element can only
+       * be substituted by other abstract elements.
+       */
+      return;
+    }
+
+    if ( stack.isEmpty() ) {
+      // The root node in the stack is part of a substitution group.
+      root = Schema.createUnion(substitutes);
+      addXmlSchemasListToRoot( base.getQName() );
+
+    } else {
+      // The substitution group is part of a higher group.
+      StackEntry parent = getParentElement();
+      List<Schema> siblings = fieldsByElement.get(parent.elementQName);
+      if (siblings == null) {
+        siblings = new ArrayList<Schema>( substitutes.size() );
+      }
+      siblings.addAll(substitutes);
+    }
+  }
+
+  /**
+   * Avro schemas do not handle different group
+   * types differently.  This is a no-op.
+   *
+   * @see XmlSchemaVisitor#onEnterAllGroup(XmlSchemaAll)
+   */
+  @Override
+  public void onEnterAllGroup(XmlSchemaAll all) { }
+
+  /**
+   * Avro schemas do not handle different group
+   * types differently.  This is a no-op.
+   *
+   * @see XmlSchemaVisitor#onExitAllGroup(XmlSchemaAll)
+   */
+  @Override
+  public void onExitAllGroup(XmlSchemaAll all) { }
+
+  /**
+   * Avro schemas do not handle different group
+   * types differently.  This is a no-op.
+   *
+   * @see XmlSchemaVisitor#onEnterChoiceGroup(XmlSchemaChoice)
+   */
+  @Override
+  public void onEnterChoiceGroup(XmlSchemaChoice choice) { }
+
+  /**
+   * Avro schemas do not handle different group
+   * types differently.  This is a no-op.
+   *
+   * @see XmlSchemaVisitor#onExitChoiceGroup(XmlSchemaChoice)
+   */
+  @Override
+  public void onExitChoiceGroup(XmlSchemaChoice choice) { }
+
+  /**
+   * Avro schemas do not handle different group
+   * types differently.  This is a no-op.
+   *
+   * @see XmlSchemaVisitor#onEnterSequenceGroup(XmlSchemaSequence)
+   */
+  @Override
+  public void onEnterSequenceGroup(final XmlSchemaSequence seq) {  }
+
+  /**
+   * Avro schemas do not handle different group
+   * types differently.  This is a no-op.
+   *
+   * @see XmlSchemaVisitor#onExitSequenceGroup(XmlSchemaSequence)
+   */
+  @Override
+  public void onExitSequenceGroup(final XmlSchemaSequence seq) { }
+
+  /**
+   * Avro schemas do not have support for an
+   * "anything" type. This method is a no-op.
+   *
+   * @see XmlSchemaVisitor#onVisitAny(XmlSchemaAny)
+   */
+  @Override
+  public void onVisitAny(XmlSchemaAny any) { }
+
+  /**
+   * Avro schemas do not have support for an
+   * "anything" type. This method is a no-op.
+   *
+   * @see XmlSchemaVisitor#onVisitAnyAttribute(XmlSchemaElement, XmlSchemaAnyAttribute)
+   */
+  @Override
+  public void onVisitAnyAttribute(final XmlSchemaElement element, final XmlSchemaAnyAttribute anyAttr) {  }
+
+  /**
+   * Retrieves the <code>StackEntry</code> representing the parent element.
+   * Traverses through as many substitution groups as necessary to find it.
+   *
+   * @return The <code>StackEntry</code> representing the parent element.
+   * @exception IllegalStateException if there is no parent element.
+   */
+  private StackEntry getParentElement() {
+    ListIterator<StackEntry> iterator = stack.listIterator( stack.size() );
+    while ( iterator.hasPrevious() ) {
+      StackEntry entry = iterator.previous();
+      if (!entry.isSubstitutionGroup) {
+        return entry;
+      }
+    }
+
+    throw new IllegalStateException("No parent element available in stack.");
+  }
+
+  /**
+   * If we are processing a substitution group, returns the
+   * <code>StackEntry</code> representing that substitution
+   * group.  Otherwise, returns <code>null</code>.
+   *
+   * @return A <code>StackEntry</code> for the represented
+   *         substitution group, or <code>null</code> if none.
+   */
+  private StackEntry getSubstitutionGroup() {
+    final ListIterator<StackEntry> iterator = stack.listIterator(stack.size());
+    if (iterator.hasPrevious()) {
+      StackEntry prev = iterator.previous();
+      if (prev.isSubstitutionGroup) {
+        return prev;
+      }
+    }
+    return null;
+  }
+
+  private void addSchemaToParent(final Schema schema) {
+    final StackEntry parent = getParentElement();
+    List<Schema> siblings = fieldsByElement.get(parent.elementQName);
+    if (siblings == null) {
+      siblings = new ArrayList<Schema>();
+      fieldsByElement.put(parent.elementQName, siblings);
+    }
+    siblings.add(schema);
+  }
+
+  private StackEntry pop(QName entryQName, boolean isSubstGroup) {
+    if ( stack.isEmpty() ) {
+      throw new IllegalStateException(
+          "Attempted to pop "
+          + getStackEntryInfo(entryQName, isSubstGroup)
+          + " off of an empty stack.");
+    }
+
+    final StackEntry entry = stack.remove(stack.size() - 1);
+
+    if (!entry.elementQName.equals(entryQName)
+        || (entry.isSubstitutionGroup != isSubstGroup)) {
+      throw new IllegalStateException(
+          "Attempted to pop "
+          + getStackEntryInfo(entryQName, isSubstGroup)
+          + " but found "
+          + getStackEntryInfo(entry.elementQName, entry.isSubstitutionGroup));
+    }
+
+    return entry;
+  }
+
+  private void addXmlSchemasListToRoot(QName rootTagQName) {
+    if (((schemaUrls == null) || schemaUrls.isEmpty())
+        && ((schemaFiles == null) || schemaFiles.isEmpty())
+        && ((baseUri == null) || !baseUri.isEmpty())) {
+      return;
+    }
+
+    final ObjectNode schemasNode = JsonNodeFactory.instance.objectNode();
+
+    if ((schemaUrls != null) && !schemaUrls.isEmpty()) {
+      final ArrayNode urlArrayNode = JsonNodeFactory.instance.arrayNode();
+      for (URL schemaUrl : schemaUrls) {
+        urlArrayNode.add( schemaUrl.toString() );
+      }
+      schemasNode.put("urls", urlArrayNode);
+    }
+
+    if ((schemaFiles != null) && !schemaFiles.isEmpty()) {
+      final ArrayNode fileArrayNode = JsonNodeFactory.instance.arrayNode();
+      for (File schemaFile : schemaFiles) {
+        fileArrayNode.add( schemaFile.getAbsolutePath() );
+      }
+      schemasNode.put("files", fileArrayNode);
+    }
+
+    if ((baseUri != null) && !baseUri.isEmpty()) {
+      schemasNode.put("baseUri", baseUri);
+    }
+
+    final ObjectNode rootTagNode = JsonNodeFactory.instance.objectNode();
+    rootTagNode.put("namespace", rootTagQName.getNamespaceURI());
+    rootTagNode.put("localPart", rootTagQName.getLocalPart());
+
+    schemasNode.put("rootTag", rootTagNode);
+
+    if ( root.getType().equals(Schema.Type.RECORD) ) {
+      root.addProp("xmlSchemas", schemasNode);
+
+    } else if ( root.getType().equals(Schema.Type.UNION) ) {
+      if ((root.getTypes() == null) || root.getTypes().isEmpty()) {
+        throw new IllegalStateException(
+            "Root is a substitution group with no children!");
+      }
+
+      final Schema firstElem = root.getTypes().get(0);
+      if ( !firstElem.getType().equals(Schema.Type.RECORD) ) {
+        throw new IllegalStateException(
+            "Root is a substitution group with a first element of type "
+            + firstElem.getType());
+      }
+
+      firstElem.addProp("xmlSchemas", schemasNode);
+
+    } else {
+      throw new IllegalStateException(
+          "Document root is neither a RECORD nor a UNION.");
+    }
+  }
+
+  private static boolean isMap(final List<AttributeEntry> attributes) {
+
+    int nonOptionalIdFieldCount = 0;
+
+    if (attributes != null) {
+      for (AttributeEntry attribute : attributes) {
+        if ( attribute.isNonOptionalIdField() ) {
+          ++nonOptionalIdFieldCount;
+        }
+      }
+    }
+
+    return (nonOptionalIdFieldCount == 1);
+  }
+
+  private static String getStackEntryInfo(
+      QName entryQName,
+      boolean isSubstGroup) {
+    return "\"" + entryQName + "\" (Substitution Group? " + isSubstGroup + ")";
+  }
+
+  private static String getDocumentationFor(XmlSchemaAnnotation annotation) {
+    if ((annotation != null)
+        && (annotation.getItems() != null)
+        && !annotation.getItems().isEmpty()) {
+
+      StringBuilder docs = new StringBuilder();
+      for (XmlSchemaAnnotationItem item : annotation.getItems()) {
+        if (item instanceof XmlSchemaDocumentation) {
+          final NodeList docNodes =
+              ((XmlSchemaDocumentation) item).getMarkup();
+
+          for (int nodeIdx = 0; nodeIdx < docNodes.getLength(); ++nodeIdx) {
+            docs.append(
+                docNodes
+                  .item(nodeIdx)
+                  .getTextContent()
+                  .replaceAll("\\s+", " "));
+          }
+          break;
+        }
+      }
+      return docs.toString();
+    }
+
+    return null;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/DomBuilderFromSax.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/DomBuilderFromSax.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/DomBuilderFromSax.java	(working copy)
@@ -0,0 +1,387 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.w3c.dom.DOMException;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.xml.sax.Attributes;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
+
+/**
+ * Builds an XML {@link org.w3c.dom.Document}
+ * from an XML Schema during a SAX walk.
+ */
+final class DomBuilderFromSax extends DefaultHandler {
+
+  private static final String XSI_NS =
+      "http://www.w3.org/2001/XMLSchema-instance";
+  private static final String XSI_SCHEMALOC = "schemaLocation";
+  private static final String XSI_NIL = "nil";
+
+  private Document document;
+  private StringBuilder content;
+  private Map<String, String> namespaceToLocationMapping;
+  private List<String> newPrefixes;
+  private XmlSchemaNamespaceContext nsContext;
+
+  private Map<QName, XmlSchemaElement> elementsByQName;
+
+  private final ArrayList<Element> elementStack;
+  private final DocumentBuilder docBuilder;
+  private final XmlSchemaCollection schemas;
+  private final Set<String> globalNamespaces;
+
+  DomBuilderFromSax() throws ParserConfigurationException {
+    this(null);
+  }
+
+  /**
+   * Creates a new <code>DocumentBuilderFromSax</code>.
+   *
+   * @throws ParserConfigurationException If unable to create a
+   *                                      {@link DocumentBuilder}. 
+   */
+  DomBuilderFromSax(XmlSchemaCollection xmlSchemaCollection)
+      throws ParserConfigurationException {
+
+    if (xmlSchemaCollection == null) {
+      throw new IllegalArgumentException(
+          "xmlSchemaCollection cannot be null.");
+    }
+
+    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+    factory.setNamespaceAware(true);
+
+    docBuilder = factory.newDocumentBuilder();
+    elementStack = new ArrayList<Element>();
+    newPrefixes = new ArrayList<String>();
+    nsContext = new XmlSchemaNamespaceContext();
+
+    document = null;
+    content = null;
+    namespaceToLocationMapping = null;
+    elementsByQName = null;
+    schemas = xmlSchemaCollection;
+
+    globalNamespaces = new HashSet<String>();
+    globalNamespaces.add("http://www.w3.org/2001/XMLSchema-instance");
+  }
+
+  /**
+   * @see org.xml.sax.helpers.DefaultHandler#startDocument()
+   */
+  @Override
+  public void startDocument() throws SAXException {
+    document = docBuilder.newDocument();
+    document.setXmlStandalone(true);
+  }
+
+  @Override
+  public void startPrefixMapping(String prefix, String uri)
+      throws SAXException {
+
+    nsContext.addNamespace(prefix, uri);
+    newPrefixes.add(prefix);
+  }
+
+  @Override
+  public void endPrefixMapping(String prefix) throws SAXException {
+    nsContext.removeNamespace(prefix);
+  }
+
+  /**
+   * @see DefaultHandler#startElement(String, String, String, Attributes)
+   */
+  @Override
+  public void startElement(
+      String uri,
+      String localName,
+      String qName,
+      Attributes atts) throws SAXException {
+
+    addContentToCurrentElement(false);
+
+    final Element element =
+        document.createElementNS(uri.isEmpty() ? null : uri, qName);
+
+    // Define New Prefixes
+    for (String newPrefix : newPrefixes) {
+      final String namespace = nsContext.getNamespaceURI(newPrefix);
+      if (namespace == null) {
+        throw new SAXException("Prefix " + newPrefix + " is not recognized.");
+      }
+      String qualifiedName = null;
+      if ( !newPrefix.isEmpty() ) {
+        qualifiedName = Constants.XMLNS_ATTRIBUTE + ':' + newPrefix;
+      } else {
+        qualifiedName = Constants.XMLNS_ATTRIBUTE;
+      }
+
+      try {
+        element.setAttributeNS(
+            Constants.XMLNS_ATTRIBUTE_NS_URI,
+            qualifiedName,
+            namespace);
+      } catch (DOMException e) {
+        throw new IllegalStateException(
+            "Cannot add namespace attribute ns=\""
+            + Constants.XMLNS_ATTRIBUTE_NS_URI
+            + "\", qn=\""
+            + qualifiedName
+            + "\", value=\""
+            + namespace
+            + "\" to element \""
+            + qName
+            + "\".",
+            e);
+      }
+    }
+    newPrefixes.clear();
+
+    // Add Attributes
+    for (int attrIndex = 0; attrIndex < atts.getLength(); ++attrIndex) {
+      String attrUri = atts.getURI(attrIndex);
+      if ( attrUri.isEmpty() ) {
+        attrUri = null;
+      }
+
+      boolean isGlobal = globalNamespaces.contains(attrUri);
+      if ((attrUri != null) && !isGlobal) {
+
+        /* TODO: This is not quite correct.  The default namespace does not
+         *       apply to attributes - so if an element defines an attribute,
+         *       it is considered to have no namespace, and likewise should
+         *       not have a prefix.
+         *
+         *       However, that no-namespace attribute may conflict with an
+         *       attribute of the same name in the global namespace.  The only
+         *       way to resolve this would be to keep track of where we are in
+         *       the schema, and then walk the element's type hierarchy to find
+         *       its attributes.  Then we would be able to determine if an
+         *       attribute is in the global namespace by calling
+         *       XmlSchemaAttribute.isTopLevel().
+         *
+         *       This cannot be done using XmlSchemaWalker (and by extension,
+         *       XmlSchemaStateMachineNodes) because XmlSchemaWalker creates
+         *       copies of the existing XmlSchemaAttributes in the schema in
+         *       order to properly merge a globally-defined attribute with its
+         *       references defined in the element type hierarchies.
+         *
+         *       The tests can be easily modified to check this behavior; just
+         *       rename avro:mapId to avro:id in test_schema.xsd and update its
+         *       implementation documents test1_root.xml, test2_children.xml,
+         *       and test3_grandchildren.xml.  The attribute name avro:id will
+         *       conflict with the id attribute defined in avro:root.
+         */
+        final QName attrQName =
+            new QName(attrUri, atts.getLocalName(attrIndex));
+
+        if (schemas.getAttributeByQName(attrQName) != null) {
+          isGlobal = true;
+        }
+      }
+
+      final String attrValue = atts.getValue(attrIndex);
+
+      if (!isGlobal) {
+        element.setAttribute(atts.getLocalName(attrIndex), attrValue);
+      } else {
+        element.setAttributeNS(attrUri, atts.getQName(attrIndex), attrValue);
+      }
+
+    }
+
+    // Update the Parent Element
+    if ( !elementStack.isEmpty() ) {
+      elementStack.get(elementStack.size() - 1).appendChild(element);
+    } else {
+      addNamespaceLocationMappings(element);
+      document.appendChild(element);
+    }
+
+    elementStack.add(element);
+  }
+
+  /**
+   * 
+   * @see DefaultHandler#characters(char[], int, int)
+   */
+  @Override
+  public void characters(char[] ch, int start, int length)
+      throws SAXException {
+
+    if (content == null) {
+      content = new StringBuilder();
+    }
+    content.append(ch, start, length);
+  }
+
+  /**
+   * @see DefaultHandler#endElement(String, String, String)
+   */
+  @Override
+  public void endElement(
+      String uri,
+      String localName,
+      String qName)
+      throws SAXException {
+
+    addContentToCurrentElement(true);
+
+    if ( elementStack.isEmpty() ) {
+      StringBuilder errMsg = new StringBuilder("Attempted to end element {");
+      errMsg.append(uri).append('}').append(localName);
+      errMsg.append(", but the stack is empty!");
+      throw new IllegalStateException( errMsg.toString() );
+    }
+
+    final Element element = elementStack.remove(elementStack.size() - 1);
+
+    final String ns = ( uri.isEmpty() ) ? null : uri;
+
+    final boolean namespacesMatch =
+        (((ns == null) && (element.getNamespaceURI() == null))
+            || ((ns != null) && ns.equals(element.getNamespaceURI())));
+
+    if (!namespacesMatch
+        || !element.getLocalName().equals(localName) ) {
+      StringBuilder errMsg = new StringBuilder("Attempted to end element {");
+      errMsg.append(ns).append('}').append(localName).append(", but found {");
+      errMsg.append( element.getNamespaceURI() ).append('}');
+      errMsg.append( element.getLocalName() ).append(" on the stack instead!");
+      throw new IllegalStateException( errMsg.toString() );
+    }
+  }
+
+  /**
+   * @see org.xml.sax.helpers.DefaultHandler#endDocument()
+   */
+  @Override
+  public void endDocument() throws SAXException {
+    if (!elementStack.isEmpty()) {
+      StringBuilder errMsg = new StringBuilder("Ending an XML document with ");
+      errMsg.append( elementStack.size() ).append(" elements still open.");
+
+      elementStack.clear();
+
+      throw new IllegalStateException(  errMsg.toString() );
+    }
+  }
+
+  private void addContentToCurrentElement(boolean isEnd) {
+    if ((content == null) || (content.length() == 0)) {
+      /* If we reached the end of the element, check if we received any
+       * content.  If not, and if the element is nillable, write a nil
+       * attribute.
+       */
+      if (isEnd && !elementStack.isEmpty() && (schemas != null)) {
+        final Element currElem  = elementStack.get(elementStack.size() - 1);
+        if (currElem.getChildNodes().getLength() == 0) {
+          final QName elemQName =
+              new QName(currElem.getNamespaceURI(), currElem.getLocalName());
+
+          XmlSchemaElement schemaElem = null;
+
+          if (elementsByQName != null) {
+            schemaElem = elementsByQName.get(elemQName);
+          }
+
+          if (schemaElem == null) {
+            schemaElem = schemas.getElementByQName(elemQName);
+          }
+
+          if ((schemaElem != null) && schemaElem.isNillable()) {
+            currElem.setAttributeNS(XSI_NS, XSI_NIL, "true");
+          }
+        }
+      }
+      return;
+    }
+
+    if ( elementStack.isEmpty() ) {
+      StringBuilder errMsg = new StringBuilder("Attempted to add content \"");
+      errMsg.append( content.toString() ).append("\", but there were no ");
+      errMsg.append("elements in the stack!");
+      throw new IllegalStateException( errMsg.toString() );
+    }
+
+    elementStack
+      .get(elementStack.size() - 1)
+      .appendChild( document.createTextNode( content.toString() ) );
+
+    content.delete(0, content.length());
+  }
+
+  Document getDocument() {
+    return document;
+  }
+
+  Map<String, String> getNamespaceToLocationMapping() {
+    return namespaceToLocationMapping;
+  }
+
+  void setNamespaceToLocationMapping(Map<String, String> nsToLocMapping) {
+    namespaceToLocationMapping = nsToLocMapping;
+  }
+
+  Map<QName, XmlSchemaElement> getElementsByQName() {
+    return elementsByQName;
+  }
+
+  void setElementsByQName(Map<QName, XmlSchemaElement> elemsByQName) {
+    elementsByQName = elemsByQName;
+  }
+
+  private void addNamespaceLocationMappings(Element rootElement) {
+    if ((namespaceToLocationMapping == null)
+        || namespaceToLocationMapping.isEmpty()
+        || rootElement.hasAttributeNS(XSI_NS, XSI_SCHEMALOC)) {
+
+      /* There are no namesapces mappings to add,
+       * or a namespace mapping already exists.
+       */
+      return;
+    }
+
+    StringBuilder schemaList = new StringBuilder();
+    for (Map.Entry<String, String> e : namespaceToLocationMapping.entrySet()) {
+      schemaList.append( e.getKey() ).append(' ').append( e.getValue() );
+      schemaList.append(' ');
+    }
+    schemaList.delete(schemaList.length() - 1, schemaList.length());
+
+    rootElement.setAttributeNS(XSI_NS, XSI_SCHEMALOC, schemaList.toString());
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/SaxWalkerOverDom.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/SaxWalkerOverDom.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/SaxWalkerOverDom.java	(working copy)
@@ -0,0 +1,447 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.constants.Constants;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.w3c.dom.Text;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+
+/**
+ * Walks over a {@link Document} in a SAX style,
+ * notifying listeners with SAX events.
+ *
+ * <p>
+ * Because the document has already been processed, only the following
+ * methods in the {@link ContentHandler} will be called:
+ * 
+ * <ul>
+ *   <li>{@link ContentHandler#startDocument()}</li>
+ *   <li>{@link ContentHandler#startPrefixMapping(String, String)}</li>
+ *   <li>{@link ContentHandler#startElement(String, String, String, Attributes)}</li>
+ *   <li>{@link ContentHandler#characters(char[], int, int)}</li>
+ *   <li>{@link ContentHandler#endElement(String, String, String)}</li>
+ *   <li>{@link ContentHandler#endPrefixMapping(String)}</li>
+ *   <li>{@link ContentHandler#endDocument()}</li>
+ * </ul>
+ * </p>
+ */
+final class SaxWalkerOverDom {
+
+  private List<ContentHandler> listeners;
+
+  private static class Attr {
+
+    final QName qName;
+    final String qualifiedName;
+    final String value;
+
+    Attr(String namespace, String localName, String qualName, String val) {
+      qName = new QName(namespace, localName);
+      qualifiedName = qualName;
+      value = val;
+    }
+
+    Attr(Node node) {
+      this(
+          node.getNamespaceURI(),
+          node.getLocalName(),
+          node.getNodeName(),
+          node.getNodeValue());
+    }
+  }
+
+  private static class DomAttrsAsSax implements org.xml.sax.Attributes {
+
+    private final List<Attr> attributes;
+    private final Map<String, Attr> attrsByQualifiedName;
+    private final Map<QName, Attr> attrsByQName;
+    private final Map<String, Integer> indexByQualifiedName;
+    private final Map<QName, Integer> indexByQName;
+
+    DomAttrsAsSax(NamedNodeMap domAttrs) throws SAXException {
+      attributes = new ArrayList<Attr>();
+      attrsByQualifiedName = new HashMap<String, Attr>();
+      attrsByQName = new HashMap<QName, Attr>();
+
+      indexByQualifiedName = new HashMap<String, Integer>();
+      indexByQName = new HashMap<QName, Integer>();
+
+      if (domAttrs != null) {
+        for (int attrIdx = 0; attrIdx < domAttrs.getLength(); ++attrIdx) {
+          final Node domAttr = domAttrs.item(attrIdx);
+
+          if (Constants.XMLNS_ATTRIBUTE_NS_URI.equals(
+              domAttr.getNamespaceURI())) {
+
+            // Namespace declarations will be handled separately.
+            continue;
+          }
+
+          final Attr attribute = new Attr(domAttr);
+          attributes.add(attribute);
+
+          attrsByQualifiedName.put(attribute.qualifiedName, attribute);
+          attrsByQName.put(attribute.qName, attribute);
+
+          indexByQualifiedName.put(attribute.qualifiedName, attrIdx);
+          indexByQName.put(attribute.qName, attrIdx);
+        }
+      }
+    }
+
+    @Override
+    public int getLength() {
+      return attributes.size();
+    }
+
+    @Override
+    public String getURI(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qName.getNamespaceURI();
+      }
+    }
+
+    @Override
+    public String getLocalName(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qName.getLocalPart();
+      }
+    }
+
+    @Override
+    public String getQName(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qualifiedName;
+      }
+    }
+
+    @Override
+    public String getType(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return "CDATA"; // We do not know the type information.
+      }
+    }
+
+    @Override
+    public String getValue(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).value;
+      }
+    }
+
+    @Override
+    public int getIndex(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return -1;
+      }
+
+      final QName qName = new QName(uri, localName);
+      final Integer index = indexByQName.get(qName);
+
+      if (index == null) {
+        return -1;
+      } else {
+        return index;
+      }
+    }
+
+    @Override
+    public int getIndex(String qName) {
+      if (qName == null) {
+        return -1;
+      }
+
+      final Integer index = indexByQualifiedName.get(qName);
+      if (index == null) {
+        return -1;
+      } else {
+        return index;
+      }
+    }
+
+    @Override
+    public String getType(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return null;
+      } else {
+        final Attr attr = attrsByQName.get( new QName(uri, localName) );
+        return (attr == null) ? null : "CDATA";
+      }
+    }
+
+    @Override
+    public String getType(String qName) {
+      if (qName == null) {
+        return null;
+      } else {
+        final Attr attr = attrsByQualifiedName.get(qName);
+        return (attr == null) ? null : "CDATA";
+      }
+    }
+
+    @Override
+    public String getValue(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return null;
+      } else {
+        final Attr attr = attrsByQName.get( new QName(uri, localName) );
+        return (attr == null) ? null : attr.value;
+      }
+    }
+
+    @Override
+    public String getValue(String qName) {
+      if (qName == null) {
+        return null;
+      } else {
+        final Attr attr = attrsByQualifiedName.get(qName);
+        return (attr == null) ? null : attr.value;
+      }
+    }
+  }
+
+  /**
+   * Constructs a new <code>SaxWalkerOverDom</code>.
+   */
+  SaxWalkerOverDom() {
+    listeners = null;
+  }
+
+  /**
+   * Constructs a new <code>SaxWalkerOverDom</code> with
+   * the provided {@link ContentHandler} to send SAX events.
+   *
+   * @param contentHandler The content handler to send events to.
+   */
+  SaxWalkerOverDom(ContentHandler contentHandler) {
+    this();
+    listeners = new ArrayList<ContentHandler>(1);
+    listeners.add(contentHandler);
+  }
+
+  /**
+   * Constructs a new <code>SaxWalkerOverDom</code>, taking ownership
+   * of the list of {@link ContentHandler}s to send events to.
+   *
+   * @param contentHandlers The list of content handlers to send events to.
+   */
+  SaxWalkerOverDom(List<ContentHandler> contentHandlers) {
+    this();
+    listeners = contentHandlers;
+  }
+
+  /**
+   * Adds the provided {@link ContentHandler} to the list of content
+   * handlers to send events to.  If this content handler was already
+   * added, it will be sent events twice (or more often).
+   *
+   * @param contentHandler The content handler to send events to.
+   */
+  void addContentHandler(ContentHandler contentHandler) {
+    if (listeners == null) {
+      listeners = new ArrayList<ContentHandler>(1);
+    }
+    listeners.add(contentHandler);
+  }
+
+  /**
+   * Removes the first instance of the provided {@link ContentHandler}
+   * from the set of handlers to send events to.  If the content handler
+   * was added more than once, it will continue to receive events.
+   *
+   * @param contentHandler The content handler to stop sending events to.
+   * @return <code>true</code> if it was found, <code>false</code> if not.
+   */
+  boolean removeContentHandler(ContentHandler contentHandler) {
+    if (listeners != null) {
+      return listeners.remove(contentHandler);
+    }
+    return false;
+  }
+
+  /**
+   * Walks the provided {@link Document}, sending events to all of the
+   * {@link ContentHandler}s as it traverses.  If there are no content
+   * handlers, this method is a no-op.
+   *
+   * @param document The {@link Document} to traverse.
+   * @param systemId The system ID of this {@link Document}.
+   * @throws SAXException if an exception occurs when notifying the handlers.
+   */
+  void walk(Document document) throws SAXException {
+    if (document == null) {
+      throw new IllegalArgumentException("Document cannot be null.");
+    }
+
+    if ((listeners == null) || listeners.isEmpty()) {
+      return;
+    }
+
+    for (ContentHandler listener : listeners) {
+      listener.startDocument();
+    }
+
+    final List<String> prefixes = startPrefixMappings(document);
+
+    walk( document.getDocumentElement() );
+
+    for (ContentHandler listener : listeners) {
+      for (String prefix : prefixes) {
+        listener.endPrefixMapping(prefix);
+      }
+      listener.endDocument();
+    }
+  }
+
+  private void walk(Element element) throws SAXException {
+    DomAttrsAsSax attrs = new DomAttrsAsSax( element.getAttributes() );
+
+    final List<String> prefixes = startPrefixMappings(element);
+
+    for (ContentHandler listener : listeners) {
+      listener.startElement(
+          convertNullToEmptyString(element.getNamespaceURI()),
+          convertNullToEmptyString(element.getLocalName()),
+          convertNullToEmptyString(element.getNodeName()),
+          attrs);
+    }
+
+    NodeList children = element.getChildNodes();
+
+    for (int childIndex = 0; childIndex < children.getLength(); ++childIndex) {
+      Node node = children.item(childIndex);
+      if (node instanceof Element) {
+        walk((Element) node);
+      } else if (node instanceof Text) {
+        walk((Text) node);
+      } else if (node instanceof org.w3c.dom.Comment) {
+        // Ignored.
+      } else {
+        throw new SAXException(
+            "Unrecognized child of "
+            + element.getTagName()
+            + " of type "
+            + node.getClass().getName());
+      }
+    }
+
+    for (ContentHandler listener : listeners) {
+      listener.endElement(
+          convertNullToEmptyString(element.getNamespaceURI()),
+          convertNullToEmptyString(element.getLocalName()),
+          convertNullToEmptyString(element.getNodeName()));
+
+      for (String prefix : prefixes) {
+        listener.endPrefixMapping(prefix);
+      }
+    }
+  }
+
+  private void walk(Text text) throws SAXException {
+    /* TODO: getData() may throw a org.w3c.dom.DOMException if the actual text
+     * data is too large to fit into a single DOMString (the DOM impl's
+     * internal storage of text data).  If that's the case, substringData()
+     * must be called to retrieve the data in pieces.
+     *
+     * The documentation does not supply information on the maximum DOMString
+     * size; it appears to require trial & error.
+     */
+    if (text.getLength() > 0) {
+      char[] data = text.getData().toCharArray();
+      for (ContentHandler listener : listeners) {
+        listener.characters(data, 0, data.length);
+      }
+    }
+  }
+
+  private static String convertNullToEmptyString(String input) {
+    if (input == null) {
+      return "";
+    }
+    return input;
+  }
+
+  private List<String> startPrefixMappings(Node node)
+      throws SAXException {
+
+    switch (node.getNodeType()) {
+    case Node.DOCUMENT_NODE:
+    case Node.ELEMENT_NODE:
+      break;
+    default:
+      throw new IllegalArgumentException(
+          "Cannot start prefix mappings for a node of type "
+          + node.getNodeType());
+    }
+
+    final ArrayList<String> prefixes = new ArrayList<String>();
+
+    final NamedNodeMap attrs = node.getAttributes();
+    if (attrs == null) {
+      return prefixes;
+    }
+
+    for (int attrIndex = 0; attrIndex < attrs.getLength(); ++attrIndex) {
+      final Node attr = attrs.item(attrIndex);
+      final String attrUri = attr.getNamespaceURI();
+
+      if ( Constants.XMLNS_ATTRIBUTE_NS_URI.equals(attrUri) ) {
+        final String localName = attr.getLocalName();
+        String prefix = null;
+
+        if (Constants.XMLNS_ATTRIBUTE.equals(localName)) {
+          prefix = Constants.DEFAULT_NS_PREFIX;
+        } else {
+          prefix = localName;
+        }
+
+        prefixes.add(prefix);
+
+        for (ContentHandler listener : listeners) {
+          listener.startPrefixMapping(prefix, attr.getNodeValue());
+        }
+      }
+    }
+
+    return prefixes;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/Utils.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/Utils.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/Utils.java	(working copy)
@@ -0,0 +1,514 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.avro.xml;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.math.MathContext;
+import java.net.URISyntaxException;
+import java.net.URI;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+
+import org.apache.avro.Schema;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.codehaus.jackson.JsonNode;
+import org.codehaus.jackson.node.IntNode;
+import org.codehaus.jackson.node.NumericNode;
+import org.codehaus.jackson.node.TextNode;
+
+/**
+ * A set of utilities for encoding and
+ * decoding XML Documents and Avro data.
+ */
+class Utils {
+
+  private static final int UNDERSCORE_CP = '_';
+  private static final int PERIOD_CP = '.';
+
+  private static final Map<QName, Schema.Type> XML_TO_AVRO_TYPES =
+      new HashMap<QName, Schema.Type>();
+
+  static {
+    XML_TO_AVRO_TYPES.put(Constants.XSD_ANYTYPE,       Schema.Type.STRING);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_BOOLEAN,       Schema.Type.BOOLEAN);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_DECIMAL,       Schema.Type.BYTES);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_DOUBLE,        Schema.Type.DOUBLE);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_FLOAT,         Schema.Type.FLOAT);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_BASE64,        Schema.Type.BYTES);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_HEXBIN,        Schema.Type.BYTES);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_LONG,          Schema.Type.LONG);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_ID,            Schema.Type.STRING);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_INT,           Schema.Type.INT);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_UNSIGNEDINT,   Schema.Type.LONG);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_UNSIGNEDSHORT, Schema.Type.INT);
+    XML_TO_AVRO_TYPES.put(Constants.XSD_QNAME,         Schema.Type.RECORD);
+  }
+
+  static Set<QName> getAvroRecognizedTypes() {
+    return XML_TO_AVRO_TYPES.keySet();
+  }
+
+  static Schema.Type getAvroSchemaTypeFor(QName qName) {
+    return XML_TO_AVRO_TYPES.get(qName);
+  }
+
+  static Schema getAvroSchemaFor(
+      XmlSchemaTypeInfo typeInfo,
+      QName qName,
+      boolean isOptional) {
+
+    switch ( typeInfo.getType() ) {
+    case ATOMIC:
+      {
+        Schema schema = null;
+        if ( isValidEnum(typeInfo) ) {
+          // This is an enumeration!
+          final HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+            facets = typeInfo.getFacets();
+
+          String ns = null;
+          try {
+            ns = Utils.getAvroNamespaceFor(qName.getNamespaceURI()) + ".enums";
+          } catch (URISyntaxException e) {
+            throw new IllegalArgumentException(
+                qName + " does not have a valid namespace.", e);
+          }
+
+          final List<XmlSchemaRestriction> enumFacet =
+              facets.get(XmlSchemaRestriction.Type.ENUMERATION);
+
+          final ArrayList<String> symbols =
+              new ArrayList<String>( enumFacet.size() );
+          for (XmlSchemaRestriction enumSym : enumFacet) {
+            symbols.add( enumSym.getValue().toString() );
+          }
+
+          schema =
+              Schema.createEnum(
+                  qName.getLocalPart(),
+                  "Enumeration of symbols in " + qName,
+                  ns,
+                  symbols);
+
+        } else if (
+            typeInfo.getBaseType().equals(XmlSchemaBaseSimpleType.QNAME)) {
+
+          /* QNames will be represented as a RECORD
+           * with a namespace and a local part.
+           */
+          final List<Schema.Field> fields = new ArrayList<Schema.Field>(2);
+          fields.add(
+              new Schema.Field(
+                  "namespace",
+                  Schema.create(Schema.Type.STRING),
+                  "The namespace of this qualified name.",
+                  null) );
+
+          fields.add(
+              new Schema.Field(
+                  "localPart",
+                  Schema.create(Schema.Type.STRING),
+                  "The local part of this qualified name.",
+                  null) );
+
+          String ns = null;
+          try {
+            ns = Utils.getAvroNamespaceFor( Constants.URI_2001_SCHEMA_XSD );
+          } catch (URISyntaxException e) {
+            throw new IllegalStateException(
+                "Cannot create an Avro namespace for "
+                + Constants.URI_2001_SCHEMA_XSD);
+          }
+
+          schema =
+              Schema.createRecord("qName", "Qualified Name", ns, false);
+          schema.setFields(fields);
+
+        } else {
+
+          final Schema.Type avroType =
+            XML_TO_AVRO_TYPES.get( typeInfo.getUserRecognizedType() );
+  
+          if (avroType == null) {
+            throw new IllegalArgumentException(
+                "No Avro type recognized for "
+                + typeInfo.getUserRecognizedType());
+          }
+  
+          schema = Schema.create(avroType);
+
+          // DECIMAL is a logical type.
+          if (schema.getType().equals(Schema.Type.BYTES)
+              && typeInfo
+                   .getBaseType()
+                   .equals(XmlSchemaBaseSimpleType.DECIMAL)) {
+
+            /* If there is a restriction on the number of fraction
+             * and/or total digits, we need to respect it.
+             */
+            int scale = 8;
+            int precision = MathContext.DECIMAL128.getPrecision();
+
+            HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+              facets = typeInfo.getFacets();
+
+            if (facets != null) {
+
+              // Fraction Digits are the scale
+              final List<XmlSchemaRestriction> fractionDigitsFacets =
+                  facets.get(XmlSchemaRestriction.Type.DIGITS_FRACTION);
+
+              if ((fractionDigitsFacets != null)
+                  && !fractionDigitsFacets.isEmpty()) {
+
+                final XmlSchemaRestriction fractionDigitsFacet =
+                    fractionDigitsFacets.get(0);
+
+                final Object value = fractionDigitsFacet.getValue();
+                if (value instanceof Number) {
+                  scale = ((Number) value).intValue();
+                } else {
+                  try {
+                    scale = Integer.parseInt(value.toString());
+                  } catch (NumberFormatException nfe) {
+                    throw new IllegalStateException(
+                        "Fraction digits facet is not a number: " + value);
+                  }
+                }
+              }
+
+              // Total Digits are the precision
+              final List<XmlSchemaRestriction> totalDigitsFacets =
+                  facets.get(XmlSchemaRestriction.Type.DIGITS_TOTAL);
+              if ((totalDigitsFacets != null)
+                  && !totalDigitsFacets.isEmpty()) {
+
+                final XmlSchemaRestriction totalDigitsFacet =
+                    fractionDigitsFacets.get(0);
+
+                final Object value = totalDigitsFacet.getValue();
+                if (value instanceof Number) {
+                  precision = ((Number) value).intValue();
+                } else {
+                  try {
+                    precision = Integer.parseInt(value.toString());
+                  } catch (NumberFormatException nfe) {
+                    throw new IllegalStateException(
+                        "Total digits facet is not a number: " + value);
+                  }
+                }
+              }
+            }
+
+            schema.addProp("logicalType", new TextNode("decimal"));
+
+            schema.addProp("scale", new IntNode(scale));
+
+            schema.addProp("precision", new IntNode(precision));
+          }
+        }
+
+        return createSchemaOf(schema, isOptional, typeInfo.isMixed());
+      }
+    case LIST:
+      {
+        Schema schema =
+            Schema.createArray(
+                getAvroSchemaFor(
+                    typeInfo.getChildTypes().get(0), qName, false) );
+
+        return createSchemaOf(schema, isOptional, typeInfo.isMixed());
+      }
+    case UNION:
+      {
+        List<XmlSchemaTypeInfo> unionTypes = typeInfo.getChildTypes();
+        List<Schema> avroTypes =
+            new ArrayList<Schema>(unionTypes.size() + 2);
+
+        for (XmlSchemaTypeInfo unionType : unionTypes) {
+          final Schema avroSchema = getAvroSchemaFor(unionType, qName, false);
+          if ( !avroTypes.contains(avroSchema) ) {
+            avroTypes.add(avroSchema);
+          }
+        }
+
+        if (isOptional) {
+          final Schema avroSchema = Schema.create(Schema.Type.NULL);
+          if ( !avroTypes.contains(avroSchema) ) {
+            avroTypes.add(avroSchema);
+          }
+        }
+        if ( typeInfo.isMixed() ) {
+          final Schema avroSchema = Schema.create(Schema.Type.STRING);
+          if ( !avroTypes.contains(avroSchema) ) {
+            avroTypes.add(avroSchema);
+          }
+        }
+
+        return Schema.createUnion(avroTypes);
+      }
+    case COMPLEX:
+      {
+        if ( typeInfo.isMixed() ) {
+          return Schema.create(Schema.Type.STRING);
+        }
+        /* falls through */
+      }
+    default:
+      throw new IllegalArgumentException(
+          "Cannot create an Avro schema for a "
+          + typeInfo.getType()
+          + " type.");
+    }
+  }
+
+  private static Schema createSchemaOf(
+      Schema schema,
+      boolean isOptional,
+      boolean isMixed) {
+
+    if (!isOptional && !isMixed) {
+      return schema;
+    }
+    List<Schema> unionTypes = new ArrayList<Schema>(2);
+    unionTypes.add(schema);
+    if (isOptional) {
+      unionTypes.add( Schema.create(Schema.Type.NULL) );
+    }
+    if (isMixed) {
+      unionTypes.add( Schema.create(Schema.Type.STRING) );
+    }
+    schema = Schema.createUnion(unionTypes);
+    return schema;
+  }
+
+  private static boolean isValidEnum(XmlSchemaTypeInfo typeInfo) {
+    final HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+      facets = typeInfo.getFacets();
+
+    if (facets == null) {
+      return false;
+    }
+
+    final List<XmlSchemaRestriction> enumFacets =
+        facets.get(XmlSchemaRestriction.Type.ENUMERATION);
+
+    if (enumFacets == null) {
+      return false;
+    }
+
+    for (XmlSchemaRestriction enumFacet : enumFacets) {
+      final String symbol = enumFacet.getValue().toString();
+
+      final int length = symbol.length();
+      for (int offset = 0; offset < length; ) {
+        final int codepoint = symbol.codePointAt(offset);
+        if (!Character.isLetterOrDigit(codepoint)
+            && (codepoint != UNDERSCORE_CP)) {
+          return false;
+        }
+
+        offset += Character.charCount(codepoint);
+      }
+    }
+
+    return true;
+  }
+
+  static XmlSchemaTypeInfo chooseUnionType(
+      XmlSchemaTypeInfo xmlType,
+      QName typeQName,
+      Schema elemType,
+      int unionIndex) {
+
+    XmlSchemaTypeInfo xmlElemType = xmlType;
+    if (xmlType.getChildTypes().size() <= unionIndex) {
+      xmlElemType = null;
+    } else {
+      for (XmlSchemaTypeInfo childType : xmlType.getChildTypes()) {
+        final Schema avroSchemaOfChildType =
+            Utils.getAvroSchemaFor(childType, typeQName, false);
+        if ( avroSchemaOfChildType.equals(elemType) ) {
+          xmlElemType = childType;
+          break;
+        }
+      }
+    }
+    return xmlElemType;
+
+  }
+
+  static String getAvroNamespaceFor(String xmlSchemaNamespace)
+      throws URISyntaxException {
+
+    return getAvroNamespaceFor(new URI(xmlSchemaNamespace));
+  }
+
+  static String getAvroNamespaceFor(URL xmlSchemaNamespace)
+      throws URISyntaxException {
+
+    return getAvroNamespaceFor( xmlSchemaNamespace.toURI() );
+  }
+
+  static String getAvroNamespaceFor(java.net.URI uri) {
+    final ArrayList<String> components = new ArrayList<String>();
+
+    // xsd.example.org -> org.example.xsd
+    final String host = uri.getHost();
+    if (host != null) {
+      String[] hostParts = host.split("\\.");
+      for (int hpIdx = hostParts.length - 1; hpIdx >= 0; --hpIdx) {
+        if ( !hostParts[hpIdx].isEmpty() ) {
+          components.add(hostParts[hpIdx]);
+        }
+      }
+    }
+
+    // path/to/schema.xsd -> path.to.schema.xsd
+    final String path = uri.getPath();
+    if (path != null) {
+      final String[] pathParts = path.split("/");
+      for (String pathPart : pathParts) {
+        if ( !pathPart.isEmpty() ) {
+          components.add(pathPart);
+        }
+      }
+    }
+
+    /* This URI is of the form a:b:c:d:e.
+     * We can convert that to a.b.c.d.e.
+     */
+    if ( components.isEmpty() ) {
+      final String schemeSpecificPart = uri.getSchemeSpecificPart();
+      final String[] schemeParts = schemeSpecificPart.split("\\:");
+
+      for (String schemePart : schemeParts) {
+        if ( !schemePart.isEmpty() ) {
+          components.add(schemePart);
+        }
+      }
+    }
+
+    if ( components.isEmpty() ) {
+      throw new IllegalArgumentException(
+          "URI \"" + uri.toString()
+          + "\" does not have enough content to create a namespace for it.");
+    }
+
+    StringBuilder namespace = new StringBuilder(components.get(0));
+    for (int c = 1; c < components.size(); ++c) {
+      namespace.append('.').append( createValidName( components.get(c) ) );
+    }
+
+    return namespace.toString();
+  }
+
+  private static String createValidName(String component) {
+    StringBuilder str = new StringBuilder();
+    final int length = component.length();
+    for (int offset = 0; offset < length; ) {
+      final int codepoint = component.codePointAt(offset);
+      if (!Character.isLetterOrDigit(codepoint)
+          && (codepoint != UNDERSCORE_CP)
+          && (codepoint != PERIOD_CP)) {
+        str.append('_');
+      } else {
+        str.append( Character.toChars(codepoint) );
+      }
+
+      offset += Character.charCount(codepoint);
+    }
+    return str.toString();
+  }
+
+  static BigDecimal createBigDecimalFrom(byte[] bytes, Schema schema) {
+    confirmIsValidDecimal(schema);
+    return new BigDecimal(
+        new BigInteger(bytes),
+        getScaleFrom(schema),
+        getMathContextFrom(schema));
+  }
+
+  static BigDecimal createBigDecimalFrom(String text, Schema schema) {
+    confirmIsValidDecimal(schema);
+    final int scale = getScaleFrom(schema);
+    final MathContext mathContext = getMathContextFrom(schema);
+    BigDecimal decimal = new BigDecimal(text, mathContext);
+    if (decimal.scale() != scale) {
+      decimal = decimal.setScale(scale, mathContext.getRoundingMode());
+    }
+    return decimal;
+  }
+
+  private static void confirmIsValidDecimal(Schema schema) {
+    final JsonNode logicalTypeNode = schema.getJsonProp("logicalType");
+    if (logicalTypeNode == null) {
+      throw new IllegalStateException(
+          "Attempted to read an XML Schema DECIMAL as an Avro "
+          + "logical type, but the logical type is missing!");
+
+    } else if (!"decimal".equals(logicalTypeNode.asText())) {
+      throw new IllegalStateException(
+          "Attempted to read an XML Schema DECIMAL as an Avro logical "
+          + "type, but the logical type is " + logicalTypeNode);
+    }
+  }
+
+  private static int getScaleFrom(Schema schema) {
+    int scale = 0;
+
+    final JsonNode scaleNode = schema.getJsonProp("scale");
+    if (scaleNode != null) {
+      if (!(scaleNode instanceof NumericNode)) {
+        throw new IllegalStateException(
+            "Attempted to read an XML Schema DECIMAL as an Avro logical "
+                + "type, but the scale is not a number! Found: "
+                + scaleNode);
+      }
+
+      scale = scaleNode.asInt();
+    }
+
+    return scale;
+  }
+
+  private static MathContext getMathContextFrom(Schema schema) {
+    final JsonNode precisionNode = schema.getJsonProp("precision");
+
+    if (precisionNode == null) {
+      throw new IllegalArgumentException(
+          "Attempted to read an XML Schema DECIMAL as an Avro "
+          + "logical type, but the precision is missing!");
+
+    } else if (!(precisionNode instanceof NumericNode)) {
+      throw new IllegalArgumentException(
+          "Attempted to read an XML Schema DECIMAL as an Avro logical "
+              + "type, but the precision is not a number! Found: "
+              + precisionNode);
+    }
+
+    return new MathContext( precisionNode.asInt() );
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumConfig.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumConfig.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumConfig.java	(working copy)
@@ -0,0 +1,218 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+import javax.xml.transform.stream.StreamSource;
+
+/**
+ * Configuration for setting up the {@link XmlDatumWriter}.  XML Schemas may
+ * be defined by {@link java.net.URL}s and/or {@link java.io.File}s, and the
+ * name of the XML Document's root tag {@link javax.xml.namespace.QName} is
+ * needed to determine how to parse the XML Schema or Schemas.
+ *
+ * <p>
+ * When using files, a Schema URI is required.  If the Schema contains
+ * references to incomplete paths, this URI will be used to track them
+ * down.
+ * </p>
+ */
+public class XmlDatumConfig {
+
+  private ArrayList<URL> schemaUrls;
+  private ArrayList<File> schemaFiles;
+  private String baseUri;
+  private QName baseTagName;
+
+  private XmlDatumConfig(QName rootTagName) {
+    baseTagName = rootTagName;
+    schemaUrls = null;
+    schemaFiles = null;
+    baseUri = null;
+  }
+
+  /**
+   * Creates a new <code>XmlDatumConfig</code> from the {@link java.net.URL}
+   * to fetch the XML Schema from and the {@link QName} representing the
+   * root element.
+   *
+   * @param schema      The URL of the XML Schema to read.
+   * @param rootTagName The <code>QName</code> of the root element.
+   */
+  public XmlDatumConfig(URL schema, QName rootTagName) {
+    this(rootTagName);
+    schemaUrls = new ArrayList<URL>(1);
+    schemaUrls.add(schema);
+    baseUri = getBaseUriFor(schema);
+  }
+
+  /**
+   * Creates a new <code>XmlDatumConfig</code> from a local {@link File}
+   * to read the XML Schema from and the {@link QName} representing the
+   * root element.  A base URI is also required as the default path to
+   * fetch any referenced schemas from.
+   *
+   * @param schema        The path to the XML Schema to read.
+   *
+   * @param schemaBaseUri The base URI of the schema - a default URI of
+   *                      where to retrieve other referenced schemas.
+   *
+   * @param rootTagName   The <code>QName</code> of the root element.
+   */
+  public XmlDatumConfig(File schema, String schemaBaseUri, QName rootTagName) {
+    this(rootTagName);
+
+    schemaFiles = new ArrayList<File>(1);
+    schemaFiles.add(schema);
+    baseUri = schemaBaseUri;
+  }
+
+  /**
+   * <p>
+   * The base URI.  If this <code>XmlDatumConfig</code> was created with a
+   * URL, the base URI is the URL up to, but not including the schema file
+   * name.
+   * </p>
+   * <p>
+   * If the <code>XmlDatumConfig</code> was created with a <code>File</code>,
+   * this is the <code>schemaBaseUri</code> provided in that constructor.
+   * </p>
+   */
+  public String getBaseUri() {
+    return baseUri;
+  }
+
+  /**
+   * The list of XML Schema URLs provided via
+   * {@link #XmlDatumConfig(URL, QName)} and
+   * any subsequent calls to
+   * {@link #addSchemaUrl(URL)}.
+   */
+  public List<URL> getSchemaUrls() {
+    return schemaUrls;
+  }
+
+  /**
+   * The list of XML Schema files provided via
+   * {@link #XmlDatumConfig(File, String, QName)}
+   * and any subsequent calls to
+   * {@link #addSchemaFile(File)}.
+   */
+  public List<File> getSchemaFiles() {
+    return schemaFiles;
+  }
+
+  /**
+   * The XML Schema's root tag passed into the constructor.
+   */
+  public QName getRootTagName() {
+    return baseTagName;
+  }
+
+  /**
+   * Adds a URL to an XML Schema to include when generating Avro.
+   */
+  public void addSchemaUrl(URL schemaUrl) {
+    if (schemaUrls == null) {
+      schemaUrls = new ArrayList<URL>(1);
+    }
+    schemaUrls.add(schemaUrl);
+  }
+
+  /**
+   * Adds a file path to an XML Schema to include when generating Avro.
+   */
+  public void addSchemaFile(File file) {
+    if (schemaFiles == null) {
+      schemaFiles = new ArrayList<File>(1);
+    }
+    schemaFiles.add(file);
+  }
+
+  @SuppressWarnings("resource")
+  List<StreamSource> getSources() throws IOException {
+    final ArrayList<StreamSource> sources =
+        new ArrayList<StreamSource>( getArraySize() );
+    try {
+      if (schemaUrls != null) {
+        for (URL schemaUrl : schemaUrls) {
+          final StreamSource source =
+            new StreamSource(
+              schemaUrl.openStream(),
+              schemaUrl.toString());
+          sources.add(source);
+        }
+      }
+      if (schemaFiles != null) {
+        for (File schemaFile : schemaFiles) {
+          final StreamSource source =
+            new StreamSource(
+              new FileReader(schemaFile),
+              schemaFile.getName());
+          sources.add(source);
+        }
+      }
+    } catch (IOException ioe) {
+      for (StreamSource source : sources) {
+        try {
+          if (source.getInputStream() != null) {
+            source.getInputStream().close();
+          } else {
+            source.getReader().close();
+          }
+        } catch (IOException failedClose) {
+          failedClose.printStackTrace();
+        }
+      }
+      throw ioe;
+    }
+    return sources;
+  }
+
+  private int getArraySize() {
+    int count = 0;
+    if (schemaUrls != null) {
+      count += schemaUrls.size();
+    }
+    if (schemaFiles != null) {
+      count += schemaFiles.size();
+    }
+    return count;
+  }
+
+  private static String getBaseUriFor(URL url) {
+    StringBuilder namespace = new StringBuilder( url.getProtocol() );
+    namespace.append("://").append( url.getHost() );
+    if (url.getPort() != -1) {
+      namespace.append(':').append( url.getPort() );
+    }
+    namespace.append( url.getPath() );
+
+    String namespaceWithFile = namespace.toString();
+    int lastSlashBeforeFileIndex = namespaceWithFile.lastIndexOf('/');
+
+    return namespaceWithFile.substring(0, lastSlashBeforeFileIndex + 1);
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumReader.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumReader.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumReader.java	(working copy)
@@ -0,0 +1,1238 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.bind.DatatypeConverter;
+import javax.xml.namespace.QName;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.avro.Schema;
+import org.apache.avro.io.DatumReader;
+import org.apache.avro.io.Decoder;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.codehaus.jackson.JsonNode;
+import org.w3c.dom.Document;
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+
+/**
+ * Reads an XML {@link Document} from a {@link Decoder}.
+ * If the {@link Schema} can be conformed to, it will be.
+ *
+ * <p>
+ * This currently requires an {@link Schema} generated by
+ * {@link XmlDatumWriter}.  The XML -> Avro conversion is
+ * lossy and the additional encoded information is the only
+ * way to reconstruct the original XML document.
+ * </p>
+ */
+public class XmlDatumReader implements DatumReader<Document> {
+
+  private Schema inputSchema;
+  private XmlSchemaCollection xmlSchemaCollection;
+  private HashMap<String, String> namespaceToLocationMapping;
+  private List<ContentHandler> contentHandlers;
+  private DomBuilderFromSax domBuilder;
+  private Map<AvroRecordName, XmlSchemaStateMachineNode> stateByAvroName;
+  private XmlSchemaNamespaceContext nsContext;
+  private int currNsNum;
+  private ArrayList<QName> newlyAddedQNamesToNs;
+  private ByteBuffer bytesBuffer;
+
+  private static class AvroRecordName implements Comparable<AvroRecordName> {
+
+    private String name;
+    private String namespace;
+
+    AvroRecordName(QName xmlQName) throws URISyntaxException {
+      namespace = Utils.getAvroNamespaceFor(xmlQName.getNamespaceURI());
+      name = xmlQName.getLocalPart();
+    }
+
+    AvroRecordName(String recordNamespace, String recordName) {
+      namespace = recordNamespace;
+      name = recordName;
+    }
+
+    /**
+     * Generates a hash code representing this <code>AvroRecordName</code>.
+     *
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      result =
+        prime * result
+        + ((name == null) ? 0 : name.hashCode());
+
+      result =
+        prime * result
+        + ((namespace == null) ? 0 : namespace.hashCode());
+
+      return result;
+    }
+
+    /**
+     * Compares this <code>AvroRecordName</code> to another one for equality.
+     *
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null) {
+        return false;
+      }
+      if (!(obj instanceof AvroRecordName)) {
+        return false;
+      }
+      AvroRecordName other = (AvroRecordName) obj;
+      if (name == null) {
+        if (other.name != null) {
+          return false;
+        }
+      } else if (!name.equals(other.name)) {
+        return false;
+      }
+      if (namespace == null) {
+        if (other.namespace != null) {
+          return false;
+        }
+      } else if (!namespace.equals(other.namespace)) {
+        return false;
+      }
+      return true;
+    }
+
+    /**
+     * Compares this <code>AvroRecordName</code> to another for
+     * relative ordering.  Namespaces are compared first, followed
+     * by names.
+     *
+     * @param o The other record to compare against.
+     *
+     * @return A number less than zero if this entry is the lesser,
+     *         a number greater than zero if this entry is the greater,
+     *         or zero if the two are equivalent.
+     *
+     * @see Comparable#compareTo(Object)
+     */
+    @Override
+    public int compareTo(AvroRecordName o) {
+
+      // 1. Compare Namespaces.
+      if ((namespace == null) && (o.namespace != null)) {
+        return -1;
+      } else if ((namespace != null) && (o.namespace == null)) {
+        return 1;
+      } else if ((namespace != null) && (o.namespace != null)) {
+        final int nsCompare = namespace.compareTo(o.namespace);
+        if (nsCompare != 0) {
+          return nsCompare;
+        }
+      }
+
+      // Either both namespaces are null, or they are equal to each other.
+
+      // 2. Compare Names.
+      if ((name == null) && (o.name != null)) {
+        return -1;
+      } else if ((name != null) && (o.name == null)) {
+        return 1;
+      } else if ((name != null) && (o.name != null)) {
+        final int nmCompare = name.compareTo(o.name);
+        if (nmCompare != 0) {
+          return nmCompare;
+        }
+      }
+
+      // Either both names are null, or both are equal.
+
+      return 0;
+    }
+
+    @Override
+    public String toString() {
+      return '{' + namespace + '}' + name;
+    }
+  }
+
+  private static class AvroAttribute {
+
+    final QName qName;
+    final String qualifiedName;
+    final String value;
+
+    AvroAttribute(
+      String namespace,
+      String localName,
+      String qualName,
+      String val) {
+
+      qName = new QName(namespace, localName);
+      qualifiedName = qualName;
+      value = val;
+    }
+  }
+
+  private static class AvroAttributes implements Attributes {
+
+    private final List<AvroAttribute> attributes;
+    private final Map<String, AvroAttribute> attrsByQualifiedName;
+    private final Map<QName, AvroAttribute> attrsByQName;
+    private final Map<String, Integer> indexByQualifiedName;
+    private final Map<QName, Integer> indexByQName;
+
+    AvroAttributes() {
+      attributes = new ArrayList<AvroAttribute>();
+      attrsByQualifiedName = new HashMap<String, AvroAttribute>();
+      attrsByQName = new HashMap<QName, AvroAttribute>();
+
+      indexByQualifiedName = new HashMap<String, Integer>();
+      indexByQName = new HashMap<QName, Integer>();
+    }
+
+    void addAttribute(AvroAttribute attr) {
+      attrsByQualifiedName.put(attr.qualifiedName, attr);
+      attrsByQName.put(attr.qName, attr);
+
+      indexByQualifiedName.put(attr.qualifiedName, attributes.size());
+      indexByQName.put(attr.qName, attributes.size());
+
+      attributes.add(attr);
+    }
+
+    @Override
+    public int getLength() {
+      return attributes.size();
+    }
+
+    @Override
+    public String getURI(int index) {
+      if (attributes.size() <= index) {
+       return null;
+      } else {
+        return attributes.get(index).qName.getNamespaceURI();
+      }
+    }
+
+    @Override
+    public String getLocalName(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qName.getLocalPart();
+      }
+    }
+
+    @Override
+    public String getQName(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qualifiedName;
+      }
+    }
+
+    @Override
+    public String getType(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return "CDATA"; // We do not know the type information.
+      }
+    }
+
+    @Override
+    public String getValue(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).value;
+      }
+    }
+
+    @Override
+    public int getIndex(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return -1;
+      }
+
+      final QName qName = new QName(uri, localName);
+      final Integer index = indexByQName.get(qName);
+
+      if (index == null) {
+        return -1;
+      } else {
+        return index;
+      }
+    }
+
+    @Override
+    public int getIndex(String qName) {
+      if (qName == null) {
+        return -1;
+      }
+
+      final Integer index = indexByQualifiedName.get(qName);
+      if (index == null) {
+        return -1;
+      } else {
+        return index;
+      }
+    }
+
+    @Override
+    public String getType(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return null;
+      } else {
+        final AvroAttribute attr =
+            attrsByQName.get( new QName(uri, localName) );
+        return (attr == null) ? null : "CDATA";
+      }
+    }
+
+    @Override
+    public String getType(String qName) {
+      if (qName == null) {
+        return null;
+      } else {
+        final AvroAttribute attr = attrsByQualifiedName.get(qName);
+        return (attr == null) ? null : "CDATA";
+      }
+    }
+
+    @Override
+    public String getValue(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return null;
+      } else {
+        final AvroAttribute attr =
+            attrsByQName.get( new QName(uri, localName) );
+        return (attr == null) ? null : attr.value;
+      }
+    }
+
+    @Override
+    public String getValue(String qName) {
+      if (qName == null) {
+        return null;
+      } else {
+        final AvroAttribute attr = attrsByQualifiedName.get(qName);
+        return (attr == null) ? null : attr.value;
+      }
+    }
+  }
+
+  /**
+   * Creates an {@link XmlDatumReader} with the {@link XmlSchemaCollection}
+   * to use when decoding XML {@link Document}s from {@link Decoder}s.
+   */
+  public XmlDatumReader() {
+    inputSchema = null;
+    xmlSchemaCollection = null;
+    namespaceToLocationMapping = null;
+    contentHandlers = null;
+    domBuilder = null;
+    bytesBuffer = null;
+    nsContext = new XmlSchemaNamespaceContext();
+  }
+
+  /**
+   * Sets the {@link Schema} that defines how data will be read from the
+   * {@link Decoder} when {@link #read(Document, Decoder)} is called.
+   *
+   * <p>
+   * Checks the input {@link Schema} conforms with the provided
+   * {@link XmlSchemaCollection}.  If <code>schema</code> does not conform,
+   * an {@link IllegalArgumentException} is thrown.
+   * </p>
+   *
+   * @throws IllegalArgumentException if the schema is <code>null</code> or
+   *                                  does not conform to the corresponding
+   *                                  XML schema.
+   *
+   * @see org.apache.avro.io.DatumReader#setSchema(org.apache.avro.Schema)
+   */
+  @Override
+  public void setSchema(Schema schema) {
+    if (schema == null) {
+      throw new IllegalArgumentException("Input schema cannot be null.");
+    }
+
+    JsonNode xmlSchemasNode = schema.getJsonProp("xmlSchemas");
+
+    if ((xmlSchemasNode == null)
+        && schema.getType().equals(Schema.Type.UNION)) {
+      /* The root node is a substitution group; the
+       * xmlSchemasNode was stored with its first child. 
+       */
+      xmlSchemasNode = schema.getTypes().get(0).getJsonProp("xmlSchemas");
+    }
+
+    if (xmlSchemasNode == null) {
+      throw new IllegalArgumentException(
+          "Avro schema must be created by XmlDatumWriter for it to be used"
+          + " with XmlDatumReader.");
+    }
+
+    nsContext.clear();
+    currNsNum = 0;
+
+    final JsonNode baseUriNode = xmlSchemasNode.get("baseUri");
+    final JsonNode urlsNode    = xmlSchemasNode.get("urls");
+    final JsonNode filesNode   = xmlSchemasNode.get("files");
+    final JsonNode rootTagNode = xmlSchemasNode.get("rootTag");
+
+    XmlDatumConfig config = null;
+
+    // 1. Build the root tag QName.
+    QName rootTagQName = buildQNameFrom(rootTagNode);
+
+    // 2. Build the list of schema files.
+    if (filesNode != null) {
+      String baseUri = null;
+      if (baseUriNode != null) {
+        baseUri = baseUriNode.getTextValue();
+      }
+      if (baseUri == null) {
+        throw new IllegalArgumentException(
+            "When building an XML Schema from files, a Base URI is "
+            + "required and must be in a text JSON node.");
+      }
+
+      final List<File> files = buildFileListFrom(filesNode);
+      if ( !files.isEmpty() ) {
+           config = new XmlDatumConfig(files.get(0), baseUri, rootTagQName);
+
+              for (int fileIndex = 1; fileIndex < files.size(); ++fileIndex) {
+                config.addSchemaFile( files.get(fileIndex) );
+              }
+            }
+          }
+
+          // 3. Build the list of schema URLs.
+          if (urlsNode != null) {
+            List<URL> urls = buildUrlListFrom(urlsNode);
+
+            if ( !urls.isEmpty() ) {
+            int startIndex = 0;
+            if (config == null) {
+              startIndex = 1;
+              config = new XmlDatumConfig(urls.get(0), rootTagQName);
+            }
+
+            for (int urlIndex = startIndex; urlIndex < urls.size(); ++urlIndex) {
+              config.addSchemaUrl( urls.get(urlIndex) );
+            }
+            }
+          }
+
+          if (config == null) {
+            throw new IllegalArgumentException(
+                "At least one XML Schema file or URL must be defined in the "
+                + "xmlSchemas property.");
+          }
+
+          // 4. Build the xmlSchemaCollection and its namespace -> location mapping.
+
+          if (namespaceToLocationMapping == null) {
+            namespaceToLocationMapping = new HashMap<String, String>();
+          } else {
+            namespaceToLocationMapping.clear();
+          }
+
+          xmlSchemaCollection = new XmlSchemaCollection();
+    xmlSchemaCollection.setSchemaResolver(new XmlSchemaMultiBaseUriResolver());
+    xmlSchemaCollection.setBaseUri(config.getBaseUri());
+    try {
+      for (StreamSource source : config.getSources()) {
+        final XmlSchema xmlSchema = xmlSchemaCollection.read(source);
+        namespaceToLocationMapping.put(
+            xmlSchema.getTargetNamespace(),
+            source.getSystemId());
+      }
+    } catch (IOException e) {
+      throw new IllegalArgumentException(
+          "Not all of the schema sources could be read from.", e);
+    }
+
+    // 6. Build the state machine.
+    final XmlSchemaStateMachineGenerator stateMachineGen =
+        new XmlSchemaStateMachineGenerator();
+
+    final XmlSchemaWalker walker =
+        new XmlSchemaWalker(xmlSchemaCollection, stateMachineGen);
+    walker.setUserRecognizedTypes( Utils.getAvroRecognizedTypes() );
+
+    final XmlSchemaElement rootElement =
+        xmlSchemaCollection.getElementByQName(config.getRootTagName());
+    walker.walk(rootElement);
+
+    try {
+      domBuilder = new DomBuilderFromSax(xmlSchemaCollection);
+    } catch (ParserConfigurationException e) {
+      throw new IllegalStateException("Cannot configure the DOM Builder.", e);
+    }
+    domBuilder.setNamespaceToLocationMapping(namespaceToLocationMapping);
+
+    final XmlSchemaStateMachineNode stateMachine =
+        stateMachineGen.getStartNode();
+
+    /* 7. Build an AvroRecordName -> XmlSchemaStateMachineNode mapping,
+     *    a QName -> Element mapping, and a namespace prefix mapping.
+     */
+    final Map<QName, XmlSchemaStateMachineNode> stateMachineNodesByQName =
+        stateMachineGen.getStateMachineNodesByQName();
+
+    final Map<QName, XmlSchemaElement> elementsByQName =
+        new HashMap<QName, XmlSchemaElement>();
+
+    stateByAvroName = new HashMap<AvroRecordName, XmlSchemaStateMachineNode>();
+    for (Map.Entry<QName, XmlSchemaStateMachineNode> entry :
+      stateMachineNodesByQName.entrySet()) {
+
+      elementsByQName.put(entry.getKey(), entry.getValue().getElement());
+
+      try {
+        stateByAvroName.put(
+            new AvroRecordName(entry.getKey()), entry.getValue());
+
+      } catch (URISyntaxException e) {
+        throw new IllegalArgumentException(
+            entry.getKey()
+            + "'s namespace of \""
+            + entry.getKey().getNamespaceURI()
+            + "\" is not a valid URI.",
+            e);
+      }
+
+      final String prefix =
+          nsContext.getPrefix( entry.getKey().getNamespaceURI() );
+      if (prefix == null) {
+        nsContext.addNamespace(
+            "ns" + currNsNum,
+            entry.getKey().getNamespaceURI());
+        ++currNsNum;
+      }
+    }
+
+    domBuilder.setElementsByQName(elementsByQName);
+
+    inputSchema = schema;
+
+          contentHandlers = new ArrayList<ContentHandler>(2);
+          contentHandlers.add( new XmlSchemaPathFinder(stateMachine) );
+          contentHandlers.add(domBuilder);
+  }
+
+  /**
+   * Reads the XML {@link Document} from the input {@link Decoder} and
+   * returns it, transformed.  The <code>reuse</code> {@link Document}
+   * will not be used, and can safely be <code>null</code>.
+   *
+   * @see DatumReader#read(Object, Decoder)
+   */
+  @Override
+  public Document read(Document reuse, Decoder in) throws IOException {
+    if ((inputSchema == null)
+        || (xmlSchemaCollection == null)
+        || (domBuilder == null)
+        || (contentHandlers == null)) {
+      throw new IllegalStateException(
+          "The Avro and XML Schemas must be defined before reading from an "
+          + "Avro Decoder.  Please call XmlDatumReader.setSchema(Schema) "
+          + "before calling this function.");
+    }
+
+    final String[] prefixes = nsContext.getDeclaredPrefixes();
+    try {
+      for (ContentHandler contentHandler : contentHandlers) {
+        contentHandler.startDocument();
+
+        for (String prefix : prefixes) {
+          contentHandler.startPrefixMapping(
+              prefix,
+              nsContext.getNamespaceURI(prefix));
+        }
+      }
+
+    } catch (Exception e) {
+      throw new IOException("Unable to create the new document.", e);
+    }
+
+    /* If the root node is part of a substitution
+     * group, retrieve the corresponding schema.
+     */
+    Schema rootSchema = inputSchema;
+    if ( rootSchema.getType().equals(Schema.Type.UNION) ) {
+      final int unionIndex = in.readIndex();
+      rootSchema = rootSchema.getTypes().get(unionIndex);
+    }
+
+    processElement(rootSchema, in);
+
+    try {
+      for (ContentHandler contentHandler : contentHandlers) {
+        for (String prefix : prefixes) {
+          contentHandler.endPrefixMapping(prefix);
+        }
+
+        contentHandler.endDocument();
+      }
+    } catch (Exception e) {
+      throw new IOException("Unable to create the new document.", e);
+    }
+
+    return domBuilder.getDocument();
+  }
+
+  private void processElement(Schema elemSchema, Decoder in)
+      throws IOException {
+
+    if ( !elemSchema.getType().equals(Schema.Type.RECORD) ) {
+      throw new IllegalStateException(
+          "Expected to process a RECORD, but found a \""
+          + elemSchema.getType()
+          + "\" instead.");
+    }
+
+    final AvroRecordName recordName =
+        new AvroRecordName(elemSchema.getNamespace(), elemSchema.getName());
+
+    final XmlSchemaStateMachineNode stateMachine =
+        stateByAvroName.get(recordName);
+
+    if (stateMachine == null) {
+      throw new IllegalStateException(
+          "Cannot find state machine for "
+          + recordName);
+
+    } else if (!stateMachine
+                  .getNodeType()
+                  .equals(XmlSchemaStateMachineNode.Type.ELEMENT) ) {
+
+      throw new IllegalStateException(
+          "State machine for "
+          + recordName
+          + " is of type "
+          + stateMachine.getNodeType()
+          + ", not ELEMENT.");
+    }
+
+    final List<XmlSchemaStateMachineNode.Attribute> expectedAttrs =
+        stateMachine.getAttributes();
+
+    final AvroAttributes attributes = new AvroAttributes();
+
+    final List<Schema.Field> fields = elemSchema.getFields();
+
+    // The first N-1 fields are attributes.
+    for (int index = 0; index < (fields.size() - 1); ++index) {
+      try {
+        final AvroAttribute attr =
+            createAttribute(expectedAttrs, fields.get(index), in);
+        if (attr != null) {
+          attributes.addAttribute(attr);
+        }
+      } catch (IOException ioe) {
+        throw new IOException(
+            "Failed to create attribute for element "
+            + stateMachine.getElement().getQName(),
+            ioe);
+      }
+    }
+
+    /* It is possible that the element's child is a QName in a
+     * new namespace we have not seen before.  SAX requires us
+     * to add all new namespaces *before* the corresponding
+     * element, so if this is a simple type, we need to fetch
+     * the content now and determine if we need to adjust the
+     * namespace context accordingly.
+     */
+    final QName elemQName = stateMachine.getElement().getQName();
+    final Schema.Field childField = elemSchema.getField(elemSchema.getName());
+    final XmlSchemaTypeInfo elemType = stateMachine.getElementType();
+
+    String content = null;
+    switch ( elemType.getType() ) {
+    case ATOMIC:
+    case LIST:
+    case UNION:
+      {
+        content = readSimpleType(childField.schema(), elemQName, elemType, in);
+        break;
+      }
+    default:
+      // Nothing to do here.
+    }
+
+    List<String> newPrefixes = null;
+    if ((newlyAddedQNamesToNs != null) && !newlyAddedQNamesToNs.isEmpty()) {
+      newPrefixes = new ArrayList<String>( newlyAddedQNamesToNs.size() );
+      for (QName qName : newlyAddedQNamesToNs) {
+        final String ns = qName.getNamespaceURI();
+        final String prefix = qName.getPrefix();
+        newPrefixes.add(prefix);
+        for (ContentHandler contentHandler : contentHandlers) {
+          try {
+            contentHandler.startPrefixMapping(prefix, ns);
+          } catch (Exception e) {
+            throw new IOException(
+                "Cannot add namespace " + ns
+                + " and prefix " + prefix
+                + " to content handlers.",
+                e);
+          }
+        }
+      }
+      newlyAddedQNamesToNs.clear();
+    }
+
+    // Determine the namespace, local name, and qualified name.
+    final String prefix = nsContext.getPrefix(elemQName.getNamespaceURI());
+    String qName = null;
+    if (prefix == null) {
+      qName = elemQName.getLocalPart();
+    } else {
+      qName = prefix + ':' + elemQName.getLocalPart();
+    }
+
+    // Notify the content handlers an element has begun.
+    for (ContentHandler contentHandler : contentHandlers) {
+      try {
+        contentHandler.startElement(
+            elemQName.getNamespaceURI(),
+            elemQName.getLocalPart(),
+            qName,
+            attributes);
+
+      } catch (Exception e) {
+        throw new IOException("Cannot start element " + elemQName + '.', e);
+      }
+    }
+
+    switch ( elemType.getType() ) {
+    case ATOMIC:
+    case LIST:
+    case UNION:
+      {
+        processContent(content);
+        break;
+      }
+    case COMPLEX:
+      processComplexChildren(
+          childField,
+          stateMachine.getElement(),
+          elemType,
+          in);
+      break;
+    default:
+      throw new IllegalStateException(
+          elemQName + " has an unrecognized type named " + elemType.getType());
+    }
+
+    // Notify the content handlers the element has ended.
+    for (ContentHandler contentHandler : contentHandlers) {
+      try {
+        contentHandler.endElement(
+            elemQName.getNamespaceURI(),
+            elemQName.getLocalPart(),
+            qName);
+
+        if (newPrefixes != null) {
+          for (String newPrefix : newPrefixes) {
+            contentHandler.endPrefixMapping(newPrefix);
+          }
+        }
+
+      } catch (Exception e) {
+        throw new IOException("Cannot start element " + elemQName + '.', e);
+      }
+    }
+
+    // Also remove any newly added prefixes from our namespace context.
+    if (newPrefixes != null) {
+      for (String newPrefix : newPrefixes) {
+        nsContext.removeNamespace(newPrefix);
+      }
+    }
+  }
+
+  private AvroAttribute createAttribute(
+      List<XmlSchemaStateMachineNode.Attribute> expectedAttrs,
+      Schema.Field field,
+      Decoder in)
+  throws IOException {
+
+    AvroAttribute attribute = null;
+
+    for (XmlSchemaStateMachineNode.Attribute attr : expectedAttrs) {
+      final QName attrQName = attr.getAttribute().getQName();
+      if (field.name().equals(attrQName.getLocalPart())) {
+        try {
+          final String value =
+              readSimpleType(field.schema(), attrQName, attr.getType(), in);
+  
+          if (value != null) {
+            final String prefix =
+                nsContext.getPrefix(attrQName.getNamespaceURI());
+    
+            String qualifiedName = null;
+            if (prefix == null) {
+              qualifiedName = attrQName.getLocalPart();
+            } else {
+              qualifiedName = prefix + ':' + attrQName.getLocalPart();
+            }
+
+            attribute =
+                new AvroAttribute(
+                    attrQName.getNamespaceURI(),
+                    attrQName.getLocalPart(),
+                    qualifiedName,
+                    value);
+          }
+        } catch (Exception e) {
+          throw new IOException(
+              "Cannot generate attribute "
+              + attr.getAttribute().getQName(),
+              e);
+        }
+
+        break;
+      }
+    }
+
+    return attribute;
+  }
+
+  private void processContent(String content) throws IOException {
+    if (content == null) {
+      return;
+    }
+
+    if ((newlyAddedQNamesToNs != null) && !newlyAddedQNamesToNs.isEmpty()) {
+      
+    }
+
+    final char[] chars = content.toCharArray();
+
+    for (ContentHandler contentHandler : contentHandlers) {
+      try {
+        contentHandler.characters(chars, 0, chars.length);
+      } catch (SAXException e) {
+        throw new IOException(
+            "Cannot process content \"" + content + "\".", e);
+      }
+    }
+  }
+
+  private String readSimpleType(
+      Schema schema,
+      QName typeQName,
+      XmlSchemaTypeInfo xmlType,
+      Decoder in)
+      throws IOException {
+
+    switch ( schema.getType() ) {
+    case ARRAY:
+      {
+        if (!xmlType.getType().equals(XmlSchemaTypeInfo.Type.LIST)) {
+          throw new IllegalStateException(
+              "Avro Schema is of type ARRAY, but the XML Schema is of type "
+              + xmlType.getType());
+        }
+
+        final StringBuilder result = new StringBuilder();
+        final XmlSchemaTypeInfo xmlElemType = xmlType.getChildTypes().get(0);
+        final Schema elemType = schema.getElementType();
+
+        for (long arrayBlockSize = in.readArrayStart();
+             arrayBlockSize > 0;
+             arrayBlockSize = in.arrayNext()) {
+          for (long itemNum = 0; itemNum < arrayBlockSize; ++itemNum) {
+            result.append(
+                readSimpleType(elemType, typeQName, xmlElemType, in));
+            result.append(' ');
+          }
+        }
+        result.delete(result.length() - 1, result.length());
+
+        return result.toString();
+      }
+    case UNION:
+      {
+        final int unionIndex = in.readIndex();
+
+        if (schema.getTypes().size() <= unionIndex) {
+          throw new IllegalStateException("Attempted to read from union index "
+              + unionIndex + " but the Avro Schema has "
+              + schema.getTypes().size() + " types, and the XML Schema has "
+              + xmlType.getChildTypes().size() + " types.");
+        }
+
+        final Schema elemType = schema.getTypes().get(unionIndex);
+
+        XmlSchemaTypeInfo xmlElemType = xmlType;
+        if ( xmlType.getType().equals(XmlSchemaTypeInfo.Type.UNION) ) {
+          /* Utils.getAvroSchemaFor() will add a NULL type and/or a STRING
+           * type on the end of the XML types to account for optional values
+           * and mixed elements, respectively.
+           *
+           * In addition, if multiple XML Types resolve to the same Avro type,
+           * the duplicates were purged.  Likewise, we need to rotate through
+           * all of the XML union types, and go with the first XML type that
+           * translates to the same Avro type.
+           *
+           * This approach works fine for the current mappings, but may show
+           * poor results when date types are added to Avro.  That is because
+           * there are 8 different date types in XML, but there will be only
+           * one in Avro.
+           */
+          xmlElemType =
+              Utils.chooseUnionType(xmlType, typeQName, elemType, unionIndex);
+
+          return readSimpleType(elemType, typeQName, xmlElemType, in);
+
+        } else {
+          /* The same XML Type applies; the union
+           * is for optional & mixed types. 
+           */
+          return readSimpleType(elemType, typeQName, xmlElemType, in);
+        }
+      }
+    case BYTES:
+      {
+        bytesBuffer = in.readBytes(bytesBuffer);
+        final int numBytes = bytesBuffer.remaining();
+        final byte[] data = new byte[numBytes];
+        bytesBuffer.get(data, 0, numBytes);
+
+        switch ( xmlType.getBaseType() ) {
+        case BIN_HEX:
+          return DatatypeConverter.printHexBinary(data);
+
+        case BIN_BASE64:
+          return DatatypeConverter.printBase64Binary(data);
+
+        case DECIMAL:
+        {
+          return DatatypeConverter.printDecimal(
+              Utils.createBigDecimalFrom(data, schema));
+        }
+        default:
+          throw new IllegalStateException(
+              "Avro Schema is of type BYTES, but the XML Schema is of type "
+              + xmlType.getBaseType() + '.');
+        }
+      }
+    case NULL:
+      {
+        in.readNull();
+        return null;
+      }
+    case BOOLEAN:
+      return DatatypeConverter.printBoolean( in.readBoolean() );
+
+    case DOUBLE:
+      {
+        return DatatypeConverter.printDouble( in.readDouble() );
+      }
+    case ENUM:
+      return schema.getEnumSymbols().get( in.readEnum() );
+
+    case FLOAT:
+      return DatatypeConverter.printFloat( in.readFloat() );
+
+    case INT:
+      return DatatypeConverter.printInt( in.readInt() );
+
+    case LONG:
+      return DatatypeConverter.printLong( in.readLong() );
+
+    case STRING:
+      return DatatypeConverter.printString( in.readString() );
+
+    case RECORD:
+      {
+        switch ( xmlType.getBaseType() ) {
+        case QNAME:
+          {
+            final String ns = in.readString();
+            final String lp = in.readString();
+
+            QName qName = null;
+            boolean isNew = false;
+
+            if ( !ns.isEmpty() ) {
+              String prefix = nsContext.getPrefix(ns);
+
+              if (prefix == null) {
+                isNew = true;
+                prefix = "ns" + currNsNum;
+                nsContext.addNamespace(prefix, ns);
+                ++currNsNum;
+              }
+
+              qName = new QName(ns, lp, prefix);
+            } else {
+              qName = new QName(lp);
+            }
+
+            /* While we need to add the namespace to the context so we can
+             * properly generate a qualified name, we also need to notify
+             * our content handlers of the namespace declaration.
+             *
+             * We cannot do that here, because we cannot properly open and
+             * close the scope.  newlyAddedQNamesToNs will be checked in
+             * a place that can properly handle the scope requirements.
+             */
+            if (isNew) {
+              if (newlyAddedQNamesToNs == null) {
+                newlyAddedQNamesToNs = new ArrayList<QName>(1);
+              }
+              newlyAddedQNamesToNs.add(qName);
+            }
+
+            return DatatypeConverter.printQName(qName, nsContext);
+          }
+        default:
+          throw new IOException(
+              "Avro Schema is of type RECORD, but the XML Schema is of type "
+              + xmlType.getBaseType() + '.');
+        }
+      }
+
+    default:
+      throw new IOException(schema.getType() + " is not a simple type.");
+    }
+  }
+
+  private void processComplexChildren(
+      Schema.Field field,
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo elemType,
+      Decoder in)
+      throws IOException {
+
+    final Schema fieldSchema = field.schema();
+
+    switch (fieldSchema.getType()) {
+    case NULL:
+      // This element has no children.
+      in.readNull();
+      break;
+    case STRING:
+      if ( elemType.isMixed() ) {
+        processContent( in.readString() );
+      } else {
+        throw new IllegalStateException(
+            element.getQName()
+            + " has textual content but is not a mixed type.");
+      }
+      break;
+    case ARRAY:
+      {
+        final Schema elemSchema = field.schema().getElementType();
+        if ( !elemSchema.getType().equals(Schema.Type.UNION) ) {
+          throw new IOException(
+              element.getQName()
+              + " has a child field of ARRAY of " + elemSchema.getType()
+              + " where ARRAY of UNION was expected.");
+        }
+
+        for (long arrayBlockSize = in.readArrayStart();
+            arrayBlockSize > 0;
+            arrayBlockSize = in.arrayNext()) {
+
+          for (long index = 0; index < arrayBlockSize; ++index) {
+            final int unionIndex = in.readIndex();
+            final Schema unionSchema = elemSchema.getTypes().get(unionIndex);
+            switch ( unionSchema.getType() ) {
+            case MAP:
+              {
+                for (long mapBlockSize = in.readMapStart();
+                     mapBlockSize > 0;
+                     mapBlockSize = in.mapNext()) {
+                  for (long mapIdx = 0; mapIdx < mapBlockSize; ++mapIdx) {
+                    in.skipString(); // The key is irrelevant.
+
+                    // MAP of UNION of RECORD or MAP of RECORD
+                    final Schema valueType = unionSchema.getValueType();
+                    if ( valueType.getType().equals(Schema.Type.RECORD) ) {
+                      processElement(valueType, in);
+
+                    } else if (valueType.getType().equals(Schema.Type.UNION)) {
+                      final int mapUnionIndex = in.readIndex();
+                      processElement(
+                          valueType.getTypes().get(mapUnionIndex),
+                          in);
+
+                    } else {
+                      throw new IOException(
+                          "Received a MAP of "
+                          + valueType.getType()
+                          + " when either MAP of RECORD"
+                          + " or MAP of UNION of RECORD was expected.");
+                    }
+                  }
+                }
+                break;
+              }
+            case RECORD:
+              processElement(unionSchema, in);
+              break;
+            case STRING:
+              if ( elemType.isMixed() ) {
+                processContent( in.readString() );
+              } else {
+                throw new IOException(
+                    "Received a STRING for non-mixed type element "
+                    + element.getQName());
+              }
+              break;
+            default:
+              throw new IOException(
+                  element.getQName()
+                  + " has a child field of ARRAY of UNION with "
+                  + unionSchema.getType()
+                  + " where ARRAY of UNION of either MAP or RECORD was"
+                  + " expected.");
+            }
+          }
+        }
+        break;
+      }
+    default:
+      throw new IOException(
+          element.getQName()
+          + " has an invalid complex content of type "
+          + fieldSchema.getType() + '.');
+    }
+  }
+
+  private static QName buildQNameFrom(JsonNode rootTagNode) {
+    if (rootTagNode == null) {
+      throw new IllegalArgumentException(
+          "The xmlSchemas property in the schema must "
+          + "have a root tag defined.");
+    }
+
+    final JsonNode namespaceNode = rootTagNode.get("namespace");
+    if (namespaceNode == null) {
+      throw new IllegalArgumentException(
+          "The rootTag object must have a namespace field.");
+    }
+
+    final JsonNode localPartNode = rootTagNode.get("localPart");
+    if (localPartNode == null) {
+      throw new IllegalArgumentException(
+          "The rootTag object must have a localPart field.");
+    }
+
+    final String namespace = namespaceNode.getTextValue();
+    if ((namespace == null) || namespace.isEmpty()) {
+      throw new IllegalArgumentException(
+          "The namespace field of the rootTag object must be a non-empty "
+          + "text field.");
+    }
+
+    final String localPart = localPartNode.getTextValue();
+    if ((localPart == null) || localPart.isEmpty()) {
+      throw new IllegalArgumentException(
+          "The localPart field of the rootTag object must be a non-empty "
+          + "text field.");
+    }
+
+    return new QName(namespace, localPart);
+  }
+
+  private static List<File> buildFileListFrom(JsonNode filesNode) {
+    if ( !filesNode.isArray() ) {
+      throw new IllegalArgumentException(
+          "The \"files\" field under xmlSchemas must "
+          + "be an array of file paths.");
+    }
+    final ArrayList<File> files = new ArrayList<File>( filesNode.size() );
+
+    for (int fileIndex = 0; fileIndex < filesNode.size(); ++fileIndex) {
+      final JsonNode fileNode = filesNode.get(fileIndex);
+      final String filePath = fileNode.getTextValue();
+      if ((filePath == null) || filePath.isEmpty()) {
+        throw new IllegalArgumentException(
+            "The file in the files array at index "
+            + fileIndex
+            + " is either empty or not a string node.");
+      }
+      files.add( new File(filePath) );
+    }
+
+    return files;
+  }
+
+  private static List<URL> buildUrlListFrom(JsonNode urlsNode) {
+    if ( !urlsNode.isArray() ) {
+      throw new IllegalArgumentException(
+          "The \"urls\" field under xmlSchemas must be an array of URLs.");
+    }
+    final ArrayList<URL> urls = new ArrayList<URL>( urlsNode.size() );
+
+    for (int urlIndex = 0; urlIndex < urlsNode.size(); ++urlIndex) {
+      final JsonNode urlNode = urlsNode.get(urlIndex);
+      final String url = urlNode.getTextValue();
+      if ((url == null) || url.isEmpty()) {
+        throw new IllegalArgumentException(
+            "The URL in the URLs array at index "
+            + urlIndex
+            + " is either empty or not a string node.");
+      }
+      try {
+        urls.add( new URL(url) );
+      } catch (MalformedURLException e) {
+        throw new IllegalArgumentException(
+            "The URL in the URLs array at index "
+            + urlIndex
+            + " is malformed.",
+            e);
+      }
+    }
+
+    return urls;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumWriter.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumWriter.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlDatumWriter.java	(working copy)
@@ -0,0 +1,1370 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import javax.xml.bind.DatatypeConverter;
+import javax.xml.namespace.QName;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.avro.Schema;
+import org.apache.avro.io.DatumWriter;
+import org.apache.avro.io.Encoder;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.w3c.dom.Document;
+import org.xml.sax.Attributes;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
+
+/**
+ * Reads an XML {@link Document} and writes it to an {@link Encoder}.
+ * <p>
+ * Generates an Avro {@link Schema} on the fly from the XML Schema itself. 
+ * That {@link Schema} can be retrieved by calling {@link #getSchema()}.
+ * </p>
+ */
+public class XmlDatumWriter implements DatumWriter<Document> {
+
+  private static final QName NIL_ATTR =
+      new QName("http://www.w3.org/2001/XMLSchema-instance", "nil");
+
+  private final XmlSchemaCollection xmlSchemaCollection;
+  private final XmlSchemaStateMachineNode stateMachine;
+  private Schema schema;
+
+  private static class StackEntry {
+    XmlSchemaDocumentNode<AvroRecordInfo> docNode;
+    boolean receivedContent;
+
+    StackEntry(XmlSchemaDocumentNode<AvroRecordInfo> docNode) {
+      this.docNode = docNode;
+      this.receivedContent = false;
+    }
+  }
+
+  private static class Writer extends DefaultHandler {
+    private static final XmlSchemaTypeInfo XML_MIXED_CONTENT_TYPE =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    private static final Schema AVRO_MIXED_CONTENT_SCHEMA =
+        Schema.create(Schema.Type.STRING);
+
+    private XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> currLocation;
+    private StringBuilder content;
+    private QName currAnyElem;
+    private ArrayList<StackEntry> stack;
+
+    private final XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path;
+    private final Encoder out;
+    private final XmlSchemaNamespaceContext nsContext;
+
+    Writer(
+        XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path,
+        Encoder out) {
+
+      this.path = path;
+      this.out = out;
+
+      nsContext = new XmlSchemaNamespaceContext();
+      stack = new ArrayList<StackEntry>();
+      currLocation = null;
+      content = null;
+      currAnyElem = null;
+    }
+
+    @Override
+    public void startDocument() throws SAXException {
+      currLocation = path;
+    }
+
+    @Override
+    public void startPrefixMapping(String prefix, String uri)
+        throws SAXException {
+
+      nsContext.addNamespace(prefix, uri);
+    }
+
+    @Override
+    public void endPrefixMapping(String prefix) throws SAXException {
+      nsContext.removeNamespace(prefix);
+    }
+
+    @Override
+    public void startElement(
+        String uri,
+        String localName,
+        String qName,
+        Attributes atts) throws SAXException {
+
+      if (currAnyElem != null) {
+        // We are inside an any element and not processing this one.
+        return;
+      }
+
+      final QName elemQName = new QName(uri, localName);
+      walkToElement(elemQName);
+
+      if ( elemQName.getLocalPart().equals("anyAndFriends") ) {
+        //log = true;
+      }
+
+      if (!currLocation
+            .getDirection()
+            .equals(XmlSchemaPathNode.Direction.CHILD)
+          && !currLocation
+               .getDirection()
+               .equals(XmlSchemaPathNode.Direction.SIBLING)) {
+        throw new IllegalStateException(
+            "We are starting an element, so our path node direction should be "
+            + "to a CHILD or SIBLING, not "
+            + currLocation.getDirection());
+      }
+
+      if (currLocation
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ANY)) {
+
+        // This is an any element; we are not processing it.
+        currAnyElem = elemQName;
+        return;
+      }
+
+      try {
+        final XmlSchemaDocumentNode<AvroRecordInfo> doc =
+            currLocation.getDocumentNode();
+        final AvroRecordInfo recordInfo = doc.getUserDefinedContent();
+
+        Schema avroSchema = recordInfo.getAvroSchema();
+
+        final List<XmlSchemaStateMachineNode.Attribute> attributes =
+            doc.getStateMachineNode().getAttributes();
+
+        final HashMap<String, XmlSchemaTypeInfo> attrTypes =
+            new HashMap<String, XmlSchemaTypeInfo>();
+
+        final HashMap<String, XmlSchemaAttribute> schemaAttrs =
+            new HashMap<String, XmlSchemaAttribute>();
+
+        for (XmlSchemaStateMachineNode.Attribute attribute : attributes) {
+          attrTypes.put(
+              attribute.getAttribute().getName(),
+              attribute.getType());
+
+          schemaAttrs.put(
+              attribute.getAttribute().getName(),
+              attribute.getAttribute());
+        }
+
+        // If there are children, we want to start an array and end it later.
+        final StackEntry entry =
+            new StackEntry(currLocation.getDocumentNode());
+
+        if (avroSchema.getType().equals(Schema.Type.RECORD)) {
+          if ( !stack.isEmpty() ) {
+            out.startItem();
+          }
+          if (recordInfo.getUnionIndex() >= 0) {
+            out.writeIndex( recordInfo.getUnionIndex() );
+          }
+
+        } else if ( avroSchema.getType().equals(Schema.Type.MAP) ) {
+          final AvroPathNode mapNode = currLocation.getUserDefinedContent();
+          if (mapNode == null) {
+            throw new IllegalStateException(
+                "Reached "
+                + elemQName
+                + ", a MAP node, but there is no map information here.");
+          }
+
+          switch ( mapNode.getType() ) {
+          case MAP_START:
+            {
+              if ( !stack.isEmpty() ) {
+                out.startItem();
+              }
+              if (recordInfo.getUnionIndex() >= 0) {
+                out.writeIndex( recordInfo.getUnionIndex() );
+              }
+              out.writeMapStart();
+              out.setItemCount( mapNode.getMapSize() );
+            }
+          case ITEM_START:
+            {
+              out.startItem();
+
+              avroSchema = avroSchema.getValueType();
+
+              /* If the MAP value is another UNION, reach
+               * into that one to fetch the schema.
+               */
+              final int mapUnionIndex = recordInfo.getMapUnionIndex();
+              if (mapUnionIndex >= 0) {
+                avroSchema = avroSchema.getTypes().get(mapUnionIndex);
+              }
+
+              String key = null;
+
+              for (int fieldIndex = 0;
+                  fieldIndex < avroSchema.getFields().size() - 1;
+                  ++fieldIndex) {
+
+                final Schema.Field field =
+                    avroSchema.getFields().get(fieldIndex);
+
+                final XmlSchemaTypeInfo attrType = attrTypes.get(field.name());
+
+                final XmlSchemaAttribute xsa = schemaAttrs.get(field.name());
+
+                if ((attrType.getUserRecognizedType() != null)
+                    && attrType
+                         .getUserRecognizedType()
+                         .equals(Constants.XSD_ID)) {
+                  key =
+                      getAttrValue(
+                          atts,
+                          xsa.getQName().getNamespaceURI(),
+                          field.name());
+
+                  if (key == null) {
+                    throw new IllegalStateException(
+                        "Attribute value for "
+                        + xsa.getQName()
+                        + " of element "
+                        + elemQName
+                        + " is null.");
+                  }
+                  break;
+                }
+              }
+
+              if (key == null) {
+                throw new IllegalStateException(
+                    "Unable to find key for element " + elemQName);
+              }
+
+              out.writeString(key);
+
+              /* If the MAP value is another UNION, write
+               * the union index before continuing.
+               */
+              if (mapUnionIndex >= 0) {
+                out.writeIndex(mapUnionIndex);
+              }
+              break;
+            }
+          case MAP_END:
+          case CONTENT:
+          default:
+            throw new IllegalStateException(
+                "Did not expect to find a map node of type "
+                + mapNode.getType()
+                + " when starting "
+                + elemQName
+                + ".");
+          }
+
+        } else {
+          throw new IllegalStateException(
+              "Elements are either MAPs or RECORDs, not "
+              + avroSchema.getType()
+              + "s.");
+        }
+
+        /* The last element in the set of fields is the children.  We want
+         * to process the children separately as they require future calls
+         * to characters() and/or startElement().
+         */
+        for (int fieldIndex = 0;
+            fieldIndex < avroSchema.getFields().size() - 1;
+            ++fieldIndex) {
+
+          final Schema.Field field = avroSchema.getFields().get(fieldIndex);
+          if (field.name().equals(elemQName.getLocalPart())) {
+            // We reached the children field early ... not supposed to happen!
+            throw new IllegalStateException(
+                "The children field is indexed at "
+                + fieldIndex
+                + " when it was expected to be the last element, or "
+                + (avroSchema.getFields().size() - 1)
+                + ".");
+          }
+
+          final XmlSchemaTypeInfo typeInfo = attrTypes.get( field.name() );
+          final QName attrQName = schemaAttrs.get( field.name() ).getQName();
+
+          String value =
+              getAttrValue(
+                  atts,
+                  attrQName.getNamespaceURI(),
+                  field.name());
+
+          if (value == null) {
+            // See if there is a default or fixed value instead.
+            final XmlSchemaAttribute schemaAttr =
+                schemaAttrs.get( field.name() );
+
+            value = schemaAttr.getDefaultValue();
+            if (value == null) {
+              value = schemaAttr.getFixedValue();
+            }
+          }
+
+          try {
+            write(typeInfo, attrQName, field.schema(), value);
+          } catch (Exception e) {
+            throw new RuntimeException(
+                "Could not write "
+                + field.name()
+                + " in "
+                + field.schema().toString()
+                + " to the output stream for element "
+                + elemQName,
+                e);
+          }
+        }
+
+        final XmlSchemaTypeInfo elemType =
+            doc.getStateMachineNode().getElementType();
+
+        boolean isComplexType = true;
+        if ( !elemType.getType().equals(XmlSchemaTypeInfo.Type.COMPLEX) ) {
+          isComplexType = false;
+        }
+
+        if (avroSchema
+              .getField( elemQName.getLocalPart() )
+              .schema()
+              .getType()
+              .equals(Schema.Type.ARRAY)
+            && isComplexType) {
+          out.writeArrayStart();
+
+          if (recordInfo.getNumChildren() > 0) {
+            out.setItemCount( recordInfo.getNumChildren() );
+          } else {
+            out.setItemCount(0);
+          }
+
+          /* We expect to receive child elements; no need to look
+           * for a default or fixed value once this element exits.
+           */
+          entry.receivedContent = true;
+
+        } else if (avroSchema
+                     .getField( elemQName.getLocalPart() )
+                     .schema()
+                     .getType()
+                     .equals(Schema.Type.NULL) ) {
+          out.writeNull();
+          entry.receivedContent = true;
+
+        } else {
+          final int nilIndex =
+              atts.getIndex(
+                  NIL_ATTR.getNamespaceURI(),
+                  NIL_ATTR.getLocalPart()); 
+
+          if ((nilIndex >= 0)
+              && Boolean.parseBoolean(atts.getValue(nilIndex))) {
+
+            write(doc.getStateMachineNode().getElementType(),
+                  elemQName,
+                  avroSchema.getField( elemQName.getLocalPart() ).schema(),
+                  null);
+            entry.receivedContent = true;
+          }
+        }
+
+        stack.add(entry);
+
+      } catch (Exception e) {
+        throw new RuntimeException(
+            "Unable to write "
+            + elemQName
+            + " to the output stream.",
+            e);
+      }
+    }
+
+    @Override
+    public void characters(char[] ch, int start, int length)
+        throws SAXException {
+
+      if (currAnyElem != null) {
+        // We do not process wildcard elements.
+        return;
+      }
+
+      if (stack.isEmpty()) {
+        throw new SAXException(
+            "We are processing content, but the element stack is empty!");
+      }
+
+      final XmlSchemaDocumentNode<AvroRecordInfo> owningElem =
+          stack.get(stack.size() - 1).docNode;
+
+      XmlSchemaPathNode path = walkToContent(owningElem);
+
+      if (path == null) {
+        final String str = new String(ch, start, length).trim();
+
+        if (str.isEmpty()) {
+          return;
+        } else {
+          if (path == null) {
+            throw new SAXException(
+                "We are processing characters \""
+                + str
+                + "\" for "
+                + owningElem
+                    .getStateMachineNode()
+                    .getElement()
+                    .getQName()
+                + " but the current direction is "
+                + currLocation.getDirection()
+                + " to "
+                + currLocation.getStateMachineNode()
+                + ", not CONTENT.");
+          }
+        }
+
+      } else {
+        currLocation = path;
+
+        if (currLocation.getNext() == null) {
+          throw new SAXException(
+              "We are processing characters for "
+              + stack.get(stack.size() - 1)
+                  .docNode
+                  .getStateMachineNode()
+                  .getElement()
+                  .getQName()
+              + " but somehow the path ends here!");
+        }
+      }
+
+      /* If characters() will be called multiple times, we want to collect
+       * all of them in the "content" StringBuilder, then process it all
+       * once the last bit of content has been collected.
+       *
+       * This includes where content is interspersed with any elements, which
+       * are skipped anyway.
+       *
+       * If this is the last content node, we'll just write it all out here.
+       */
+      final boolean moreContentComing =
+          hasMoreContent(currLocation.getNext(), owningElem);
+
+      String result = null;
+      if (moreContentComing
+          || ((content != null) && (content.length() > 0))) {
+
+        if (content == null) {
+          content = new StringBuilder();
+        }
+        content.append(ch, start, length);
+
+        if (!moreContentComing) {
+          // If this is the last node, process the content.
+          result = content.toString();
+          content.delete(0, content.length());
+        }
+      } else {
+        // This is the only content node - just write it.
+        result = new String(ch, start, length);
+      }
+
+      if (result != null) {
+        final StackEntry entry = stack.get(stack.size() - 1);
+        final XmlSchemaDocumentNode<AvroRecordInfo> docNode = entry.docNode;
+
+        final XmlSchemaTypeInfo elemType =
+            docNode.getStateMachineNode().getElementType();
+
+        final QName elemQName =
+            docNode
+              .getStateMachineNode()
+              .getElement()
+              .getQName();
+
+        final Schema avroSchema =
+           docNode
+             .getUserDefinedContent()
+             .getAvroSchema()
+             .getField(elemQName.getLocalPart())
+             .schema();
+
+        try {
+          final AvroPathNode contentPathNode =
+              currLocation.getUserDefinedContent();
+
+          if ((contentPathNode != null)
+              && contentPathNode.getType().equals(AvroPathNode.Type.CONTENT)) {
+
+            out.startItem();
+            out.writeIndex(contentPathNode.getContentUnionIndex());
+
+            write(
+                XML_MIXED_CONTENT_TYPE,
+                elemQName,
+                AVRO_MIXED_CONTENT_SCHEMA,
+                result);
+
+          } else {
+            write(elemType, elemQName, avroSchema, result);
+          }
+          entry.receivedContent = true;
+        } catch (Exception e) {
+          throw new RuntimeException(
+              "Unable to write the content \""
+              + result
+              + "\" for "
+              + elemQName,
+              e);
+        }
+      }
+    }
+
+    @Override
+    public void endElement(
+        String uri,
+        String localName,
+        String qName)
+        throws SAXException
+    {
+      final QName elemQName = new QName(uri, localName);
+
+      if (currAnyElem != null) {
+        if (currAnyElem.equals(elemQName)) {
+          // We are exiting an any element; prepare for the next one!
+          currAnyElem = null;
+        }
+        return;
+      }
+
+      final StackEntry entry = stack.remove(stack.size() - 1);
+      final XmlSchemaDocumentNode<AvroRecordInfo> docNode = entry.docNode;
+
+      final XmlSchemaTypeInfo elemType =
+          docNode.getStateMachineNode().getElementType();
+
+      if (!entry.receivedContent) {
+
+        /* Look for either the default value
+         * or fixed value and apply it, if any.
+         */
+        String value =
+            docNode.getStateMachineNode().getElement().getDefaultValue();
+
+        if (value == null) {
+          value = docNode.getStateMachineNode().getElement().getFixedValue();
+        }
+
+        final AvroRecordInfo record = docNode.getUserDefinedContent();
+
+        Schema avroSchema = record.getAvroSchema();
+
+        if ( avroSchema.getType().equals(Schema.Type.MAP) ) {
+          avroSchema = avroSchema.getValueType();
+
+          if (record.getMapUnionIndex() >= 0) {
+            avroSchema = avroSchema.getTypes().get(record.getMapUnionIndex());
+          }
+        }
+
+        avroSchema = avroSchema.getField(localName).schema();
+
+        try {
+          write(elemType, elemQName, avroSchema, value);
+        } catch (IOException e) {
+          throw new RuntimeException(
+              "Attempted to write a default value of \""
+              + value
+              + "\" for "
+              + elemQName
+              + " and failed.",
+              e);
+        }
+      }
+
+      final QName stackElemQName =
+          docNode
+            .getStateMachineNode()
+            .getElement()
+            .getQName();
+
+      if (!stackElemQName.equals(elemQName)) {
+        throw new IllegalStateException(
+            "We are leaving "
+            + elemQName
+            + " but the element on the stack is "
+            + stackElemQName + ".");
+      }
+
+      Schema avroSchema =
+          docNode
+            .getUserDefinedContent()
+            .getAvroSchema();
+
+      boolean isMapEnd = false;
+      if (avroSchema.getType().equals(Schema.Type.MAP)) {
+        avroSchema = avroSchema.getValueType();
+
+        final int mapUnionIndex =
+            docNode.getUserDefinedContent().getMapUnionIndex();
+        if (mapUnionIndex >= 0) {
+          avroSchema = avroSchema.getTypes().get(mapUnionIndex);
+        }
+
+        isMapEnd = isMapEnd();
+      }
+
+      boolean isComplexType = true;
+      if ( !elemType.getType().equals(XmlSchemaTypeInfo.Type.COMPLEX) ) {
+        isComplexType = false;
+      }
+
+      if (avroSchema
+            .getField( elemQName.getLocalPart() )
+            .schema()
+            .getType()
+            .equals(Schema.Type.ARRAY)
+          && isComplexType) {
+        try {
+          out.writeArrayEnd();
+        } catch (Exception e) {
+          throw new RuntimeException(
+              "Unable to end the array for " + elemQName, e);
+        }
+      }
+
+      if (isMapEnd) {
+        try {
+          out.writeMapEnd();
+        } catch (Exception e) {
+          throw new RuntimeException("Unable to process a MAP_END.", e);
+        }
+
+      }
+    }
+
+    @Override
+    public void endDocument() throws SAXException {
+      if (currLocation.getNext() != null) {
+        currLocation = currLocation.getNext();
+        while (currLocation != null) {
+          if (!currLocation
+                 .getDirection()
+                 .equals(XmlSchemaPathNode.Direction.PARENT)) {
+            throw new IllegalStateException(
+                "Path has more nodes after document end: "
+                + currLocation.getDirection()
+                + " | "
+                + currLocation.getStateMachineNode());
+          }
+          currLocation = currLocation.getNext();
+        }
+      }
+    }
+
+    private void walkToElement(QName elemName) {
+      if (stack.isEmpty()
+          && currLocation
+               .getStateMachineNode()
+               .getNodeType()
+               .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+          && currLocation
+               .getStateMachineNode()
+               .getElement()
+               .getQName()
+               .equals(elemName)) {
+        return;
+      }
+
+      do {
+        currLocation = currLocation.getNext();
+      } while ((currLocation != null)
+                && (currLocation
+                      .getDirection()
+                      .equals(XmlSchemaPathNode.Direction.PARENT)
+                    || (!currLocation
+                           .getDirection()
+                           .equals(XmlSchemaPathNode.Direction.PARENT)
+                         && !currLocation
+                               .getStateMachineNode()
+                               .getNodeType()
+                               .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+                         && !currLocation
+                               .getStateMachineNode()
+                               .getNodeType()
+                               .equals(XmlSchemaStateMachineNode.Type.ANY))));
+
+      if (currLocation == null) {
+        throw new IllegalStateException(
+            "Cannot find " + elemName + " in the path!");
+
+      } else if (
+          currLocation
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+          && !currLocation
+                .getStateMachineNode()
+                .getElement()
+                .getQName()
+                .equals(elemName)) {
+        throw new IllegalStateException(
+            "The next element in the path is "
+            + currLocation.getStateMachineNode().getElement().getQName()
+            + " ("
+            + currLocation.getDirection()
+            + "), not "
+            + elemName
+            + ".");
+      }
+    }
+
+    /**
+     * For a path to be exiting a particular element's
+     * scope, it must be doing one of four things:
+     *
+     * 1. It is null, indicating the end of the document.
+     * 2. It is a PARENT path to the owning element's parent.
+     * 3. It is a CHILD path to the owning element's child (wildcard) element.
+     * 4. It is a SIBLING path to a new element instance.
+     */
+    private static boolean pathExitsElementScope(
+        XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path,
+        XmlSchemaDocumentNode<AvroRecordInfo> owningElem,
+        boolean ignoreAny) {
+
+      // 1. This is the end of the path.
+      if (path == null) {
+        return true;
+      }
+
+      // 2. This is a PARENT path to the owning element's parent.
+      final XmlSchemaDocumentNode<AvroRecordInfo> parentElem =
+          owningElem.getParent();
+
+      if (path.getDirection().equals(XmlSchemaPathNode.Direction.PARENT)
+          && path.getDocumentNode() == parentElem) {
+        return true;
+      }
+
+      // 3. It is a CHILD path to the owning element's child.
+      final XmlSchemaStateMachineNode.Type nodeType =
+          path.getStateMachineNode().getNodeType();
+
+      final boolean isElement =
+          nodeType.equals(XmlSchemaStateMachineNode.Type.ELEMENT);
+
+      final boolean isAny =
+          nodeType.equals(XmlSchemaStateMachineNode.Type.ANY);
+
+      if (path.getDirection().equals(XmlSchemaPathNode.Direction.CHILD)
+          && (isElement || (isAny && !ignoreAny))) {
+        return true;
+      }
+
+      // 4. It is a SIBLING path to a new element instance.
+      if (path.getDirection().equals(XmlSchemaPathNode.Direction.SIBLING)
+          && (isElement || (isAny && !ignoreAny))) {
+        return true;
+      }
+
+      // It is none of these things; we are still in the scope.
+      return false;
+    }
+
+    private static boolean hasMoreContent(
+        XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path,
+        XmlSchemaDocumentNode<AvroRecordInfo> owningElem) {
+
+      if (path == null) {
+        return false;
+      }
+
+      while (!pathExitsElementScope(path, owningElem, true)
+             && !path
+                  .getDirection()
+                  .equals(XmlSchemaPathNode.Direction.CONTENT) ) {
+        path = path.getNext();
+      }
+
+      if ((path != null)
+          && path
+               .getDirection()
+               .equals(XmlSchemaPathNode.Direction.CONTENT) ) {
+        return true;
+      }
+
+      return false;
+    }
+
+    private XmlSchemaPathNode walkToContent(
+        XmlSchemaDocumentNode<AvroRecordInfo> owningElem) {
+
+      if (currLocation == null) {
+        return null;
+      }
+
+      XmlSchemaPathNode path = currLocation.getNext();
+
+      while (!pathExitsElementScope(path, owningElem, false)
+             && !path
+                  .getDirection()
+                  .equals(XmlSchemaPathNode.Direction.CONTENT) ) {
+        path = path.getNext();
+      }
+
+      if ((path != null)
+          && path
+               .getDirection()
+               .equals(XmlSchemaPathNode.Direction.CONTENT) ) {
+        return path;
+      }
+
+      return null;
+    }
+
+    private boolean isMapEnd() {
+      XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> position = currLocation;
+      AvroPathNode pathInfo = null;
+
+      do {
+        position = position.getNext();
+        if (position != null) {
+          pathInfo = position.getUserDefinedContent();
+        }
+      } while ((position != null)
+                && ((pathInfo == null)
+                    || ((pathInfo != null)
+                         && pathInfo.getType().equals(
+                             AvroPathNode.Type.CONTENT))));
+
+      return ((position != null)
+              && position
+                   .getUserDefinedContent()
+                   .getType()
+                   .equals(AvroPathNode.Type.MAP_END));
+    }
+
+    private static String getAttrValue(
+        Attributes atts,
+        String namespaceUri,
+        String name) {
+
+      /* Attributes in XML Schema each have their own namespace, which
+       * is not supported in Avro.  So, we will see if we can find the
+       * attribute using the existing namespace, and if not, we will
+       * walk all of them to see which one has the same name.
+       */
+      String value =
+          atts.getValue(namespaceUri, name);
+
+      if (value == null) {
+        for (int attrIndex = 0;
+            attrIndex < atts.getLength();
+            ++attrIndex) {
+          if (atts.getLocalName(attrIndex).equals(name)) {
+            value = atts.getValue(attrIndex);
+            break;
+          }
+        }
+      }
+
+      return value;
+    }
+
+    private void write(
+        XmlSchemaTypeInfo xmlType,
+        QName xmlQName,
+        Schema schema,
+        String data) throws IOException {
+
+      write(xmlType, xmlQName, schema, data, -1);
+    }
+
+    private void write(
+        XmlSchemaTypeInfo xmlType,
+        QName xmlQName,
+        Schema schema,
+        String data,
+        int unionIndex)
+        throws IOException {
+
+      /* If the data is empty or null, write
+       * it as a null or string, if possible.
+       */
+      final XmlSchemaBaseSimpleType baseType = xmlType.getBaseType();
+
+      if ((data == null) || data.isEmpty()) {
+        boolean isNullable = (schema.getType().equals(Schema.Type.NULL));
+        boolean isString = (schema.getType().equals(Schema.Type.STRING));
+        int nullUnionIndex = -1;
+        int stringIndex = -1;
+        if (!isNullable
+            && !isString
+            && schema.getType().equals(Schema.Type.UNION)) {
+
+          for (int typeIndex = 0;
+              typeIndex < schema.getTypes().size();
+              ++typeIndex) {
+
+            final Schema.Type type =
+                schema.getTypes().get(typeIndex).getType();
+
+            if (type.equals(Schema.Type.NULL)) {
+              nullUnionIndex = typeIndex;
+              isNullable = true;
+              break;
+            } else if (type.equals(Schema.Type.STRING)) {
+              isString = true;
+              stringIndex = typeIndex;
+            }
+          }
+        }
+
+        if (isString && (data != null) && data.isEmpty()) {
+          // Preserve empty strings when possible.
+          if (stringIndex >= 0) {
+            out.writeIndex(stringIndex);
+          }
+          out.writeString(data);
+
+        } else if (isNullable) {
+          if (nullUnionIndex >= 0) {
+            out.writeIndex(nullUnionIndex);
+          }
+          out.writeNull();
+
+        } else if (isString) {
+          if (stringIndex >= 0) {
+            out.writeIndex(stringIndex);
+          }
+          out.writeString("");
+
+        } else {
+            throw new IOException(
+                "Cannot write a null or empty string "
+                + "as a non-null or non-string type.");
+        }
+
+        return;
+      }
+
+      switch ( schema.getType() ) {
+      case ARRAY:
+        {
+          /* While unions of lists of different types are technically possible, 
+           * supporting them here would be difficult, to say the least.  For
+           * now, only one array type will be supported in a union.
+           */
+          if (unionIndex >= 0) {
+            out.writeIndex(unionIndex);
+          }
+
+          if ( xmlType.getType().equals(XmlSchemaTypeInfo.Type.UNION) ) {
+            xmlType = Utils.chooseUnionType(xmlType, null, schema, unionIndex);
+          }
+          if ( xmlType.getType().equals(XmlSchemaTypeInfo.Type.LIST) ) {
+            xmlType = xmlType.getChildTypes().get(0);
+          }
+
+          final String[] items = data.split(" ");
+          final List<String> itemList = new ArrayList<String>(items.length);
+          for (String item : items) {
+            if ( !item.isEmpty() ) {
+              itemList.add(item);
+            }
+          }
+          out.writeArrayStart();
+          out.setItemCount( itemList.size() );
+          for (String item : itemList) {
+            out.startItem();
+            write(xmlType, xmlQName, schema.getElementType(), item);
+          }
+          out.writeArrayEnd();
+          break;
+        }
+      case UNION:
+        {
+          int textIndex = -1;
+          int bytesIndex = -1;
+
+          Schema bytesType = null;
+
+          final List<Schema> subTypes = schema.getTypes();
+          boolean written = false;
+          for (int subTypeIndex = 0;
+              subTypeIndex < subTypes.size();
+              ++subTypeIndex) {
+            // Try the text types last.
+            final Schema subType = subTypes.get(subTypeIndex);
+            if (subType.getType().equals(Schema.Type.BYTES)) {
+              bytesIndex = subTypeIndex;
+              bytesType = subType;
+              continue;
+            } else if (subType.getType().equals(Schema.Type.STRING)) {
+              textIndex = subTypeIndex;
+              continue;
+            }
+
+            // Determine the corresponding XML union type.
+            XmlSchemaTypeInfo xmlSubType = xmlType;
+            if ( xmlType.getType().equals(XmlSchemaTypeInfo.Type.UNION) ) {
+              xmlSubType =
+                  Utils.chooseUnionType(
+                      xmlType,
+                      xmlQName,
+                      subType,
+                      subTypeIndex);
+            }
+
+            if (xmlSubType != null) {
+              try {
+                write(xmlSubType, xmlQName, subType, data, subTypeIndex);
+                written = true;
+                break;
+              } catch (Exception e) {
+                /* Could not parse the value using the
+                 * provided type; try the next one.
+                 */
+              }
+            }
+          }
+
+          if (!written) {
+            if (bytesIndex >= 0) {
+              XmlSchemaTypeInfo subType = xmlType;
+              if (xmlType.getType().equals(XmlSchemaTypeInfo.Type.UNION)) {
+                subType =
+                    Utils.chooseUnionType(
+                        xmlType,
+                        xmlQName,
+                        schema.getTypes().get(bytesIndex),
+                        bytesIndex);
+              }
+
+              // Only write the bytes if we know how.
+              if (subType != null) {
+                try {
+                  write(subType, xmlQName, bytesType, data, bytesIndex);
+                  written = true;
+                } catch (Exception e) {
+                  // Cannot write the data as bytes either.
+                }
+              }
+            }
+            if (!written && (textIndex >= 0)) {
+              out.writeIndex(textIndex);
+              out.writeString(data);
+
+            } else if (!written) {
+              throw new IOException(
+                  "Cannot write \""
+                  + data
+                  + "\" as one of the types in "
+                  + schema.toString());
+            }
+          }
+          break;
+        }
+      case BYTES:
+        {
+          byte[] bytes = null;
+          switch (baseType) {
+          case BIN_BASE64:
+            bytes = DatatypeConverter.parseBase64Binary(data);
+            break;
+          case BIN_HEX:
+            bytes = DatatypeConverter.parseHexBinary(data);
+            break;
+          case DECIMAL:
+            {
+              final BigDecimal decimal =
+                  Utils.createBigDecimalFrom(data, schema);
+              final BigInteger unscaledValue =
+                  decimal.unscaledValue();
+              bytes = unscaledValue.toByteArray();
+              break;
+            }
+          default:
+            throw new IllegalArgumentException(
+                "Cannot generate bytes for data of a base type of "
+                + baseType);
+          }
+          if (unionIndex >= 0) {
+            out.writeIndex(unionIndex);
+          }
+          out.writeBytes(bytes);
+          break;
+        }
+      case STRING:
+        {
+          if (unionIndex >= 0) {
+            out.writeIndex(unionIndex);
+          }
+          out.writeString(data);
+          break;
+        }
+      case ENUM:
+        {
+          if ( !schema.hasEnumSymbol(data) ) {
+            final int numSymbols = schema.getEnumSymbols().size();
+
+            StringBuilder errMsg = new StringBuilder("\"");
+            errMsg.append(data);
+            errMsg.append("\" is not a member of the symbols [\"");
+            for (int symbolIndex = 0;
+                symbolIndex < numSymbols - 1;
+                ++symbolIndex) {
+              errMsg.append( schema.getEnumSymbols().get(symbolIndex) );
+              errMsg.append("\", \"");
+            }
+            errMsg.append( schema.getEnumSymbols().get(numSymbols - 1) );
+            errMsg.append("\"].");
+
+            throw new IOException( errMsg.toString() );
+          }
+          if (unionIndex >= 0) {
+            out.writeIndex(unionIndex);
+          }
+          out.writeEnum( schema.getEnumOrdinal(data) );
+          break;
+        }
+      case DOUBLE:
+        {
+          try {
+            final double value = Double.parseDouble(data);
+            if (unionIndex >= 0) {
+              out.writeIndex(unionIndex);
+            }
+            out.writeDouble(value);
+          } catch (NumberFormatException nfe) {
+            throw new IOException("\"" + data + "\" is not a double.", nfe);
+          }
+          break;
+        }
+      case FLOAT:
+        {
+          try {
+            final float value = Float.parseFloat(data);
+            if (unionIndex >= 0) {
+              out.writeIndex(unionIndex);
+            }
+            out.writeFloat(value);
+          } catch (NumberFormatException nfe) {
+            throw new IOException("\"" + data + "\" is not a float.", nfe);
+          }
+          break;
+        }
+      case LONG:
+        {
+          try {
+            final long value = Long.parseLong(data);
+            if (unionIndex >= 0) {
+              out.writeIndex(unionIndex);
+            }
+            out.writeLong(value);
+          } catch (NumberFormatException nfe) {
+            throw new IOException("\"" + data + "\" is not a long.", nfe);
+          }
+          break;
+        }
+      case INT:
+        {
+          try {
+            final int value = Integer.parseInt(data);
+            if (unionIndex >= 0) {
+              out.writeIndex(unionIndex);
+            }
+            out.writeInt(value);
+          } catch (NumberFormatException nfe) {
+            throw new IOException("\"" + data + "\" is not an int.", nfe);
+          }
+          break;
+        }
+      case BOOLEAN:
+        {
+          if (data.equalsIgnoreCase("true")
+              || data.equalsIgnoreCase("false")) {
+            if (unionIndex >= 0) {
+              out.writeIndex(unionIndex);
+            }
+            out.writeBoolean( Boolean.parseBoolean(data) );
+          } else {
+            throw new IOException('"' + data + "\" is not a boolean.");
+          }
+          break;
+        }
+      case RECORD:
+        {
+          switch (baseType) {
+          case QNAME:
+            {
+              try {
+                final QName qName =
+                    DatatypeConverter.parseQName(data, nsContext);
+
+                if (unionIndex >= 0) {
+                  out.writeIndex(unionIndex);
+                }
+                out.writeString( qName.getNamespaceURI() );
+                out.writeString( qName.getLocalPart() );
+
+              } catch (IllegalArgumentException e) {
+                throw new IOException("\"" + data + "\" is not a QName.", e);
+              }
+              break;
+            }
+           default:
+             throw new IOException(
+                 "Cannot write a record of XML Schema Type " + baseType);
+          }
+          break;
+        }
+      default:
+        throw new IOException("Cannot write data of type " + schema.getType());
+      }
+    }
+  }
+
+  public XmlDatumWriter(XmlDatumConfig config, Schema avroSchema)
+      throws IOException {
+
+    if (config == null) {
+      throw new IllegalArgumentException("XmlDatumConfig cannot be null.");
+    }
+
+    xmlSchemaCollection = new XmlSchemaCollection();
+    xmlSchemaCollection.setSchemaResolver(new XmlSchemaMultiBaseUriResolver());
+    xmlSchemaCollection.setBaseUri(config.getBaseUri());
+    for (StreamSource source : config.getSources()) {
+      xmlSchemaCollection.read(source);
+    }
+
+    final XmlSchemaStateMachineGenerator stateMachineGen =
+        new XmlSchemaStateMachineGenerator();
+
+    final XmlSchemaWalker walker =
+        new XmlSchemaWalker(xmlSchemaCollection, stateMachineGen);
+    walker.setUserRecognizedTypes( Utils.getAvroRecognizedTypes() );
+
+    AvroSchemaGenerator avroSchemaGen = null;
+    if (avroSchema == null) {
+      avroSchemaGen =
+          new AvroSchemaGenerator(
+              config.getBaseUri(),
+              config.getSchemaUrls(),
+              config.getSchemaFiles());
+      walker.addVisitor(avroSchemaGen);
+    }
+
+    final XmlSchemaElement rootElement =
+        xmlSchemaCollection.getElementByQName(config.getRootTagName());
+    walker.walk(rootElement);
+
+    stateMachine = stateMachineGen.getStartNode();
+
+    if (avroSchema == null) {
+      schema = avroSchemaGen.getSchema();
+    } else {
+      schema = avroSchema;
+    }
+  }
+
+  public XmlDatumWriter(XmlDatumConfig config) throws IOException {
+    this(config, null);
+  }
+
+  /**
+   * Returns the {@link Schema} this <code>XmlDatumWriter</code> is
+   * writing against - either the one automatically generated from
+   * the {@link XmlDatumConfig} or the {@link Schema} set after that.
+   */
+  public Schema getSchema() {
+    return schema;
+  }
+
+  /**
+   * Sets the schema to use when writing the XML
+   * {@link Document} to the {@link Encoder}.
+   *
+   * @see org.apache.avro.io.DatumWriter#setSchema(org.apache.avro.Schema)
+   */
+  @Override
+  public void setSchema(Schema schema) {
+    if (schema == null) {
+      throw new IllegalArgumentException("Avro schema cannot be null.");
+    }
+    this.schema = schema;
+  }
+
+  /**
+   * Writes the {@link Document} to the {@link Encoder} in accordance
+   * with the {@link Schema} set in {@link #setSchema(Schema)}.
+   *
+   * <p>
+   * If no {@link Schema} was provided, builds one from the {@link Document}
+   * and its {@link XmlSchemaCollection}.  The schema can then be retrieved
+   * from {@link #getSchema()}.
+   * </p>
+   *
+   * @see DatumWriter#write(java.lang.Object, org.apache.avro.io.Encoder)
+   */
+  @Override
+  public void write(Document doc, Encoder out) throws IOException {
+    // 1. Build the path through the schema that describes the document.
+    XmlSchemaPathFinder pathFinder = new XmlSchemaPathFinder(stateMachine);
+    SaxWalkerOverDom walker = new SaxWalkerOverDom(pathFinder);
+    try {
+      walker.walk(doc);
+    } catch (Exception se) {
+      throw new IOException("Unable to parse the document.", se);
+    }
+    final XmlSchemaPathNode<AvroRecordInfo, AvroPathNode> path =
+        pathFinder.getXmlSchemaDocumentPath();
+
+    // 2. Apply Avro schema metadata on top of the document. 
+    final AvroSchemaApplier applier = new AvroSchemaApplier(schema, false);
+    applier.apply(path);
+
+    // 3. Encode the document.
+    walker.removeContentHandler(pathFinder);
+    walker.addContentHandler( new Writer(path, out) );
+
+    try {
+      walker.walk(doc);
+    } catch (SAXException e) {
+      throw new IOException("Unable to encode the document.", e);
+    }
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaBaseSimpleType.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaBaseSimpleType.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaBaseSimpleType.java	(working copy)
@@ -0,0 +1,81 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.HashMap;
+
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.constants.Constants;
+
+/**
+ * Represents the set of simple types defined by XML Schema, and
+ * conversions between them and their respective {@link QName}s.
+ */
+enum XmlSchemaBaseSimpleType {
+  ANYTYPE(Constants.XSD_ANYTYPE),
+  ANYSIMPLETYPE(Constants.XSD_ANYSIMPLETYPE),
+  DURATION(Constants.XSD_DURATION),
+  DATETIME(Constants.XSD_DATETIME),
+  TIME(Constants.XSD_TIME),
+  DATE(Constants.XSD_DATE),
+  YEARMONTH(Constants.XSD_YEARMONTH),
+  YEAR(Constants.XSD_YEAR),
+  MONTHDAY(Constants.XSD_MONTHDAY),
+  DAY(Constants.XSD_DAY),
+  MONTH(Constants.XSD_MONTH),
+  STRING(Constants.XSD_STRING),
+  BOOLEAN(Constants.XSD_BOOLEAN),
+  BIN_BASE64(Constants.XSD_BASE64),
+  BIN_HEX(Constants.XSD_HEXBIN),
+  FLOAT(Constants.XSD_FLOAT),
+  DECIMAL(Constants.XSD_DECIMAL),
+  DOUBLE(Constants.XSD_DOUBLE),
+  ANYURI(Constants.XSD_ANYURI),
+  QNAME(Constants.XSD_QNAME),
+  NOTATION(Constants.XSD_NOTATION);
+
+  private QName qName;
+
+  XmlSchemaBaseSimpleType(QName qName) {
+    this.qName = qName;
+  }
+
+  QName getQName() {
+    return qName;
+  }
+
+  private static HashMap<QName, XmlSchemaBaseSimpleType> reverseMap =
+      new HashMap<QName, XmlSchemaBaseSimpleType>();
+
+  static {
+    final XmlSchemaBaseSimpleType[] types = XmlSchemaBaseSimpleType.values();
+    for (XmlSchemaBaseSimpleType type : types) {
+      reverseMap.put(type.getQName(), type);
+    }
+  }
+
+  static XmlSchemaBaseSimpleType getBaseSimpleTypeFor(QName qName) {
+    return reverseMap.get(qName);
+  }
+
+  static boolean isBaseSimpleType(QName qName) {
+    return reverseMap.containsKey(qName);
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaDocumentNode.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaDocumentNode.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaDocumentNode.java	(working copy)
@@ -0,0 +1,222 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+/**
+ * The <code>XmlSchemaDocumentNode</code> represents a node in the
+ * XML Schema as it is used by an XML document.  As {@link XmlSchemaPathFinder}
+ * walks through an XML document, it builds {@link XmlSchemaPathNode}s
+ * representing the path walked, and <code>XmlSchemaDocumentNode</code>s
+ * representing where the XML document's elements fall in the XML Schema's
+ * sequences, choices, and all groups.
+ */
+final class XmlSchemaDocumentNode<U> {
+
+  private XmlSchemaStateMachineNode stateMachineNode;
+  private XmlSchemaDocumentNode parent;
+  private List<SortedMap<Integer, XmlSchemaDocumentNode<U>>> children;
+  private List<XmlSchemaPathNode> visitors;
+  private boolean receivedContent;
+  private U userDefinedContent;
+
+  XmlSchemaDocumentNode(
+      XmlSchemaDocumentNode parent,
+      XmlSchemaStateMachineNode stateMachineNode) {
+
+    userDefinedContent = null;
+    set(parent, stateMachineNode);
+  }
+
+  XmlSchemaStateMachineNode getStateMachineNode() {
+    return stateMachineNode;
+  }
+
+  XmlSchemaDocumentNode getParent() {
+    return parent;
+  }
+
+  SortedMap<Integer, XmlSchemaDocumentNode<U>> getChildren() {
+    if (children == null) {
+      return null;
+    } else {
+      return getChildren(children.size());
+    }
+  }
+
+  SortedMap<Integer, XmlSchemaDocumentNode<U>> getChildren(int iteration) {
+    if ((children == null)
+          || (children.size() < iteration)
+          || (iteration < 1)) {
+      return null;
+    } else {
+      return children.get(iteration - 1);
+    }
+  }
+
+  /**
+   * Indicates whether an element has text in it.
+   */
+  boolean getReceivedContent() {
+    return receivedContent;
+  }
+
+  void setReceivedContent(boolean receivedContent) {
+    this.receivedContent = receivedContent;
+  }
+
+  /**
+   * A visitor is a CHILD or SIBLING {@link XmlSchemaPathNode} entering
+   * this <code>XmlSchemaDocumentNode</code>.  This is used to keep track
+   * of how many occurrences are active via the current path winding
+   * through the schema.
+   */
+  void addVisitor(XmlSchemaPathNode path) {
+    if (path.getDocumentNode() != this) {
+      throw new IllegalArgumentException(
+          "Path node must have this XmlSchemaDocumentNode "
+          + "as its document node.");
+    }
+
+    switch( path.getDirection() ) {
+    case CHILD:
+    case SIBLING:
+      break;
+    default:
+      throw new IllegalArgumentException(
+          "Only CHILD and SIBLING paths may be visitors of an "
+          + "XmlSchemaDocumentNode, not a "
+          + path.getDirection()
+          + " path.");
+    }
+
+    if (visitors == null) {
+      visitors = new ArrayList<XmlSchemaPathNode>(4);
+    }
+
+    if (children != null) { 
+      if (children.size() == visitors.size()) {
+        children.add( new TreeMap<Integer, XmlSchemaDocumentNode<U>>() );
+      } else {
+        throw new IllegalStateException("Attempted to add a new visitor when the number of occurrences (" + children.size() + ") did not match the number of existing visitors (" + visitors.size() + ").");
+      }
+    }
+
+    visitors.add(path);
+  }
+
+  boolean removeVisitor(XmlSchemaPathNode path) {
+    if ((visitors == null) || visitors.isEmpty()) {
+      return false;
+    }
+
+    if ((children != null) && (visitors.size() != children.size())) {
+      throw new IllegalStateException(
+          "The number of visitors ("
+          + visitors.size()
+          + ") does not match the number of occurrences ("
+          + children.size()
+          + ").");
+    }
+
+    int visitorIndex = 0;
+    for (; visitorIndex < visitors.size(); ++visitorIndex) {
+      if (visitors.get(visitorIndex) == path) {
+        break;
+      }
+    }
+
+    if (visitors.size() == visitorIndex) {
+      return false;
+    }
+
+    visitors.remove(visitorIndex);
+
+    if (children != null) {
+      children.remove(visitorIndex);
+    }
+
+    return true;
+  }
+
+  int getIteration() {
+    if ((children != null) && (children.size() != visitors.size())) {
+      throw new IllegalStateException(
+          "The number of occurrences ("
+          + children.size()
+          + ") is not equal to the number of visitors ("
+          + visitors.size()
+          + ").");
+    }
+    return visitors.size();
+  }
+
+  long getMinOccurs() {
+    return stateMachineNode.getMinOccurs();
+  }
+
+  long getMaxOccurs() {
+    return stateMachineNode.getMaxOccurs();
+  }
+
+  int getSequencePosition() {
+    if ((children == null)
+        || (!stateMachineNode
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.SEQUENCE))) {
+      return -1;
+    } else if (children.isEmpty()) {
+      return 0;
+    } else if (children.get(children.size() - 1).isEmpty()) {
+      return 0;
+    } else {
+      return children.get(children.size() - 1).lastKey();
+    }
+  }
+
+  void set(
+      XmlSchemaDocumentNode parent,
+      XmlSchemaStateMachineNode stateMachineNode) {
+
+    this.parent = parent;
+    this.stateMachineNode = stateMachineNode;
+    this.receivedContent = false;
+    this.visitors = null;
+
+    if ((this.stateMachineNode.getPossibleNextStates() == null)
+        || this.stateMachineNode.getPossibleNextStates().isEmpty()) {
+      this.children = null;
+
+    } else {
+      this.children =
+          new ArrayList<SortedMap<Integer, XmlSchemaDocumentNode<U>>>(1);
+    }
+  }
+
+  U getUserDefinedContent() {
+    return userDefinedContent;
+  }
+
+  void setUserDefinedContent(U userDefinedContent) {
+    this.userDefinedContent = userDefinedContent;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaElementValidator.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaElementValidator.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaElementValidator.java	(working copy)
@@ -0,0 +1,975 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.bind.DatatypeConverter;
+import javax.xml.bind.ValidationException;
+import javax.xml.datatype.DatatypeConfigurationException;
+import javax.xml.datatype.DatatypeFactory;
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaUse;
+import org.xml.sax.Attributes;
+
+/**
+ * Methods to confirm that an XML element and
+ * its attributes all conform to its XML Schema.
+ */
+final class XmlSchemaElementValidator {
+
+  private static DatatypeFactory datatypeFactory = null;
+
+  private static DatatypeFactory getDatatypeFactory() {
+    if (datatypeFactory == null) {
+      try {
+        datatypeFactory = DatatypeFactory.newInstance();
+      } catch (DatatypeConfigurationException e) {
+        throw new IllegalStateException(
+            "Unable to create the DatatypeFactory for validating XML Schema "
+            + "durations.",
+            e);
+      }
+    }
+    return datatypeFactory;
+  }
+
+  static void validateAttributes(
+      XmlSchemaStateMachineNode state,
+      Attributes attrs,
+      NamespaceContext nsContext) throws ValidationException {
+
+    if ((state == null)
+        || (attrs == null)
+        || (nsContext == null)
+        || !state
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      throw new ValidationException(
+          "None of state, attrs, or nsContext can be null, and state must"
+          + " be of an SchemaStateMachineNode.Type.ELEMENT node, not "
+          + ((state == null) ? null : state.getNodeType()));
+    }
+
+    final List<XmlSchemaStateMachineNode.Attribute> attributes =
+        state.getAttributes();
+
+    if ((attributes == null) || attributes.isEmpty()) {
+      // Nothing to validate.
+      return;
+    }
+
+    final QName elemQName = state.getElement().getQName();
+
+    for (XmlSchemaStateMachineNode.Attribute attribute : attributes) {
+      final XmlSchemaAttribute xmlSchemaAttr = attribute.getAttribute();
+      final QName attrQName = xmlSchemaAttr.getQName();
+      final XmlSchemaUse use = xmlSchemaAttr.getUse();
+
+      String value =
+          attrs.getValue(
+              attrQName.getNamespaceURI(),
+              attrQName.getLocalPart());
+
+      if (value == null) {
+        // A namespace is not always available.
+        value = attrs.getValue("", attrQName.getLocalPart());
+      }
+
+      if (value != null) {
+        value = value.trim();
+      }
+
+      // Confirm the attribute is used correctly.
+      switch (use) {
+      case OPTIONAL:
+        break;
+      case PROHIBITED:
+        if ((value != null) && !value.isEmpty()) {
+          throw new ValidationException(
+              "Attribute "
+              + attrQName
+              + " was declared 'prohibited' by "
+              + elemQName
+              + " and cannot have a value.");
+        }
+        break;
+      case REQUIRED:
+        if ((value == null) || value.isEmpty()) {
+          throw new ValidationException(
+              "Attribute "
+              + attrQName
+              + " was declared 'required' by "
+              + elemQName
+              + " and must have a value.");
+        }
+        break;
+      case NONE:
+        /* An attribute with no usage is optional, which
+         * was already taken care of by XmlSchemaWalker.
+         */
+      default:
+        throw new ValidationException(
+            "Attribute "
+            + attrQName
+            + " of element "
+            + elemQName
+            + " has an unrecognized usage of "
+            + use
+            + ".");
+      }
+
+      /* If the value is null or empty there is no
+       * further validation we can perform here.
+       */
+      if ((value == null) || value.isEmpty()) {
+        continue;
+      }
+
+      if (attribute
+            .getType()
+            .getType()
+            .equals(XmlSchemaTypeInfo.Type.COMPLEX) ) {
+
+        throw new ValidationException(
+            "Attribute "
+            + attrQName
+            + " of element "
+            + elemQName
+            + " cannot have a COMPLEX type.");
+      }
+
+      validateType(
+          "Attribute " + attrQName + " of " + elemQName,
+          value,
+          attribute.getType(),
+          nsContext);
+    }
+  }
+
+  static void validateContent(
+      XmlSchemaStateMachineNode state,
+      String elementContent,
+      NamespaceContext nsContext) throws ValidationException {
+
+    if ((state == null)
+        || (nsContext == null)
+        || !state
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      throw new ValidationException(
+          "Niether state nor nsContext can be null, and state must be of an "
+          + "SchemaStateMachineNode.Type.ELEMENT node, not "
+          + ((state == null) ? null : state.getNodeType()));
+    }
+
+    final QName elemQName = state.getElement().getQName();
+    final XmlSchemaTypeInfo elemType = state.getElementType();
+    final XmlSchemaElement element = state.getElement();
+
+    if (elementContent != null) {
+      elementContent = elementContent.trim();
+    }
+
+    switch ( elemType.getType() ) {
+    case COMPLEX:
+      {
+        if (!elemType.isMixed()
+          && (elementContent != null)
+          && !elementContent.isEmpty()) {
+          
+          /* If a type is COMPLEX, then it either is a mixed type or it only
+           * has elements as children.  Likewise, if the text is not null or
+           * empty, and the type is not mixed, then element content is where
+           * it is not expected.
+           */
+          throw new ValidationException(
+              elemQName
+              + " is a non-mixed complex type, therefore there should"
+              + " not be any content between the tags, like \""
+              + elementContent
+              + "\".");
+        }
+        break;
+      }
+    case ATOMIC:
+    case LIST:
+    case UNION:
+      {
+        if ((elementContent == null) || elementContent.isEmpty()) {
+          if ( state.getElement().isNillable() ) {
+            // Null is a perfectly valid state.
+            return;
+          } else {
+            elementContent = element.getDefaultValue();
+            if (elementContent == null) {
+              elementContent = element.getFixedValue();
+            }
+            if (elementContent == null) {
+              throw new ValidationException(
+                  "Element "
+                  + elemQName
+                  + " has no content, no default value, and no fixed value,"
+                  + " but is of type "
+                  + elemType.getType()
+                  + ".");
+            }
+          }
+        }
+        validateType(
+            elemQName.toString(),
+            elementContent,
+            elemType,
+            nsContext);
+        break;
+      }
+    default:
+      throw new IllegalStateException(
+          elemQName
+          + " has an unrecognized content type of "
+          + elemType.getType()
+          + ".");
+    }
+  }
+
+  private static void validateType(
+      String name,
+      String value,
+      XmlSchemaTypeInfo typeInfo,
+      NamespaceContext nsContext) throws ValidationException {
+
+    if ((value == null) || value.isEmpty()) {
+      throw new ValidationException(
+          name + " cannot have a null or empty value!");
+    }
+
+    final HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+      facets = typeInfo.getFacets();
+
+    switch ( typeInfo.getType() ) {
+    case ATOMIC:
+      validateAtomicType(name, value, typeInfo, nsContext);
+      break;
+    case LIST:
+      {
+        /* A list is a whitespace-separated series of elements.
+         * Split the list and perform a type-check on the items.
+         */
+        final String[] values = value.split(" ");
+        for (String item : values) {
+          validateType(
+              name + " item value \"" + item + "\"",
+              item,
+              typeInfo.getChildTypes().get(0),
+              nsContext);
+        }
+        listLengthChecks(name, values, facets);
+        break;
+      }
+    case UNION:
+      {
+        /* We just want to confirm that the value we are given
+         * validates against at least one of the types; we do
+         * not care which one.
+         */
+        boolean foundValidType = false;
+        for (XmlSchemaTypeInfo unionType : typeInfo.getChildTypes()) {
+          try {
+            validateType(name, value, unionType, nsContext);
+            foundValidType = true;
+            break;
+          } catch (ValidationException e) {
+            // The type did not validate; try another.
+          }
+        }
+        if (!foundValidType) {
+          StringBuilder errMsg = new StringBuilder(name);
+          errMsg.append(" does not validate against any of its union of");
+          errMsg.append(" types.  The value is \"").append(value);
+          errMsg.append("\" and the union types are: ");
+
+          for (int childIndex = 0;
+               childIndex < typeInfo.getChildTypes().size() - 1;
+              ++childIndex) {
+
+            errMsg.append(
+                typeInfo
+                  .getChildTypes()
+                  .get(childIndex)
+                  .getBaseType() );
+            errMsg.append(", ");
+
+          }
+          errMsg
+            .append(
+                typeInfo
+                  .getChildTypes()
+                  .get(typeInfo.getChildTypes().size() - 1)
+                  .getBaseType());
+          errMsg.append('.');
+
+          throw new ValidationException( errMsg.toString() );
+        }
+        break;
+      }
+    case COMPLEX:
+      // This only validates if the type is mixed.
+      if ( !typeInfo.isMixed() ) {
+        throw new ValidationException(
+            name
+            + " has a value of \""
+            + value
+            + "\" but it represents a non-mixed complex type.");
+      }
+      break;
+    default:
+      throw new ValidationException(
+          name
+          + " has an unrecognized type of "
+          + typeInfo.getType());
+    }
+  }
+
+  private static void validateAtomicType(
+      String name,
+      String value,
+      XmlSchemaTypeInfo typeInfo,
+      NamespaceContext nsContext) throws ValidationException {
+
+    if ( !typeInfo.getType().equals(XmlSchemaTypeInfo.Type.ATOMIC) ) {
+      throw new ValidationException(
+          name
+          + " must have a type of ATOMIC, not "
+          + typeInfo.getType());
+
+    } else if ((value == null) || value.isEmpty()) {
+      throw new ValidationException(
+          name
+          + " cannot have a null or empty value when validating.");
+    }
+
+    final Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        typeInfo.getFacets();
+
+    switch( typeInfo.getBaseType() ) {
+    case ANYTYPE:
+    case ANYSIMPLETYPE:
+    case ANYURI:
+      /* anyURI has no equivalent type in Java.
+       * (from http://docs.oracle.com/cd/E19159-01/819-3669/bnazf/index.html)
+       */
+    case STRING:
+      // Text plus facets.
+      stringLengthChecks(name, DatatypeConverter.parseString(value), facets);
+      break;
+
+    case DURATION:
+      try {
+        getDatatypeFactory().newDuration(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid duration.",
+            iae);
+      }
+      break;
+
+    case DATETIME:
+      try {
+        DatatypeConverter.parseDateTime(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid date-time.",
+            iae);
+      }
+      break;
+
+    case TIME:
+      try {
+        DatatypeConverter.parseTime(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid time.",
+            iae);
+      }
+      break;
+      
+    case DATE:
+      try {
+        DatatypeConverter.parseDate(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid date.",
+            iae);
+      }
+      break;
+
+    case YEARMONTH:
+      try {
+        getDatatypeFactory().newXMLGregorianCalendar(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid Year-Month.",
+            iae);
+      }
+      break;
+
+    case YEAR:
+      try {
+        getDatatypeFactory().newXMLGregorianCalendar(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid year.",
+            iae);
+      }
+      break;
+
+    case MONTHDAY:
+      try {
+        getDatatypeFactory().newXMLGregorianCalendar(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid month-day.",
+            iae);
+      }
+      break;
+
+    case DAY:
+      try {
+        getDatatypeFactory().newXMLGregorianCalendar(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid day.",
+            iae);
+      }
+      break;
+
+    case MONTH:
+      try {
+        getDatatypeFactory().newXMLGregorianCalendar(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid month.",
+            iae);
+      }
+      break;
+
+      // Dates
+    case BOOLEAN:
+      if (!value.equalsIgnoreCase("true")
+          && !value.equalsIgnoreCase("false")) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid boolean; must be \"true\" or \"false\".");
+      }
+      break;
+
+    case BIN_BASE64:
+      try {
+        DatatypeConverter.parseBase64Binary(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not valid base-64 binary.",
+            iae);
+      }
+      break;
+
+    case BIN_HEX:
+      try {
+        DatatypeConverter.parseHexBinary(value);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not valid hexadecimal binary.",
+            iae);
+      }
+      break;
+
+    case FLOAT:
+      try {
+        rangeChecks(
+            name,
+            new BigDecimal( DatatypeConverter.parseFloat(value) ),
+            facets);
+      } catch (NumberFormatException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid float.",
+            iae);
+      }
+      break;
+
+    case DECIMAL:
+      try {
+        final BigDecimal decimal = DatatypeConverter.parseDecimal(value);
+        rangeChecks(name, decimal, facets);
+        digitsFacetChecks(name, decimal, facets);
+      } catch (NumberFormatException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid decimal.",
+            iae);
+      }
+      break;
+
+    case DOUBLE:
+      try {
+        rangeChecks(
+            name,
+            new BigDecimal( DatatypeConverter.parseDouble(value) ),
+            facets);
+      } catch (NumberFormatException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid double.",
+            iae);
+      }
+      break;
+
+    case QNAME:
+      try {
+        DatatypeConverter.parseQName(value, nsContext);
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid .",
+            iae);
+      }
+      break;
+
+    case NOTATION:
+      try {
+        /* The value space of NOTATION is the set of QNames
+         * of notations declared in the current schema.
+         */
+        final String[] qNames = value.split(" ");
+        for (String qName : qNames) {
+          DatatypeConverter.parseQName(qName, nsContext);
+        }
+
+      } catch (IllegalArgumentException iae) {
+        throw new ValidationException(
+            name
+            + " value of \""
+            + value
+            + "\" is not a valid series of QNames.",
+            iae);
+      }
+      break;
+
+    default:
+      throw new ValidationException(
+          name
+          + " has an unrecognized base value type of "
+          + typeInfo.getBaseType());
+    }
+
+    checkEnumerationFacet(name, value, facets);
+  }
+
+  private static void rangeChecks(
+      String name,
+      BigDecimal value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets)
+  throws ValidationException {
+
+    if (facets == null) {
+      return;
+    }
+
+    rangeCheck(name, value, facets, XmlSchemaRestriction.Type.EXCLUSIVE_MIN);
+    rangeCheck(name, value, facets, XmlSchemaRestriction.Type.INCLUSIVE_MIN);
+    rangeCheck(name, value, facets, XmlSchemaRestriction.Type.EXCLUSIVE_MAX);
+    rangeCheck(name, value, facets, XmlSchemaRestriction.Type.INCLUSIVE_MAX);
+  }
+
+  private static void rangeCheck(
+      String name,
+      BigDecimal value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets,
+      XmlSchemaRestriction.Type rangeType)
+  throws ValidationException {
+
+    final List<XmlSchemaRestriction> rangeFacets = facets.get(rangeType);
+
+    boolean satisfied = true;
+    BigDecimal compareTo = null;
+
+    if ((rangeFacets != null) && !rangeFacets.isEmpty()) {
+      for (XmlSchemaRestriction rangeFacet : rangeFacets) {
+        compareTo = getBigDecimalOf( rangeFacet.getValue() );
+        final int comparison = value.compareTo(compareTo);
+
+        switch (rangeType) {
+        case EXCLUSIVE_MIN:
+          satisfied = (comparison > 0);
+          break;
+        case INCLUSIVE_MIN:
+          satisfied = (comparison >= 0);
+          break;
+        case EXCLUSIVE_MAX:
+          satisfied = (comparison < 0);
+          break;
+        case INCLUSIVE_MAX:
+          satisfied = (comparison <= 0);
+          break;
+        default:
+          throw new ValidationException(
+              "Cannot perform a range check of type " + rangeType);
+        }
+
+        if (!satisfied) {
+          break;
+        }
+      }
+    }
+
+    if (!satisfied) {
+      throw new ValidationException(
+          name
+          + " value \""
+          + value
+          + "\" violates the "
+          + rangeType
+          + " restriction of "
+          + compareTo
+          + ".");
+    }
+  }
+
+  private static BigDecimal getBigDecimalOf(Object numericValue) {
+    BigDecimal newValue = null;
+
+    if (numericValue instanceof BigDecimal) {
+      newValue = (BigDecimal) numericValue;
+
+    } else if (numericValue instanceof Double) {
+      newValue = new BigDecimal(((Double) numericValue).doubleValue());
+
+    } else if (numericValue instanceof Float) {
+      newValue = new BigDecimal(((Float) numericValue).floatValue());
+
+    } else if (numericValue instanceof BigInteger) {
+      newValue = new BigDecimal((BigInteger) numericValue);
+
+    } else if (numericValue instanceof Number) {
+      newValue = new BigDecimal(((Number) numericValue).longValue());
+
+    } else if (numericValue instanceof String) {
+      newValue = new BigDecimal(numericValue.toString());
+
+    } else {
+      throw new IllegalArgumentException(
+          numericValue.getClass().getName()
+          + " is not a subclass of java.lang.Number.");
+    }
+
+    return newValue;
+  }
+
+  private static void stringLengthChecks(
+      String name,
+      String value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets)
+  throws ValidationException {
+
+    if (facets == null) {
+      return;
+    }
+
+    stringLengthCheck(name, value, facets, XmlSchemaRestriction.Type.LENGTH);
+
+    stringLengthCheck(name,
+                      value,
+                      facets,
+                      XmlSchemaRestriction.Type.LENGTH_MIN);
+
+    stringLengthCheck(name,
+                      value,
+                      facets,
+                      XmlSchemaRestriction.Type.LENGTH_MAX);
+  }
+
+  private static void stringLengthCheck(
+      String name,
+      String value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets,
+      XmlSchemaRestriction.Type facetType)
+  throws ValidationException {
+
+    final List<XmlSchemaRestriction> lengthFacets = facets.get(facetType);
+    int lengthRestriction = -1;
+    boolean satisfied = true;
+
+    if (lengthFacets != null) {
+      for (XmlSchemaRestriction lengthFacet : lengthFacets) {
+        lengthRestriction =
+            Integer.parseInt( lengthFacet.getValue().toString() );
+
+        switch (facetType) {
+        case LENGTH:
+          satisfied = (value.length() == lengthRestriction);
+          break;
+        case LENGTH_MIN:
+          satisfied = (value.length() >= lengthRestriction);
+          break;
+        case LENGTH_MAX:
+          satisfied = (value.length() <= lengthRestriction);
+          break;
+        default:
+          throw new IllegalArgumentException(
+              "Cannot perform a length restriction of type " + facetType);
+        }
+
+        if (!satisfied) {
+          break;
+        }
+      }
+    }
+
+    if (!satisfied) {
+      throw new ValidationException(
+          name
+          + " value \""
+          + value
+          + "\" does not meet the "
+          + facetType
+          + " restriction of "
+          + lengthRestriction
+          + ".");
+    }
+  }
+
+  private static void listLengthChecks(
+      String name,
+      String[] value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets)
+  throws ValidationException {
+
+    if (facets == null) {
+      return;
+    }
+
+    listLengthCheck(name, value, facets, XmlSchemaRestriction.Type.LENGTH);
+    listLengthCheck(name, value, facets, XmlSchemaRestriction.Type.LENGTH_MIN);
+    listLengthCheck(name, value, facets, XmlSchemaRestriction.Type.LENGTH_MAX);
+  }
+
+  private static void listLengthCheck(
+      String name,
+      String[] value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets,
+      XmlSchemaRestriction.Type facetType)
+  throws ValidationException {
+
+    final List<XmlSchemaRestriction> lengthFacets = facets.get(facetType);
+    int lengthRestriction = -1;
+    boolean satisfied = true;
+
+    if (lengthFacets != null) {
+      for (XmlSchemaRestriction lengthFacet : lengthFacets) {
+        lengthRestriction =
+            Integer.parseInt( lengthFacet.getValue().toString() );
+
+        switch (facetType) {
+        case LENGTH:
+          satisfied = (value.length == lengthRestriction);
+          break;
+        case LENGTH_MIN:
+          satisfied = (value.length >= lengthRestriction);
+          break;
+        case LENGTH_MAX:
+          satisfied = (value.length <= lengthRestriction);
+          break;
+        default:
+          throw new IllegalArgumentException(
+              "Cannot perform a length restriction of type " + facetType);
+        }
+
+        if (!satisfied) {
+          break;
+        }
+      }
+    }
+
+    if (!satisfied) {
+      throw new ValidationException(
+          name
+          + " value of length "
+          + value.length
+          + " does not meet the "
+          + facetType
+          + " restriction of "
+          + lengthRestriction
+          + ".");
+    }
+  }
+
+  private static void digitsFacetChecks(
+      String name,
+      BigDecimal value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets)
+  throws ValidationException {
+
+    if (facets == null) {
+      return;
+    }
+
+    digitsFacetCheck(
+        name,
+        value,
+        facets,
+        XmlSchemaRestriction.Type.DIGITS_FRACTION);
+
+    digitsFacetCheck(
+        name,
+        value,
+        facets,
+        XmlSchemaRestriction.Type.DIGITS_TOTAL);
+  }
+
+  private static void digitsFacetCheck(
+      String name,
+      BigDecimal value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets,
+      XmlSchemaRestriction.Type facetType)
+  throws ValidationException {
+
+    final List<XmlSchemaRestriction> digitsFacets = facets.get(facetType);
+    int numDigits = 0;
+    boolean satisfied = true;
+
+    if (digitsFacets != null) {
+      for (XmlSchemaRestriction digitsFacet : digitsFacets) {
+        numDigits = Integer.parseInt( digitsFacet.getValue().toString() );
+        switch (facetType) {
+        case DIGITS_FRACTION:
+          satisfied = (value.scale() <= numDigits);
+          break;
+        case DIGITS_TOTAL:
+        {
+          satisfied = (value.precision() <= numDigits);
+          break;
+        }
+        default:
+          throw new IllegalArgumentException(
+              "Cannot perform a digits facet check with a facet of type "
+              + facetType);
+        }
+      }
+    }
+
+    if (!satisfied) {
+      StringBuilder errMsg = new StringBuilder(name);
+      errMsg.append(" value \"").append(value);
+      errMsg.append("\" does not meet the ").append(facetType);
+      errMsg.append(" check of ").append(numDigits).append(" digits.");
+
+      throw new ValidationException( errMsg.toString() );
+    }
+  }
+
+  private static void checkEnumerationFacet(
+      String name,
+      String value,
+      Map<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets)
+  throws ValidationException {
+
+    if (facets == null) {
+      return;
+    }
+
+    final List<XmlSchemaRestriction> enumFacets =
+        facets.get(XmlSchemaRestriction.Type.ENUMERATION);
+
+    if (enumFacets == null) {
+      return;
+    }
+
+    boolean found = false;
+    for (XmlSchemaRestriction enumFacet : enumFacets) {
+      if ( value.equals(enumFacet.getValue().toString()) ) {
+        found = true;
+        break;
+      }
+    }
+
+    if (!found) {
+      StringBuilder errMsg = new StringBuilder(name);
+      errMsg.append(" value \"").append(value).append("\" is not a member of");
+      errMsg.append(" the enumeration {\"");
+      for (int enumIndex = 0; enumIndex < enumFacets.size() - 1; ++enumIndex) {
+        errMsg.append( enumFacets.get(enumIndex).getValue() ).append("\", \"");
+      }
+      errMsg.append( enumFacets.get(enumFacets.size() - 1).getValue() );
+      errMsg.append("\"}.");
+
+      throw new ValidationException( errMsg.toString() );
+    }
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaMultiBaseUriResolver.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaMultiBaseUriResolver.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaMultiBaseUriResolver.java	(working copy)
@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.avro.xml;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.List;
+import java.util.ListIterator;
+
+import org.apache.ws.commons.schema.resolver.DefaultURIResolver;
+import org.xml.sax.InputSource;
+
+/**
+ * This class is used by
+ * {@link org.apache.ws.commons.schema.XmlSchemaCollection}
+ * to resolve schemas from multiple base URIs.
+ */
+class XmlSchemaMultiBaseUriResolver extends DefaultURIResolver {
+
+  private List<String> baseUris;
+
+  public XmlSchemaMultiBaseUriResolver() {
+    baseUris = new java.util.ArrayList<String>();
+  }
+
+  /**
+   * Resolves the schema at the provided location
+   * with the specified input namespace and base URI.
+   *
+   * @see org.apache.ws.commons.schema.resolver.URIResolver#resolveEntity(String, String, String)
+   */
+  @SuppressWarnings("unused")
+  public InputSource resolveEntity(
+      String namespace,
+      String schemaLocation,
+      String baseUri) {
+
+    InputSource source = null;
+    if ((baseUri != null) && !baseUri.isEmpty()) {
+      baseUris.add(baseUri);
+    }
+
+    /* Confirm the schema location is a fully-qualified
+     * path before adding it to the set of base URIs.
+     */
+    try {
+      new URL(schemaLocation);
+      baseUris.add(schemaLocation);
+    } catch (MalformedURLException e) {
+    }
+
+    /* When we receive a schema location, it may only be a partial path.
+     * That partial path may come from one of many different base URIs
+     * that we've seen already, most likely from one we recently tried.
+     * So, in order to determine which base URI the partial schema comes
+     * from, we must try them all and see which one resolves.
+     *
+     * We check in reverse order because a schema is likely tied to a
+     * recent base URI we have already seen.
+     */
+    ListIterator<String> iter = baseUris.listIterator(baseUris.size() - 1);
+    while (iter.hasPrevious()) {
+      try {
+        String newBaseUri = iter.previous();
+        source = super.resolveEntity(namespace, schemaLocation, newBaseUri);
+        InputStream urlStream = null;
+        try {
+          urlStream = new URL(source.getSystemId()).openStream();
+        } finally {
+          if (urlStream != null) {
+            try {
+              urlStream.close();
+            } catch (IOException ioe) {
+              // No error for failure to close.
+            }
+          }
+        }
+        break;
+      } catch (IOException ioe) {
+        /* If we reach here, we were unable to open a
+         * connection to the source.  Try the next one.
+         */
+      }
+    }
+    return source;
+  }
+
+  /**
+   * Returns one of the base URIs provided earlier.
+   */
+  @Override
+  public String getCollectionBaseURI() {
+    return baseUris.isEmpty() ? null : baseUris.get(0);
+  }
+
+  /**
+   * Adds the provided URI to the set of base URIs to check.
+   */
+  @Override
+  public void setCollectionBaseURI(String uri) {
+    baseUris.add(uri);
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaNamespaceContext.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaNamespaceContext.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaNamespaceContext.java	(working copy)
@@ -0,0 +1,164 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.ws.commons.schema.constants.Constants;
+import org.apache.ws.commons.schema.utils.NamespacePrefixList;
+
+/**
+ * A {@link javax.xml.namespace.NamespaceContext}.
+ *
+ * <p>
+ * Implemented as a series of scope-based stacks, one per prefix.
+ * </p>
+ */
+final class XmlSchemaNamespaceContext implements NamespacePrefixList {
+
+  private Map<String, List<String>> namespacesByPrefixStack;
+
+  XmlSchemaNamespaceContext() {
+    namespacesByPrefixStack = new HashMap<String, List<String>>();
+
+    namespacesByPrefixStack.put(
+        Constants.XML_NS_PREFIX,
+        Collections.singletonList(Constants.XML_NS_URI));
+
+    namespacesByPrefixStack.put(
+        Constants.XMLNS_ATTRIBUTE,
+        Collections.singletonList(Constants.XMLNS_ATTRIBUTE_NS_URI));
+  }
+
+  @Override
+  public String getNamespaceURI(String prefix) {
+    if (prefix == null) {
+      throw new IllegalArgumentException("Prefix cannot be null.");
+    }
+    final List<String> namespaces = namespacesByPrefixStack.get(prefix);
+
+    String namespace = null;
+    if ((namespaces == null) || namespaces.isEmpty()) {
+      namespace = Constants.NULL_NS_URI;
+    } else {
+      namespace = namespaces.get(namespaces.size() - 1);
+    }
+
+    return namespace;
+  }
+
+  @Override
+  public String getPrefix(String namespaceUri) {
+    if (namespaceUri == null) {
+      throw new IllegalArgumentException("Namespace cannot be null.");
+    }
+
+    for (Map.Entry<String, List<String>> prefixEntry
+        : namespacesByPrefixStack.entrySet()) {
+
+      final List<String> namespaceStack = prefixEntry.getValue();
+      if((namespaceStack != null)
+          && !namespaceStack.isEmpty()
+          && namespaceStack
+               .get(namespaceStack.size() - 1)
+               .equals(namespaceUri)) {
+        return prefixEntry.getKey();
+      }
+    }
+
+    return null;
+  }
+
+  @Override
+  public Iterator getPrefixes(String namespaceUri) {
+    if (namespaceUri == null) {
+      throw new IllegalArgumentException("The Namespace URI cannot be null.");
+    }
+
+    ArrayList<String> prefixes = new ArrayList<String>();
+
+    for (Map.Entry<String, List<String>> prefixEntry
+          : namespacesByPrefixStack.entrySet()) {
+
+      final List<String> namespaceStack = prefixEntry.getValue();
+      if((namespaceStack != null)
+          && !namespaceStack.isEmpty()
+          && namespaceStack
+               .get(namespaceStack.size() - 1)
+               .equals(namespaceUri)) {
+
+        prefixes.add( prefixEntry.getKey() );
+      }
+    }
+
+    return prefixes.iterator();
+  }
+
+  @Override
+  public String[] getDeclaredPrefixes() {
+    final Set<String> prefixes = namespacesByPrefixStack.keySet();
+    return prefixes.toArray(new String[prefixes.size()]);
+  }
+
+  /**
+   * Adds a new prefix mapping to the context.  Returns true
+   * if the mapping is new, and <code>false</code> if it already existed. 
+   */
+  void addNamespace(String prefix, String namespaceUri) {
+    if ((prefix == null)
+        || (namespaceUri == null)
+        || namespaceUri.isEmpty()) {
+
+      throw new IllegalArgumentException(
+          "The prefix may not be null, and the namespace URI "
+          + "may neither be null nor empty.");
+    }
+
+    List<String> namespaceStack = namespacesByPrefixStack.get(prefix);
+    if (namespaceStack == null) {
+      namespaceStack = new ArrayList<String>(1);
+      namespacesByPrefixStack.put(prefix, namespaceStack);
+    }
+    namespaceStack.add(namespaceUri);
+  }
+
+  void removeNamespace(String prefix) {
+    final List<String> namespaceStack = namespacesByPrefixStack.get(prefix);
+    if ((namespaceStack == null) || namespaceStack.isEmpty()) {
+      throw new IllegalStateException(
+          "Prefix \""
+          + prefix
+          + "\" is not mapped to any namespaces.");
+    }
+    namespaceStack.remove(namespaceStack.size() - 1);
+    if (namespaceStack.isEmpty()) {
+      namespacesByPrefixStack.remove(prefix);
+    }
+  }
+
+  void clear() {
+    namespacesByPrefixStack.clear();
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathFinder.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathFinder.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathFinder.java	(working copy)
@@ -0,0 +1,1957 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.bind.ValidationException;
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.xml.sax.Attributes;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
+
+/**
+ * Performs a SAX-based walk through the XML document, determining the
+ * interpretation ("path") that best matches both the XML Schema and the
+ * Avro Schema.
+ */
+final class XmlSchemaPathFinder extends DefaultHandler {
+
+  /* If a group loops back on itself, we don't want to loop
+   * until the stack overflows looking for a valid match.
+   * We will stop looking once we reach MAX_DEPTH.
+   */
+  private static final int MAX_DEPTH = 256;
+
+  private final XmlSchemaNamespaceContext nsContext;
+
+  private XmlSchemaPathNode rootPathNode;
+
+  private XmlSchemaPathNode currentPath;
+
+  private ArrayList<TraversedElement> traversedElements;
+  private ArrayList<DecisionPoint> decisionPoints;
+
+  private ArrayList<QName> elementStack;
+  private ArrayList<QName> anyStack;
+
+  private XmlSchemaPathManager pathMgr;
+
+  /* We want to keep track of all of the valid path segments to a particular
+   * element, but we do not want to stomp on the very first node until we
+   * know which path we want to follow.  Likewise, we want to keep the
+   * first node in the segment without a "next" node, but every node after
+   * that we wish to chain together.
+   *
+   * To accomplish this, we start with a base node at the end and "prepend"
+   * previous nodes until we work our way back to the beginning.  When we
+   * prepend a node, we link the previous start node to the node directly
+   * after it, while leaving the new start node unlinked.
+   *
+   * Path segments may also be recycled when a decision point is refuted.
+   */
+  private final class PathSegment implements Comparable<PathSegment> {
+
+    private XmlSchemaPathNode start;
+    private XmlSchemaPathNode end;
+    private XmlSchemaPathNode afterStart;
+    private int length;
+    private int afterStartPathIndex;
+
+    PathSegment(XmlSchemaPathNode node) {
+      set(node);
+    }
+
+    @Override
+    public int compareTo(PathSegment o) {
+      if (this == o) {
+        return 0;
+      }
+
+      /* Paths which end in a wildcard element are of lower
+       * rank (higher order) than those that end in elements.
+       */
+      if ( !end
+              .getStateMachineNode()
+              .getNodeType()
+              .equals( o.getEnd().getStateMachineNode().getNodeType() ) ) {
+
+        if ( end
+              .getStateMachineNode()
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.ANY) ) {
+          return 1;
+
+        } else if ( o.getEnd()
+                     .getStateMachineNode()
+                     .getNodeType()
+                     .equals(XmlSchemaStateMachineNode.Type.ANY) ) {
+          return -1;
+
+        } else {
+          throw new IllegalStateException(
+              "The end nodes do not have the same machine node type, so one "
+              + "should be an ELEMENT and the other should be an ANY.  "
+              + "However, this end node is a "
+              + end.getStateMachineNode().getNodeType()
+              + " while the other has an end node of type "
+              + o.getEnd().getStateMachineNode().getNodeType() + ".");
+        }
+      }
+
+      final int thisLength = getLength();
+      final int thatLength = o.getLength();
+
+      /* Paths that walk through earlier sequence group children are
+       * preferred over paths that walk through later sequence group
+       * children.  They provide more options later.
+       *
+       * Shorter paths are also preferred over longer ones.
+       */
+      if ((thisLength > 0) && (thatLength > 0)) {
+        // Both paths have more than just one element.
+        XmlSchemaPathNode thisIter = afterStart;
+        XmlSchemaPathNode thatIter = o.getAfterStart();
+
+        while ((thisIter != null) && (thatIter != null)) {
+          if (thisIter.getDirection().getRank()
+               < thatIter.getDirection().getRank() ) {
+            return -1;
+          } else if (thisIter.getDirection().getRank()
+              > thatIter.getDirection().getRank()) {
+            return 1;
+          }
+
+          if (thisIter.getIndexOfNextNodeState()
+                < thatIter.getIndexOfNextNodeState()) {
+
+            return -1;
+
+          } else if (thisIter.getIndexOfNextNodeState()
+                       > thatIter.getIndexOfNextNodeState()) {
+
+            return  1;
+          }
+
+          thisIter = thisIter.getNext();
+          thatIter = thatIter.getNext();
+        }
+
+        if ((thisIter == null) && (thatIter != null)) {
+          // This path is shorter.
+          return -1;
+        } else if ((thisIter != null) && (thatIter == null)) {
+          // That path is shorter.
+          return 1;
+        }
+
+      } else if ((thisLength == 0) && (thatLength > 0)) {
+        // This path is shorter.
+        return -1;
+
+      } else if ((thisLength > 0) && (thatLength == 0)) {
+        // That path is shorter.
+        return 1;
+
+      } else {
+        // Both paths have exactly one element.
+        if (end.getIndexOfNextNodeState()
+              < o.getEnd().getIndexOfNextNodeState()) {
+
+          return -1;
+
+        } else if (end.getIndexOfNextNodeState()
+                     > o.getEnd().getIndexOfNextNodeState()) {
+
+          return 1;
+        }
+      }
+
+      /* If all of our different heuristics do not differentiate the
+       * paths, we will return equality.  This is fine because
+       * Collections.sort(List<T>) is stable, and will preserve the
+       * ordering.
+       */
+      return 0;
+    }
+
+    int getLength() {
+      if ((length == 0) && (start != end)) {
+        for (XmlSchemaPathNode iter = afterStart;
+            iter != end;
+            iter = iter.getNext()) {
+          ++length;
+        }
+        ++length; // (afterStart -> end) + start
+      }
+      return length;
+    }
+
+    /* Prepends a new start node to this segment.  We want to clone
+     * the previous start node as sibling paths may be sharing it.
+     * We also need to know the newStart's path index to reach the
+     * clonedStartNode, so we know how to properly link them later.
+     */
+    void prepend(XmlSchemaPathNode newStart, int pathIndexToNextNode) {
+      // We need to clone start and make it the afterStart.
+      final XmlSchemaPathNode clonedStartNode = pathMgr.clone(start);
+
+      if (afterStart != null) {
+        afterStart.setPreviousNode(clonedStartNode);
+        clonedStartNode.setNextNode(afterStartPathIndex, afterStart);
+        afterStart = clonedStartNode;
+
+      } else {
+        // This path segment only has one node in it; now it has two.
+        end = clonedStartNode;
+        afterStart = clonedStartNode;
+      }
+
+      start = newStart;
+      afterStartPathIndex = pathIndexToNextNode;
+      length = 0; // Force a recalculation.
+    }
+
+    XmlSchemaPathNode getStart() {
+      return start;
+    }
+
+    XmlSchemaPathNode getEnd() {
+      return end;
+    }
+
+    XmlSchemaPathNode getAfterStart() {
+      return afterStart;
+    }
+
+    int getAfterStartPathIndex() {
+      return afterStartPathIndex;
+    }
+
+    void set(XmlSchemaPathNode node) {
+      if (node == null) {
+        throw new IllegalArgumentException("DocumentPathNode cannot be null.");
+      }
+
+      this.start = node;
+      this.end = node;
+      this.afterStart = null;
+      this.afterStartPathIndex = -1;
+      this.length = 0;
+    }
+
+    @Override
+    public String toString() {
+      final StringBuilder str = new StringBuilder("Path Segment: [ ");
+
+      str.append( start.getDirection() ).append(" | ");
+      str.append( start.getStateMachineNode() ).append(" ]");
+
+      if (afterStart != null) {
+        XmlSchemaPathNode path = afterStart;
+
+        do {
+          str.append(" [").append( path.getDirection() ).append(" | ");
+          str.append( path.getStateMachineNode() ).append(" ]");
+
+          path = path.getNext();
+        } while (path != null);
+
+      } else {
+        str.append(" [").append( end.getDirection() ).append(" | ");
+        str.append( end.getStateMachineNode() ).append(" ]");
+      }
+
+      return str.toString();
+    }
+  }
+
+  /**
+   * A <code>DescisionPoint</code> is a location in a document path where
+   * an element in the document can be reached by following two or more
+   * different traversals through the XML Schema.
+   *
+   * When we reach such a decision point, we will keep track of the different
+   * paths through the XML Schema that reach the element.  We will then follow
+   * each path, one-by-one from the shortest through the longest, until we find
+   * a path that successfully navigates both the document and the schema.
+   */
+  private static class DecisionPoint {
+
+    private final XmlSchemaPathNode decisionPoint;
+    private final List<PathSegment> choices;
+    private final int traversedElementIndex;
+    private final ArrayList<QName> elementStack;
+    private final ArrayList<QName> anyStack;
+
+    DecisionPoint(
+        XmlSchemaPathNode decisionPoint,
+        List<PathSegment> choices,
+        int traversedElementIndex,
+        ArrayList<QName> elementStack,
+        ArrayList<QName> anyStack) {
+
+      if (decisionPoint == null) {
+        throw new IllegalArgumentException(
+            "The decision point path node cannot be null.");
+      } else if (choices == null) {
+        throw new IllegalArgumentException(
+            "The set of choice paths to follow cannot be null.");
+      } else if (choices.size() < 2) {
+        throw new IllegalArgumentException(
+            "There must be at least two choices to constitute a decision point"
+            + ", not "
+            + choices.size());
+      }
+
+      this.decisionPoint = decisionPoint;
+      this.choices = choices;
+      this.traversedElementIndex = traversedElementIndex;
+      this.elementStack = (ArrayList<QName>) elementStack.clone();
+
+      if (anyStack == null) {
+        this.anyStack = null;
+      } else {
+        this.anyStack = (ArrayList<QName>) anyStack.clone();
+      }
+
+      java.util.Collections.sort(choices);
+    }
+
+    /**
+     * Returns the next <code>PathSegment</code> to try, or
+     * <code>null</code> if all <code>PathSegment</code>s
+     * have been followed.
+     */
+    PathSegment tryNextPath() {
+      if (choices.isEmpty()) {
+        return null;
+      } else {
+        return choices.remove(0);
+      }
+    }
+
+    XmlSchemaPathNode getDecisionPoint() {
+      return decisionPoint;
+    }
+
+    ArrayList<QName> getElementStack() {
+      return (ArrayList<QName>) elementStack.clone();
+    }
+
+    ArrayList<QName> getAnyStack() {
+      return (anyStack == null) ? null : ((ArrayList<QName>) anyStack.clone());
+    }
+
+    @Override
+    public String toString() {
+      final String nl = System.getProperty("line.separator");
+
+      final StringBuilder str = new StringBuilder("Decision Point: ");
+
+      str.append( decisionPoint.getDirection() ).append(" | ");
+      str.append( decisionPoint.getStateMachineNode() );
+      str.append(" ]").append(nl);
+
+      for (PathSegment choice : choices) {
+        str.append('\t').append(choice).append(nl);
+      }
+
+      return str.toString();
+    }
+  }
+
+  /* Represents an element-start, element-end, or content we have
+   * seen before.  When walking our way through the XML Schema,
+   * we need this information in order to properly backtrack if we
+   * took a wrong path.
+   */
+  private static class TraversedElement {
+
+    QName elemName;
+    Traversal traversal;
+
+    enum Traversal {
+      START,
+      CONTENT,
+      END
+    }
+
+    TraversedElement(QName elemName, Traversal traversal) {
+      this.elemName = elemName;
+      this.traversal = traversal;
+    }
+
+    public String toString() {
+      StringBuilder str = new StringBuilder( elemName.toString() );
+      str.append(" : ").append(traversal);
+      return str.toString();
+    }
+  }
+
+  /* Represents a group's fulfillment state.  It is either not fulfilled,
+   * meaning more children are required, partially fulfilled, meaning at
+   * least the minimum number of children have been added, or completely
+   * fulfilled, meaning no more children can be introduced.
+   */
+  enum Fulfillment {
+    NOT,
+    PARTIAL,
+    COMPLETE
+  }
+
+  /**
+   * Creates a new <code>XmlToAvroPathCreator</code> with the root
+   * {@link XmlSchemaStateMachineNode} to start from when evaluating documents.
+   */
+  XmlSchemaPathFinder(XmlSchemaStateMachineNode root) {
+    pathMgr = new XmlSchemaPathManager();
+    nsContext = new XmlSchemaNamespaceContext();
+
+    rootPathNode =
+        pathMgr.createStartPathNode(XmlSchemaPathNode.Direction.CHILD, root);
+    rootPathNode.setIteration(1);
+
+    traversedElements = new ArrayList<TraversedElement>();
+    elementStack = new ArrayList<QName>();
+    currentPath = null;
+    decisionPoints = null; // Hopefully there won't be any!
+  }
+
+  @Override
+  public void startDocument() throws SAXException {
+    currentPath = null;
+
+    traversedElements.clear();
+    elementStack.clear();
+
+    if (decisionPoints != null) {
+      decisionPoints.clear();
+    }
+  }
+
+  @Override
+  public void startPrefixMapping(String prefix, String uri)
+      throws SAXException {
+
+    nsContext.addNamespace(prefix, uri);
+  }
+
+  @Override
+  public void endPrefixMapping(String prefix) throws SAXException {
+    nsContext.removeNamespace(prefix);
+  }
+
+  /**
+   * Find the path through the XML Schema that best matches this element.
+   *
+   * @see DefaultHandler#startElement(String, String, String, Attributes)
+   */
+  @Override
+  public void startElement(
+      String uri,
+      String localName,
+      String qName,
+      Attributes atts) throws SAXException {
+
+    final QName elemQName = new QName(uri, localName);
+
+    try {
+      if (currentPath == null) {
+        /* We just started a new document.  Likewise we need
+         * to move into a position to process the root element.
+         */
+        currentPath = rootPathNode;
+
+      } else if (currentPath
+                   .getStateMachineNode()
+                   .getNodeType()
+                   .equals(XmlSchemaStateMachineNode.Type.ANY)
+                   && (anyStack != null)
+                   && !anyStack.isEmpty()) {
+        /* If we are currently following a wildcard element node, we don't know
+         * anything about the element or its children.  So it does not make
+         * sense to follow the children or grandchildren of this element.
+         */
+        elementStack.add(elemQName);
+        anyStack.add(elemQName);
+        return;
+      }
+
+      // 1. Find possible paths.
+      List<PathSegment> possiblePaths = find(currentPath, elemQName);
+
+      PathSegment nextPath = null;
+  
+      if ((possiblePaths != null) && !possiblePaths.isEmpty()) {
+        /* 2. If multiple paths were returned, add a DecisionPoint.
+         *    Sort the paths where paths ending in elements are favored over
+         *    element wild cards, and shorter paths are favored over longer
+         *    paths.
+         */
+        if (possiblePaths.size() > 1) {
+          final DecisionPoint decisionPoint =
+              new DecisionPoint(
+                  currentPath,
+                  possiblePaths,
+                  traversedElements.size(),
+                  elementStack,
+                  anyStack);
+
+          if (decisionPoints == null) {
+            decisionPoints = new ArrayList<DecisionPoint>(4);
+          }
+          decisionPoints.add(decisionPoint);
+
+          nextPath = decisionPoint.tryNextPath();
+        } else {
+          nextPath = possiblePaths.get(0);
+        }
+
+        if (nextPath == null) {
+          throw new IllegalStateException(
+              "When searching for "
+              + elemQName
+              + ", received a set of path choices of size "
+              + possiblePaths.size()
+              + ", but the next path is null.");
+        }
+
+        followPath(nextPath);
+
+      } else {
+        // OR: If no paths are returned:
+        while ((decisionPoints != null) && !decisionPoints.isEmpty()) {
+          /* 2a. Backtrack to the most recent decision point.
+           *     Remove the top path (the one we just tried),
+           *     and select the next one.
+           */
+          final DecisionPoint priorPoint =
+              decisionPoints.get(decisionPoints.size() - 1);
+
+          nextPath = priorPoint.tryNextPath();
+
+          if (nextPath == null) {
+            /* We have tried all paths at this decision point.
+             * Remove it and try the next prior decision point.
+             */
+            decisionPoints.remove(decisionPoints.size() - 1);
+            continue;
+          }
+
+          pathMgr.unfollowPath(priorPoint.getDecisionPoint());
+
+          elementStack = priorPoint.getElementStack();
+          anyStack = priorPoint.getAnyStack();
+
+          /* Walk through the traversedElements list again from that
+           * index and see if we traverse through all of the elements
+           * in the list, including this one.  If not, repeat step 2a,
+           * removing decision points from the stack as we refute them.
+           */
+          followPath(nextPath);
+
+          final QName traversedQName =
+              traversedElements.get(priorPoint.traversedElementIndex).elemName;
+
+          elementStack.add(traversedQName);
+
+          if (currentPath
+              .getStateMachineNode()
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.ANY)) {
+            if (anyStack == null) {
+              anyStack = new ArrayList<QName>();
+            }
+            anyStack.add(traversedQName);
+          }
+
+          int index = priorPoint.traversedElementIndex + 1;
+          for (; index < traversedElements.size(); ++index) {
+            nextPath = null;
+
+            final TraversedElement te = traversedElements.get(index);
+
+            if (te.traversal.equals(TraversedElement.Traversal.START)) {
+              possiblePaths = find(currentPath, te.elemName);
+
+              if ((possiblePaths == null) || possiblePaths.isEmpty()) {
+                break;
+
+              } else if (possiblePaths.size() > 1) {
+                final DecisionPoint decisionPoint =
+                    new DecisionPoint(
+                        currentPath,
+                        possiblePaths,
+                        index,
+                        elementStack,
+                        anyStack);
+                decisionPoints.add(decisionPoint);
+                nextPath = decisionPoint.tryNextPath();
+
+              } else {
+                nextPath = possiblePaths.get(0);
+              }
+
+              if (nextPath == null) {
+                throw new IllegalStateException(
+                    "Somehow after finding a new path to follow,"
+                    + " that path is null.");
+              }
+
+              // If we find (a) path(s) that match(es), success!  Follow it.
+              followPath(nextPath);
+
+              if (currentPath
+                  .getStateMachineNode()
+                  .getNodeType()
+                  .equals(XmlSchemaStateMachineNode.Type.ANY)) {
+                if (anyStack == null) {
+                  anyStack = new ArrayList<QName>();
+                }
+                anyStack.add(te.elemName);
+              }
+
+              elementStack.add(te.elemName);
+
+            } else if ( te.traversal.equals(TraversedElement.Traversal.END) ) {
+              final boolean isAny =
+                  (currentPath
+                    .getStateMachineNode()
+                    .getNodeType()
+                    .equals(XmlSchemaStateMachineNode.Type.ANY)
+                    && (anyStack != null) && !anyStack.isEmpty());
+
+              if (!isAny) {
+                walkUpToElement(te.elemName);
+              }
+
+              walkUpTree(te.elemName);
+
+              final QName endingElemName =
+                  elementStack.remove(elementStack.size() - 1);
+
+              if (!te.elemName.equals(endingElemName)) {
+                throw new IllegalStateException(
+                    "Attempted to end element "
+                    + te.elemName
+                    + " but found "
+                    + endingElemName
+                    + " on the stack instead!");
+              }
+
+              if (isAny) {
+                anyStack.remove(anyStack.size() - 1);
+              }
+
+            } else if (
+                te.traversal.equals(TraversedElement.Traversal.CONTENT)) {
+
+              final XmlSchemaPathNode contentPath =
+                  pathMgr.addParentSiblingOrContentNodeToPath(
+                      currentPath,
+                      XmlSchemaPathNode.Direction.CONTENT);
+
+              currentPath.setNextNode(-1, contentPath);
+              currentPath = contentPath;
+
+            } else {
+              throw new IllegalStateException(
+                  "Unrecognized element traversal direction for "
+                  + te.elemName
+                  + " of "
+                  + te.traversal
+                  + '.');
+            }
+          }
+
+          if (index < traversedElements.size()) {
+            /* This attempt is also incorrect.  However, we may have introduced
+             * new decision points along the way, and we want to follow them
+             * first.  So let's go back around for another try.
+             */
+            continue;
+          }
+
+          /* We made it to the end of the element
+           * list! Now try the current one again.
+           */
+          possiblePaths = find(currentPath, elemQName);
+
+          if (possiblePaths == null) {
+            // Still incorrect!
+            continue;
+
+          } else if (possiblePaths.size() > 1) {
+            final DecisionPoint decisionPoint =
+                new DecisionPoint(
+                    currentPath,
+                    possiblePaths,
+                    traversedElements.size(),
+                    elementStack,
+                    anyStack);
+            decisionPoints.add(decisionPoint);
+            nextPath = decisionPoint.tryNextPath();
+          } else {
+            nextPath = possiblePaths.get(0);
+          }
+
+          if (nextPath != null) {
+            followPath(nextPath);
+            break;
+          }
+        }
+      }
+
+      if (nextPath == null) {
+        /* If we go through all prior decision points and are unable to find
+         * one or more paths through the XML Schema that match the document,
+         * throw an error.  There is nothing more we can do here.
+         */
+        throw new IllegalStateException(
+            "Walked through XML Schema and could not find a traversal that "
+            + "represented this XML Document.");
+      }
+
+      /* Current path now points to the element we
+       * just started.  Validate its attributes.
+       */
+      validateAttributes(atts);
+
+      traversedElements.add(
+          new TraversedElement(elemQName, TraversedElement.Traversal.START));
+      elementStack.add(elemQName);
+
+      /* If this is element is of type xsd:any, we do not track it or its
+       * children.  So, we keep a stack of the element and its children,
+       * allowing us to know when we leave and can start tracking elements
+       * again.
+       */
+      if (currentPath
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ANY)) {
+        if (anyStack == null) {
+          anyStack = new ArrayList<QName>();
+        }
+        anyStack.add(elemQName);
+      }
+
+    } catch (Exception e) {
+      /* A SAX Exception cannot be thrown because it is caught, and its
+       * internal exception is thrown instead. Likewise, any useful info
+       * about the error reported in the wrapper SAXException is lost.
+       */
+      throw new RuntimeException(
+          "Error occurred while starting element "
+          + elemQName
+          + "; traversed path is "
+          + getElementsTraversedAsString(),
+          e);
+    }
+  }
+
+  /**
+   * 
+   * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)
+   */
+  @Override
+  public void characters(char[] ch, int start, int length)
+      throws SAXException {
+
+    /* If the most recent path node is an element with simple content,
+     * confirm these characters match the data type expected.
+     *
+     * If we are not expecting an element with simple content,
+     * and the characters don't represent all whitespace, throw
+     * an exception.
+     */
+
+    try {
+      if (currentPath
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ANY)
+          && (anyStack != null) && !anyStack.isEmpty()) {
+        /* If this represents a wildcard element, we don't
+         * care - we won't be processing the content.
+         */
+        return;
+      }   
+
+      final XmlSchemaStateMachineNode state =
+          getStateMachineOfOwningElement();
+
+      final XmlSchemaElement element = state.getElement();
+      final XmlSchemaTypeInfo elemTypeInfo = state.getElementType();
+
+      final String text = new String(ch, start, length).trim();
+
+      final boolean elemExpectsContent =
+          ((elemTypeInfo != null)
+          && (!elemTypeInfo.getType().equals(XmlSchemaTypeInfo.Type.COMPLEX)
+              || elemTypeInfo.isMixed()));
+
+      if (!elemExpectsContent && text.isEmpty()) {
+        // Nothing to see here.
+        return;
+
+      } else if (!elemExpectsContent && !text.isEmpty()) {
+        throw new IllegalStateException(
+            "Element "
+            + state.getElement().getQName()
+            + " has no content, but we received \""
+            + text
+            + "\" for it.");
+
+      } else if (elemExpectsContent
+                   && text.isEmpty()
+                   && !state.getElement().isNillable()
+                   && !elemTypeInfo.isMixed()
+                   && (element.getDefaultValue() == null)
+                   && (element.getFixedValue() == null)) {
+        throw new IllegalStateException(
+            "Received empty text for element "
+            + state.getElement().getQName()
+            + " when content was expected.");
+      }
+
+      XmlSchemaElementValidator.validateContent(state, text, nsContext);
+
+      currentPath.getDocumentNode().setReceivedContent(true);
+
+      final XmlSchemaPathNode contentPath =
+          pathMgr.addParentSiblingOrContentNodeToPath(
+              currentPath,
+              XmlSchemaPathNode.Direction.CONTENT);
+
+      currentPath.setNextNode(-1, contentPath);
+      currentPath = contentPath;
+
+      traversedElements.add(
+          new TraversedElement(element.getQName(),
+              TraversedElement.Traversal.CONTENT) );
+
+    } catch (Exception e) {
+      throw new RuntimeException(
+          "Error occurred while processing characters; traversed path was "
+          + getElementsTraversedAsString(),
+          e);
+    }
+  }
+
+  /**
+   * Confirm the current position matches the element we are ending.
+   * If not, throw an exception.
+   *
+   * If the number of occurrences is less than the minimum number of
+   * occurrences, do not move.  The next element must be an instance
+   * of this one.
+   *
+   * Otherwise, walk back up the tree to the next position.
+   *
+   * If the parent is a group of any kind, and its minimum number of
+   * occurrences is not fulfilled, stop there.
+   *
+   * Otherwise, if the parent is a choice group or substitution group,
+   * walk two levels up to the grandparent.  If the number of occurrences
+   * of this element, the choice group, or the substitution group are
+   * maxed out, and the grandparent is a sequence group or all group,
+   * update the information accordingly.
+   *
+   * If the parent is a sequence group or an all group, update it
+   * accordingly.  Again, if the number of occurrences is equal to
+   * the maximum number, advance the parent accordingly.
+   *
+   * If the parent (or grandparent) is an element, return to it.
+   * We expect the next call to be to endElement of that.
+   *
+   * @see DefaultHandler#endElement(String, String, String)
+   */
+  @Override
+  public void endElement(
+      String uri,
+      String localName,
+      String qName)
+      throws SAXException
+  {
+    final QName elemQName = new QName(uri, localName);
+
+    try {
+      final boolean isAny =
+          (currentPath
+            .getStateMachineNode()
+            .getNodeType()
+            .equals(XmlSchemaStateMachineNode.Type.ANY)
+            && (anyStack != null) && !anyStack.isEmpty());
+
+      if (!isAny
+            && !elementStack.get(elementStack.size() - 1).equals(elemQName) ) {
+        throw new IllegalStateException(
+            "Attempting to end element "
+            + elemQName
+            + " but the stack is expecting "
+            + elementStack.get(elementStack.size() - 1));
+      }
+
+      if (!isAny) {
+        walkUpToElement(elemQName);
+      }
+
+      final XmlSchemaStateMachineNode state =
+          currentPath.getStateMachineNode();
+
+      if (state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+
+        // 1. Is this the element we are looking for?
+        if (!state.getElement().getQName().equals(elemQName) ) {
+          throw new IllegalStateException(
+              "We are ending element "
+              + elemQName
+              + " but our current position is for element "
+              + state.getElement().getQName()
+              + '.');
+        }
+
+        // 2. Check the element received the expected content, if any.
+        final XmlSchemaTypeInfo elemTypeInfo = state.getElementType();
+
+        final boolean elemExpectsContent =
+          (elemTypeInfo != null)
+          && (!elemTypeInfo.getType().equals(XmlSchemaTypeInfo.Type.COMPLEX));
+
+        if (elemExpectsContent
+            && !state.getElement().isNillable()
+            && (state.getElement().getDefaultValue() == null)
+            && (state.getElement().getFixedValue() == null)
+            && !currentPath.getDocumentNode().getReceivedContent()) {
+          throw new IllegalStateException(
+              "We are ending element "
+              + elemQName
+              + "; it expected to receive content but did not.");
+        }
+      }
+
+      traversedElements.add(
+          new TraversedElement(elemQName, TraversedElement.Traversal.END));
+
+      elementStack.remove(elementStack.size() - 1);
+      if (isAny) {
+        anyStack.remove(anyStack.size() - 1);
+      }
+
+      if ((anyStack == null) || anyStack.isEmpty()) {
+        walkUpTree(elemQName);
+      }
+
+    } catch (Exception e) {
+      throw new RuntimeException(
+          "Error occurred while ending element "
+          + elemQName
+          + "; traversed path was "
+          + getElementsTraversedAsString(),
+          e);
+    }
+  }
+
+  @Override
+  public void endDocument() throws SAXException {
+    if ( !elementStack.isEmpty() ) {
+      throw new IllegalStateException(
+          "Ended the document but "
+          + elementStack.size()
+          + " elements have not been closed.");
+    }
+
+    pathMgr.clear();
+
+    if (decisionPoints != null) {
+      decisionPoints.clear();
+    }
+  }
+
+  XmlSchemaPathNode getXmlSchemaDocumentPath() {
+    return rootPathNode;
+  }
+
+  private static Fulfillment isPositionFulfilled(
+      XmlSchemaPathNode currentPath,
+      List<Integer> possiblePaths) {
+
+    boolean completelyFulfilled = true;
+    boolean partiallyFulfilled = true;
+
+    final XmlSchemaStateMachineNode state = currentPath.getStateMachineNode();
+
+    if (currentPath.getDocumentNode() == null) {
+      // This is the root node.  It is not fulfilled.
+      partiallyFulfilled = false;
+    } else if ( currentPath.getDocIteration() >= state.getMinOccurs() ) {
+      partiallyFulfilled = true;
+    } else {
+      partiallyFulfilled = false;
+    }
+
+    if (currentPath.getDocumentNode() == null) {
+      completelyFulfilled = false;
+    } else if (currentPath.getDocIteration() == state.getMaxOccurs()) {
+      completelyFulfilled = true;
+    } else if (currentPath.getDocIteration() > state.getMaxOccurs()) {
+      throw new IllegalStateException(
+          "Current path's document iteration of "
+          + currentPath.getDocIteration()
+          + " is greater than the maximum number of occurrences ("
+          + state.getMaxOccurs()
+          + ").");
+
+    } else {
+      completelyFulfilled = false;
+    }
+
+    final List<XmlSchemaStateMachineNode> nextStates =
+        state.getPossibleNextStates();
+
+    Map<Integer, XmlSchemaDocumentNode> children = null;
+    if (currentPath.getDocumentNode() != null) {
+      children = currentPath.getDocumentNode().getChildren();
+    }
+
+    switch ( state.getNodeType() ) {
+    case ELEMENT:
+    case ANY:
+      // We only needed to perform the occurrence check.
+      break;
+    case CHOICE:
+    case SUBSTITUTION_GROUP:
+      {
+        /* If any child meets the minimum number, we are partially fulfilled.
+         * If all elements meet the maximum, we are completely fulfilled.
+         */
+        boolean groupPartiallyFulfilled = false;
+        boolean groupCompletelyFulfilled = false;
+        for (int stateIndex = 0;
+            stateIndex < nextStates.size();
+            ++stateIndex) {
+
+          XmlSchemaStateMachineNode nextState = nextStates.get(stateIndex);
+
+          if ((children != null) && children.containsKey(stateIndex) ) {
+            final XmlSchemaDocumentNode child = children.get(stateIndex);
+            final int iteration = child.getIteration();
+            if (iteration >= nextState.getMinOccurs()) {
+              groupPartiallyFulfilled = true;
+              if (possiblePaths != null) {
+                possiblePaths.clear();
+                if (iteration < nextState.getMaxOccurs()) {
+                  possiblePaths.add(stateIndex);
+                } else {
+                  groupCompletelyFulfilled = true;
+                }
+              }
+              break;
+            } else if (possiblePaths != null) {
+              possiblePaths.add(stateIndex);
+            }
+          } else {
+            if (nextState.getMinOccurs() == 0) {
+              groupPartiallyFulfilled = true;
+            }
+            if (nextState.getMaxOccurs() == 0) {
+              groupCompletelyFulfilled = true;
+            } else if (possiblePaths != null) {
+              possiblePaths.add(stateIndex);
+            }
+          }
+        }
+        partiallyFulfilled &= groupPartiallyFulfilled;
+        completelyFulfilled &= groupCompletelyFulfilled;
+        break;
+      }
+    case ALL:
+      {
+        // If all children meet the minimum number, we succeeded.
+        for (int stateIndex = 0;
+            stateIndex < nextStates.size();
+            ++stateIndex) {
+
+          final XmlSchemaStateMachineNode nextState =
+              nextStates.get(stateIndex);
+
+          if ((children != null) && children.containsKey(stateIndex)) {
+            final XmlSchemaDocumentNode child = children.get(stateIndex);
+            final int iteration = child.getIteration();
+            if (iteration < nextState.getMinOccurs()) {
+              partiallyFulfilled = false;
+            }
+            if (iteration < nextState.getMaxOccurs()) {
+              completelyFulfilled = false;
+              if (possiblePaths != null) {
+                possiblePaths.add(stateIndex);
+              }
+            }
+          } else {
+            if (nextState.getMinOccurs() > 0) {
+              partiallyFulfilled = false;
+            }
+            if (nextState.getMaxOccurs() > 0) {
+              completelyFulfilled = false;
+              if (possiblePaths != null) {
+                possiblePaths.add(stateIndex);
+              }
+            }
+          }
+        }
+
+        break;
+      }
+    case SEQUENCE:
+      {
+        // If the sequence is complete, we succeeded.
+        int stateIndex = currentPath.getDocSequencePosition();
+        if (stateIndex < 0) {
+          stateIndex = 0;
+        }
+        for (; stateIndex < nextStates.size(); ++stateIndex) {
+          final XmlSchemaStateMachineNode nextState =
+              nextStates.get(stateIndex);
+
+          if ((children != null) && children.containsKey(stateIndex)) {
+            final XmlSchemaDocumentNode child = children.get(stateIndex);
+            if (child.getIteration()
+                < nextState.getMinOccurs()) {
+              partiallyFulfilled = false;
+            }
+            if (child.getIteration() < nextState.getMaxOccurs()) {
+              completelyFulfilled = false;
+              if (possiblePaths != null) {
+                possiblePaths.add(stateIndex);
+              }
+            }
+          } else {
+            if (nextState.getMinOccurs() > 0) {
+              partiallyFulfilled = false;
+            }
+            if (nextState.getMaxOccurs() > 0) {
+              completelyFulfilled = false;
+              if (possiblePaths != null) {
+                possiblePaths.add(stateIndex);
+              }
+            }
+          } 
+        }
+        break;
+      }
+    default:
+      throw new IllegalStateException(
+          "Current position has a node of unrecognized type \""
+          + currentPath.getStateMachineNode().getNodeType()
+          + '\"');
+    }
+
+    Fulfillment fulfillment = Fulfillment.NOT;
+    if (completelyFulfilled) {
+      fulfillment = Fulfillment.COMPLETE;
+    } else if (partiallyFulfilled) {
+      fulfillment = Fulfillment.PARTIAL;
+    }
+    return fulfillment;
+  }
+
+  private List<PathSegment> find(
+      XmlSchemaPathNode startNode,
+      QName elemQName) {
+
+    final XmlSchemaPathNode startOfPath = startNode;
+
+    if (startNode
+          .getStateMachineNode()
+          .getNodeType()
+          .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+        && !elementStack.isEmpty()
+        && startNode
+             .getStateMachineNode()
+             .getElement()
+             .getQName()
+             .equals( elementStack.get(elementStack.size() - 1) )) {
+
+      /* We are at an element in an existing document.  This
+       * is the start node of a child.  Likewise we need to
+       * move down one level to the children.
+       */
+      verifyCurrentPositionIsAtElement("Started element " + elemQName);
+
+      if (startNode
+           .getStateMachineNode()
+           .getPossibleNextStates() == null) {
+
+        final String elemName =
+            getLeafNodeName( startNode.getStateMachineNode() );
+
+        throw new IllegalStateException(
+            "Element "
+            + elemName
+            + " has null children!  Exactly one is expected.");
+
+      } else if (startNode
+                   .getStateMachineNode()
+                   .getPossibleNextStates()
+                   .isEmpty()) {
+
+        final String elemName =
+            getLeafNodeName( startNode.getStateMachineNode() );
+
+        throw new IllegalStateException(
+            "Element "
+            + elemName
+            + " has zero children!  Exactly one is expected.");
+
+      } else if (currentPath
+                   .getStateMachineNode()
+                   .getPossibleNextStates().size() > 1) {
+
+        final String elemName =
+            getLeafNodeName( currentPath.getStateMachineNode() );
+
+        throw new IllegalStateException(
+            "Element "
+            + elemName
+            + " has "
+            + currentPath.getStateMachineNode().getPossibleNextStates().size()
+            + " children!  Only one was expected.");
+      }
+
+      if ((startNode.getDocumentNode() != null)
+          && (startNode.getDocumentNode().getChildren() != null)
+          && !startNode.getDocumentNode().getChildren().isEmpty()
+          && (startNode.getDocumentNode().getChildren().size() > 1)) {
+        throw new IllegalStateException(
+            "There are multiple children in the document node for element "
+            + currentPath.getStateMachineNode().getElement().getQName());
+      }
+
+      final XmlSchemaPathNode childPath =
+          pathMgr.addChildNodeToPath(startNode, 0);
+
+      startNode.setNextNode(0, childPath);
+      startNode = childPath;
+    }
+
+    final List<PathSegment> choices = find(startNode, elemQName, null);
+
+    if ((choices != null) && (startOfPath != startNode)) {
+      /* If we moved down to the children, we need to
+       * prepend the path with the original start node.
+       */
+      for (PathSegment choice : choices) {
+        choice.prepend(startOfPath, 0);
+      }
+    }
+
+    return choices;
+  }
+
+  private List<PathSegment> find(
+      XmlSchemaPathNode startNode,
+      QName elemQName,
+      XmlSchemaStateMachineNode doNotFollow) {
+
+    final ArrayList<Integer> childrenNodes =
+        new ArrayList<Integer>();
+    final boolean isFulfilled =
+        !isPositionFulfilled(startNode, childrenNodes).equals(Fulfillment.NOT);
+
+    // First, try searching down the tree.
+    List<PathSegment> choices = null;
+    List<PathSegment> currChoices = null;
+
+    if (startNode.getIteration() > startNode.getDocIteration()) {
+      choices = find(startNode, elemQName, 0);
+    } else {
+      for (Integer childPath : childrenNodes) {
+        if (doNotFollow
+              == startNode
+                   .getStateMachineNode()
+                   .getPossibleNextStates()
+                   .get(childPath)) {
+          /* We are coming up from a child node; do
+           * not traverse back down to that child.
+           */
+          continue;
+        }
+        final XmlSchemaPathNode currPath =
+            pathMgr.addChildNodeToPath(startNode, childPath);
+  
+        currChoices = find(currPath, elemQName, 0);
+        if (currChoices != null) {
+          for (PathSegment choice : currChoices) {
+            choice.prepend(startNode, childPath);
+          }
+  
+          if (choices == null) {
+            choices = currChoices;
+          } else {
+            choices.addAll(currChoices);
+          }
+        }
+      }
+    }
+
+    // Second, if the node is currently fulfilled, try siblings and parents.
+    if (isFulfilled) {
+
+      // Try siblings.
+      if (startNode.getIteration() < startNode.getMaxOccurs()) {
+        final XmlSchemaPathNode siblingPath =
+            pathMgr.addParentSiblingOrContentNodeToPath(
+                startNode,
+                XmlSchemaPathNode.Direction.SIBLING);
+        siblingPath.setIteration(startNode.getIteration() + 1);
+
+        currChoices = find(siblingPath, elemQName, 0);
+        if (currChoices != null) {
+          for (PathSegment choice : currChoices) {
+            choice.prepend(startNode, -1);
+          }
+
+          if (choices == null) {
+            choices = currChoices;
+          } else {
+            choices.addAll(currChoices);
+          }
+        }
+      }
+
+      // Try parent.
+      if (startNode.getDocumentNode().getParent() == null) {
+        // This is the root element; there is no parent.
+        return choices;
+      }
+
+      final XmlSchemaPathNode path =
+          pathMgr.addParentSiblingOrContentNodeToPath(
+              startNode,
+              XmlSchemaPathNode.Direction.PARENT);
+
+      if (path
+          .getStateMachineNode()
+          .getNodeType()
+          .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+          && path
+             .getStateMachineNode()
+             .getElement()
+             .getQName()
+             .equals(elementStack.get(elementStack.size() - 1))) {
+          return choices;
+      }
+
+      final List<PathSegment> pathsOfParent =
+          find(path, elemQName, startNode.getStateMachineNode());
+
+      if (pathsOfParent != null) {
+        for (PathSegment choice : pathsOfParent) {
+          choice.prepend(startNode, -1);
+        }
+
+        if (choices == null) {
+          choices = pathsOfParent;
+        } else {
+          choices.addAll(pathsOfParent);
+        }
+      } else {
+        // path would not have been recycled at a lower level.
+        pathMgr.recyclePathNode(path);
+      }
+    }
+
+    return choices;
+  }
+
+  private List<PathSegment> find(
+      XmlSchemaPathNode startNode,
+      QName elemQName,
+      int currDepth) {
+
+    final XmlSchemaStateMachineNode state = startNode.getStateMachineNode();
+
+    if (currDepth > MAX_DEPTH) {
+      /* We are likely in an infinite recursive loop looking for an element in
+       * a group whose definition includes itself.  Likewise, we'll stop here
+       * and say we were unable to find the element we were looking for.
+       */
+      return null;
+
+    } else if (startNode.getStateMachineNode() != state) {
+
+      throw new IllegalStateException(
+          "While searching for "
+          + elemQName
+          + ", the DocumentPathNode state machine ("
+          + startNode.getStateMachineNode().getNodeType()
+          + ") does not match the tree node ("
+          + state.getNodeType()
+          + ").");
+
+    } else if (startNode.getIteration()
+                 <= startNode.getDocIteration()) {
+      throw new IllegalStateException(
+          "While searching for "
+          + elemQName
+          + ", the DocumentPathNode iteration ("
+          + startNode.getIteration()
+          + ") should be greater than the tree node's iteration ("
+          + startNode.getDocIteration()
+          + ").  Current state machine position is "
+          + state.getNodeType());
+
+    } else if (state.getMaxOccurs() < startNode.getIteration()) {
+      return null;
+    }
+
+    // If this is a group, confirm it has children.
+    if ( !state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+        && !state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ANY) ) {
+
+      if (( state.getPossibleNextStates() == null)
+          || state.getPossibleNextStates().isEmpty()) {
+
+        throw new IllegalStateException(
+            "Group "
+            + state.getNodeType()
+            + " has no children.  Found when processing "
+            + elemQName);
+      }
+    }
+
+    List<PathSegment> choices = null;
+
+    switch (state.getNodeType()) {
+    case ELEMENT:
+      {
+        if (state.getElement().getQName().equals(elemQName)
+            && startNode.getIteration() <= state.getMaxOccurs()) {
+
+          choices = new ArrayList<PathSegment>(1);
+          choices.add( new PathSegment(startNode) );
+        }
+      }
+      break;
+
+    case SEQUENCE:
+      {
+        // Find the next one in the sequence that matches.
+        int position = startNode.getDocSequencePosition();
+
+        if (startNode.getDocIteration() > startNode.getMaxOccurs()) {
+          throw new IllegalStateException(
+              "Somehow the document iteration for "
+              + startNode.getStateMachineNode()
+              + " of "
+              + startNode.getDocIteration()
+              + " exceeds the maximum number of occurrences of "
+              + startNode.getMaxOccurs());
+
+        } else if (startNode.getDocIteration() == startNode.getMaxOccurs()) {
+          ++position;
+        }
+
+        for (int stateIndex = position;
+            stateIndex
+              < startNode.getStateMachineNode().getPossibleNextStates().size();
+            ++stateIndex) {
+
+          // Process child.
+          final XmlSchemaPathNode nextPath =
+              pathMgr.addChildNodeToPath(startNode, stateIndex);
+
+          /* Both the tree node's and the document path node's state machine
+           * nodes should point to the same state machine node in memory.
+           */
+          if (nextPath.getIteration() > nextPath.getMaxOccurs()) {
+            throw new IllegalStateException(
+                "Reached a sequence group when searching for "
+                + elemQName
+                + " whose iteration at the current position ("
+                + nextPath.getIteration()
+                + ") was already maxed out ("
+                + nextPath.getMaxOccurs()
+                + ").  Was at position "
+                + stateIndex
+                + "; tree node's starting position was "
+                + startNode.getDocSequencePosition());
+          }
+
+          final boolean reachedMinOccurs =
+              (nextPath.getDocIteration() >= nextPath.getMinOccurs());
+
+          final List<PathSegment> seqPaths =
+              find(nextPath, elemQName, currDepth + 1);
+
+          if (seqPaths != null) {
+            for (PathSegment seqPath : seqPaths) {
+              seqPath.prepend(startNode, stateIndex);
+            }
+
+            // nextPath was cloned by all path segments, so it can be recycled.
+            pathMgr.recyclePathNode(nextPath);
+
+            if (choices == null) {
+              choices = seqPaths;
+            } else {
+              choices.addAll(seqPaths);
+            }
+          }
+
+          if (!reachedMinOccurs) {
+
+            /* If we have not traversed this node in the sequence the minimum
+             * number of times, we cannot advance to the next node in the
+             * sequence.
+             */
+            break;
+          }
+        }
+
+        break;
+      }
+
+    case ALL:
+    case SUBSTITUTION_GROUP:
+    case CHOICE:
+      {
+        /* All groups only contain elements.  Find one that matches.
+         * The max-occurrence check will confirm it wasn't already selected.
+         *
+         * Choice groups may have multiple paths through its children
+         * which are valid.  In addition, a wild card ("any" element)
+         * may be a child of any group, thus creating another decision
+         * point.
+         */
+        for (int stateIndex = 0;
+            stateIndex < state.getPossibleNextStates().size();
+            ++stateIndex) {
+
+          final XmlSchemaStateMachineNode nextState =
+              state.getPossibleNextStates().get(stateIndex);
+
+          if (state.getNodeType().equals(XmlSchemaStateMachineNode.Type.ALL)
+              && !nextState
+                   .getNodeType()
+                   .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+              && !nextState
+                   .getNodeType()
+                   .equals(XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP)
+              && !nextState
+                   .getNodeType()
+                   .equals(XmlSchemaStateMachineNode.Type.ANY)) {
+
+            throw new IllegalStateException(
+                "While searching for "
+                + elemQName
+                + ", encountered an All group which contained a child of type "
+                + nextState.getNodeType()
+                + '.');
+          }
+
+          final XmlSchemaPathNode nextPath =
+              pathMgr.addChildNodeToPath(startNode, stateIndex);
+
+          final List<PathSegment> choicePaths =
+              find(nextPath, elemQName, currDepth + 1);
+
+          if (choicePaths != null) {
+            for (PathSegment choicePath : choicePaths) {
+              choicePath.prepend(startNode, stateIndex);
+            }
+
+            // nextPath was cloned by all path segments, so it can be recycled.
+            pathMgr.recyclePathNode(nextPath);
+
+            if (choices == null) {
+              choices = choicePaths;
+            } else {
+              choices.addAll(choicePaths);
+            }
+          }
+        }
+
+        break;
+      }
+    case ANY:
+      {
+        /* If the XmlSchemaAny namespace and processing rules
+         * apply, this element matches.  False otherwise.
+         */
+        if (traversedElements.size() < 2) {
+          throw new IllegalStateException(
+              "Reached a wildcard element while searching for "
+              + elemQName
+              + ", but we've only seen "
+              + traversedElements.size()
+              + " element(s)!");
+        }
+
+        final XmlSchemaAny any = state.getAny();
+
+        if (any.getNamespace() == null) {
+          choices = new ArrayList<PathSegment>(1);
+          choices.add( new PathSegment(startNode) );
+          break;
+        }
+
+        boolean needTargetNamespace = false;
+        boolean matches = false;
+        boolean matchOnNotTargetNamespace = false;
+
+        List<String> validNamespaces = null;
+
+        if ( any.getNamespace().equals("##any") ) {
+          // Any namespace is valid.  This matches.
+          matches = true;
+
+        } else if ( any.getNamespace().equals("##other") ) {
+          needTargetNamespace = true;
+          matchOnNotTargetNamespace = true;
+          validNamespaces = new ArrayList<String>(1);
+
+        } else {
+          final String[] namespaces = any.getNamespace().trim().split(" ");
+          validNamespaces = new ArrayList<String>(namespaces.length);
+          for (String namespace : namespaces) {
+            if (namespace.equals("##targetNamespace")) {
+              needTargetNamespace = true;
+
+            } else if (namespace.equals("##local")
+                && (elemQName.getNamespaceURI() == null)) {
+
+              matches = true;
+
+            } else {
+              validNamespaces.add(namespace);
+            }
+          }
+        }
+
+        if (!matches) {
+          /* At this time, it is not possible to determine the XmlSchemaAny's
+           * original target namespace without knowing the original element
+           * that owned it.  Likewise, unless the XmlSchemaAny's namespace is
+           * an actual namespace, or ##any, or ##local, there is no way to
+           * validate it.
+           *
+           * The work-around is to use the namespace of the owning element as
+           * the target namespace.
+           */
+          if (needTargetNamespace) {
+            final String targetNamespace =
+                elementStack.get(elementStack.size() - 1).getNamespaceURI();
+            validNamespaces.add(targetNamespace);
+          }
+
+          matches = validNamespaces.contains( elemQName.getNamespaceURI() );
+
+          if (matchOnNotTargetNamespace) {
+            matches = !matches;
+          }
+        }
+
+        if (matches) {
+          choices = new ArrayList<PathSegment>(1);
+          choices.add( new PathSegment(startNode) );
+        }
+      }
+      break;
+    default:
+      throw new IllegalStateException(
+          "Unrecognized node type "
+          + state.getNodeType()
+          + " when processing element "
+          + elemQName);
+    }
+
+    if ((choices == null) && (currDepth > 0)) {
+      pathMgr.recyclePathNode(startNode);
+    }
+    return choices;
+  }
+
+  /* Walks up the tree from the current element to the prior one.
+   * Confirms the provided QName matches the current one before traversing.
+   *
+   * If currElem is null, the current position must be a wildcard element.
+   */
+  private void walkUpTree(QName currElem) {
+    final XmlSchemaStateMachineNode state =
+        currentPath.getStateMachineNode();
+
+    switch (state.getNodeType()) {
+    case ANY:
+      break;
+    case ELEMENT:
+      if ( !state.getElement().getQName().equals(currElem) ) {
+        throw new IllegalStateException(
+            "We expected to walk upwards from element "
+            + currElem
+            + ", but our current element is "
+            + state.getElement().getQName());
+      }
+      break;
+    default:
+      throw new IllegalStateException(
+          "We expected to walk upwards from element "
+          + currElem
+          + ", but our current position is in a node of type "
+          + state.getNodeType());
+    }
+
+    XmlSchemaDocumentNode iter = currentPath.getDocumentNode();
+    XmlSchemaPathNode path = currentPath;
+
+    do {
+      if (iter.getIteration()
+            < iter.getStateMachineNode().getMaxOccurs()) {
+        break;
+      }
+
+      if (!isPositionFulfilled(path, null).equals(Fulfillment.COMPLETE)) {
+        break;
+      }
+
+      iter = iter.getParent();
+
+      if (iter == null) {
+        // We are exiting the root node.  Nothing to see here!
+        break;
+      }
+
+      final XmlSchemaPathNode nextPath =
+          pathMgr.addParentSiblingOrContentNodeToPath(
+              path,
+              XmlSchemaPathNode.Direction.PARENT);
+
+      path.setNextNode(-1, nextPath);
+      path = nextPath;
+
+    } while (!iter
+                .getStateMachineNode()
+                .getNodeType()
+                .equals(XmlSchemaStateMachineNode.Type.ELEMENT));
+
+    currentPath = path;
+  }
+
+  private void walkUpToElement(QName element) {
+    XmlSchemaDocumentNode iter = currentPath.getDocumentNode();
+
+    if (iter
+          .getStateMachineNode()
+          .getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+          && iter
+               .getStateMachineNode()
+               .getElement()
+               .getQName()
+               .equals(element)) {
+      // We are already at the element!
+      return;
+    }
+
+    do {
+
+      iter = iter.getParent();
+      if (iter != null) {
+        final XmlSchemaPathNode nextPath =
+            pathMgr.addParentSiblingOrContentNodeToPath(
+                currentPath,
+                XmlSchemaPathNode.Direction.PARENT);
+
+        currentPath.setNextNode(-1, nextPath);
+        currentPath = nextPath;
+      }
+    } while ((iter != null)
+        && !iter
+              .getStateMachineNode()
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.ELEMENT));
+
+    if (!currentPath
+           .getStateMachineNode()
+           .getNodeType()
+           .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+        || !currentPath
+              .getStateMachineNode()
+              .getElement()
+              .getQName()
+              .equals(element)) {
+      throw new IllegalStateException(
+          "Walked up tree and stopped at node "
+          + currentPath.getStateMachineNode()
+          + ", which does not represent element "
+          + element);
+    }
+  }
+
+  private void followPath(PathSegment path) {
+    switch (path.getEnd().getStateMachineNode().getNodeType()) {
+    case ELEMENT:
+    case ANY:
+      break;
+    default:
+      throw new IllegalStateException(
+          "Path does not end in an element or a wildcard element.");
+    }
+
+    // Join the start element with the new path.
+    XmlSchemaPathNode startNode = path.getStart();
+
+    if (path.getAfterStart() != null) {
+      startNode.setNextNode(
+          path.getAfterStartPathIndex(),
+          path.getAfterStart());
+    }
+
+    pathMgr.followPath(startNode);
+
+    currentPath = path.getEnd();
+  }
+
+  /* Perhaps this would be better implemented as a bunch of starting and
+   * ending tags on separate lines, properly indented, to generate an XML
+   * document similar to the one being parsed?  An idea to consider later.
+   */
+  private String getElementsTraversedAsString() {
+    final StringBuilder traversed = new StringBuilder("[");
+    if ((traversedElements != null) && !traversedElements.isEmpty()) {
+      for (int i = 0; i < traversedElements.size() - 1; ++i) {
+        traversed.append( traversedElements.get(i) ).append(" | ");
+      }
+      traversed.append( traversedElements.get(traversedElements.size() - 1) );
+    }
+    traversed.append(" ]");
+
+    return traversed.toString();
+  }
+
+  private void verifyCurrentPositionIsAtElement(String errMsgPrefix) {
+    if (!currentPath
+        .getStateMachineNode()
+        .getNodeType()
+        .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+
+        && !currentPath
+              .getStateMachineNode()
+              .getNodeType()
+              .equals(XmlSchemaStateMachineNode.Type.ANY)) {
+
+      throw new IllegalStateException(
+          errMsgPrefix
+          + " when our current position in the tree is a "
+          + currentPath.getStateMachineNode().getNodeType()
+          + '.');
+    }
+  }
+
+  private String getLeafNodeName(XmlSchemaStateMachineNode node) {
+    if (!node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+        && !node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ANY)) {
+
+      throw new IllegalStateException(
+          "State machine node needs to be an element or a wildcard element, "
+          + "not a "
+          + currentPath.getStateMachineNode().getNodeType()
+          + '.');
+    }
+
+    String elemName = "a wildcard element";
+    if (node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT) ) {
+      elemName =
+          node.getElement().getQName().toString();
+    }
+    return elemName;
+  }
+
+  private XmlSchemaStateMachineNode getStateMachineOfOwningElement() {
+    QName element = elementStack.get(elementStack.size() - 1);
+    XmlSchemaDocumentNode iter = currentPath.getDocumentNode();
+
+    if (iter
+          .getStateMachineNode()
+          .getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+          && iter
+               .getStateMachineNode()
+               .getElement()
+               .getQName()
+               .equals(element)) {
+      // We are already at the element!
+      return currentPath.getStateMachineNode();
+    }
+
+    do {
+      iter = iter.getParent();
+    } while ((iter != null)
+            && !iter
+                  .getStateMachineNode()
+                  .getNodeType()
+                  .equals(XmlSchemaStateMachineNode.Type.ELEMENT));
+
+    if (!iter
+          .getStateMachineNode()
+          .getNodeType()
+          .equals(XmlSchemaStateMachineNode.Type.ELEMENT)
+        || !iter
+              .getStateMachineNode()
+              .getElement()
+              .getQName()
+              .equals(element)) {
+      throw new IllegalStateException(
+          "Walked up tree and stopped at node "
+          + currentPath.getStateMachineNode()
+          + ", which does not represent element "
+          + element);
+    }
+
+    return iter.getStateMachineNode();
+  }
+
+  private void validateAttributes(Attributes attrs) {
+    if (currentPath
+          .getStateMachineNode()
+          .getNodeType()
+          .equals(XmlSchemaStateMachineNode.Type.ANY) ) {
+      // No validation is performed on ANY elements.
+      return;
+    }
+
+    try {
+      XmlSchemaElementValidator.validateAttributes(
+          currentPath.getStateMachineNode(),
+          attrs,
+          nsContext);
+    } catch (ValidationException ve) {
+      throw new IllegalStateException(
+          "Cannot validate attributes of "
+          + currentPath.getStateMachineNode().getElement().getQName()
+          + '.',
+          ve);
+    }
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathManager.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathManager.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathManager.java	(working copy)
@@ -0,0 +1,333 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+/**
+ * Factory for creating {@link XmlSchemaPathNode}s.  This allows
+ * for recycling and abstracts away the complexity of walking through
+ * an XML Schema.
+ */
+final class XmlSchemaPathManager<U, V> {
+
+  private ArrayList<XmlSchemaPathNode<U, V>> unusedPathNodes;
+  private ArrayList<XmlSchemaDocumentNode<U>> unusedDocNodes;
+
+  /**
+   * Constructs the document path node factory.
+   */
+  public XmlSchemaPathManager() {
+    unusedPathNodes = new ArrayList<XmlSchemaPathNode<U, V>>();
+    unusedDocNodes = new ArrayList<XmlSchemaDocumentNode<U>>();
+  }
+
+  XmlSchemaPathNode<U, V> createStartPathNode(
+      XmlSchemaPathNode.Direction direction,
+      XmlSchemaStateMachineNode state) {
+
+    return createPathNode(direction, null, state);
+  }
+
+  XmlSchemaPathNode<U, V> addParentSiblingOrContentNodeToPath(
+      XmlSchemaPathNode<U, V> startNode,
+      XmlSchemaPathNode.Direction direction) {
+
+    XmlSchemaDocumentNode position = startNode.getDocumentNode();
+
+    switch (direction) {
+    case PARENT:
+      if (position != null) {
+        position = position.getParent();
+      }
+    case SIBLING:
+    case CONTENT:
+      if (position == null) {
+        throw new IllegalStateException(
+            "When calling addParentSiblingOrContentNodeToPath(), the "
+            + "startNode's document node (and its parent) cannot be null.");
+      }
+      break;
+    default:
+      throw new IllegalStateException(
+          "This method cannot be called if following a child.  Use "
+          + "addChildNodeToPath(startNode, direction, stateIndex).");
+    }
+
+    XmlSchemaPathNode<U, V> node = null;
+    if ( !unusedPathNodes.isEmpty() ) {
+      node =
+          unusedPathNodes.remove(unusedPathNodes.size() - 1);
+      node.update(direction, startNode, position);
+    } else {
+      node = new XmlSchemaPathNode<U, V>(direction, startNode, position);
+    }
+
+    if ( direction.equals(XmlSchemaPathNode.Direction.SIBLING) ) {
+      node.setIteration(position.getIteration() + 1);
+    } else {
+      node.setIteration(position.getIteration());
+    }
+
+    return node;
+  }
+
+  XmlSchemaPathNode<U, V> addChildNodeToPath(
+      XmlSchemaPathNode<U, V> startNode,
+      int branchIndex) {
+
+    final XmlSchemaStateMachineNode stateMachine =
+        startNode.getStateMachineNode();
+
+    if (stateMachine.getPossibleNextStates() == null) {
+      throw new IllegalStateException(
+          "Cannot follow the branch index; no possible next states.");
+
+    } else if (stateMachine.getPossibleNextStates().size() <= branchIndex) {
+      throw new IllegalArgumentException(
+          "Cannot follow the branch index; branch "
+          + branchIndex
+          + " was requested when there are only "
+          + stateMachine.getPossibleNextStates().size()
+          + " branches to follow.");
+    }
+
+    final XmlSchemaPathNode<U, V> next =
+        createPathNode(
+            XmlSchemaPathNode.Direction.CHILD,
+            startNode,
+            stateMachine.getPossibleNextStates().get(branchIndex));
+
+    final XmlSchemaDocumentNode<U> docNode = startNode.getDocumentNode();
+
+    if ((startNode.getDocumentNode() != null)
+        && (docNode.getChildren(startNode.getIteration()) != null)
+        && docNode.getChildren().containsKey(branchIndex)) {
+
+      next.setDocumentNode(
+          docNode.getChildren(startNode.getIteration()).get(branchIndex) );
+      next.setIteration(next.getDocIteration() + 1);
+
+    } else {
+      next.setIteration(1);
+    }
+
+    return next;
+  }
+
+  /**
+   * Recyles the provided {@link XmlSchemaPathNode} and all of
+   * the nodes that follow it.  Unlinks from its previous node.
+   */
+  void recyclePathNode(XmlSchemaPathNode<U, V> toRecycle) {
+    if (toRecycle.getPrevious() != null) {
+      toRecycle.getPrevious().setNextNode(-1, null);
+      toRecycle.setPreviousNode(null);
+    }
+
+    if (toRecycle.getNext() != null) {
+      recyclePathNode(toRecycle.getNext());
+    }
+
+    unusedPathNodes.add(toRecycle);
+  }
+
+  XmlSchemaPathNode<U, V> clone(XmlSchemaPathNode<U, V> original) {
+    final XmlSchemaPathNode<U, V> clone =
+        createPathNode(
+            original.getDirection(),
+            original.getPrevious(),
+            original.getStateMachineNode());
+
+    clone.setIteration(original.getIteration());
+
+    if (original.getDocumentNode() != null) {
+      clone.setDocumentNode(original.getDocumentNode());
+    }
+
+    return clone;
+  }
+
+  /**
+   * Follows the path starting at <code>startNode</code>, creating
+   * {@link XmlSchemaDocumentNode}s and linking them along the way.
+   *
+   * @param startNode The node to start building the tree from.
+   */
+  void followPath(XmlSchemaPathNode<U, V> startNode) {
+    if (startNode.getDocumentNode() == null) {
+      if (!startNode
+             .getDirection()
+             .equals(XmlSchemaPathNode.Direction.CHILD)) {
+
+        throw new IllegalStateException(
+            "The startNode may only have a null XmlSchemaDocumentNode if it "
+            + "represents the root node, and likewise its only valid "
+            + "direction is CHILD, not "
+            + startNode.getDirection());
+      }
+
+      // startNode is the root node.
+      XmlSchemaDocumentNode rootDoc =
+          createDocumentNode(null, startNode.getStateMachineNode());
+      startNode.setDocumentNode(rootDoc);
+      rootDoc.addVisitor(startNode);
+    }
+
+    XmlSchemaPathNode<U, V> prev = startNode;
+    XmlSchemaPathNode<U, V> iter = prev.getNext();
+    while (iter != null) {
+      if (iter.getDocumentNode() == null) {
+        if ( !iter.getDirection().equals(XmlSchemaPathNode.Direction.CHILD) ) {
+          throw new IllegalStateException(
+              "XmlSchemaPathNode has a direction of "
+              + iter.getDirection()
+              + " but it does not have an XmlSchemaDocumentNode to represent"
+              + " its state machine ("
+              + iter.getStateMachineNode() + ").");
+        }
+
+        final XmlSchemaDocumentNode<U> newDocNode = 
+            createDocumentNode(
+                prev.getDocumentNode(),
+                iter.getStateMachineNode());
+
+        iter.setDocumentNode(newDocNode);
+
+        final Map<Integer, XmlSchemaDocumentNode<U>> siblings =
+            prev.getDocumentNode().getChildren();
+
+        if (prev.getIndexOfNextNodeState() < 0) {
+          throw new IllegalStateException(
+              "Creating a new document node for a node represented by "
+              + iter.getStateMachineNode()
+              + " but its previous state does not know how to reach me.");
+        }
+
+        siblings.put(prev.getIndexOfNextNodeState(), iter.getDocumentNode());
+      }
+
+      switch (iter.getDirection()) {
+      case CHILD:
+      case SIBLING:
+        iter.getDocumentNode().addVisitor(iter);
+        break;
+      default:
+      }
+
+      if (iter.getIteration() != iter.getDocIteration()) {
+        throw new IllegalStateException(
+            "The current path node (representing "
+            + iter.getStateMachineNode()
+            + ") has an iteration of "
+            + iter.getIteration()
+            + ", which does not match the document node iteration of "
+            + iter.getDocIteration()
+            + '.');
+      }
+
+      prev = iter;
+      iter = iter.getNext();
+    }
+  }
+
+  void unfollowPath(XmlSchemaPathNode<U, V> startNode) {
+    // Walk to the end and work backwards, recycling as we go.
+    XmlSchemaPathNode<U, V> iter = startNode;
+    XmlSchemaPathNode<U, V> prev = null;
+
+    while (iter != null) {
+      prev = iter;
+      iter = iter.getNext();
+    }
+
+    while (prev != startNode) {
+      iter = prev;
+      prev = iter.getPrevious();
+
+      if (iter.getDocumentNode() != null) {
+        iter.getDocumentNode().removeVisitor(iter);
+        if (iter.getDocIteration() == 0) {
+          recycleDocumentNode(iter.getDocumentNode());
+        }
+      }
+      recyclePathNode(iter);
+    }
+  }
+
+  void clear() {
+    unusedPathNodes.clear();
+    unusedDocNodes.clear();
+  }
+
+  private XmlSchemaPathNode<U, V> createPathNode(
+      XmlSchemaPathNode.Direction direction,
+      XmlSchemaPathNode<U, V> previous,
+      XmlSchemaStateMachineNode state) {
+    
+    if ( !unusedPathNodes.isEmpty() ) {
+      XmlSchemaPathNode<U, V> node =
+          unusedPathNodes.remove(unusedPathNodes.size() - 1);
+      node.update(direction, previous, state);
+      return node;
+    } else {
+      return new XmlSchemaPathNode(direction, previous, state);
+    }
+  }
+
+  private XmlSchemaDocumentNode<U> createDocumentNode(
+      XmlSchemaDocumentNode<U> parent,
+      XmlSchemaStateMachineNode state) {
+
+    if ( !unusedDocNodes.isEmpty() ) {
+      XmlSchemaDocumentNode<U> node =
+          unusedDocNodes.remove(unusedDocNodes.size() - 1);
+      node.set(parent, state);
+      return node;
+    } else {
+      return new XmlSchemaDocumentNode<U>(parent, state);
+    }
+  }
+
+  void recycleDocumentNode(XmlSchemaDocumentNode<U> node) {
+    if (node.getParent() != null) {
+      final Map<Integer, XmlSchemaDocumentNode> siblings =
+          node.getParent().getChildren();
+
+      for (Map.Entry<Integer, XmlSchemaDocumentNode> sibling :
+             siblings.entrySet()) {
+
+        if (sibling.getValue() == node) {
+          siblings.remove(sibling.getKey());
+          break;
+        }
+      }
+
+      if (node.getChildren() != null) {
+        for (Map.Entry<Integer, XmlSchemaDocumentNode<U>> child :
+                node.getChildren().entrySet()) {
+          recycleDocumentNode(child.getValue());
+        }
+      }
+    }
+
+    unusedDocNodes.add(node);
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathNode.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathNode.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaPathNode.java	(working copy)
@@ -0,0 +1,262 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+/**
+ * This represents a node in the path when walking an XML or Avro document.
+ * As {@link XmlSchemaPathFinder} walks through an XML document, it builds
+ * <code>XmlSchemaPathNode</code>s  representing the path walked, and
+ * {@link XmlSchemaDocumentNode}s representing where the XML document's
+ * elements fall in the XML Schema's sequences, choices, and all groups.
+ */
+final class XmlSchemaPathNode<U, V> {
+
+  private Direction direction;
+  private XmlSchemaDocumentNode<U> documentNode;
+  private XmlSchemaStateMachineNode stateMachineNode;
+  private int nextNodeStateIndex;
+  private int iterationNum;
+  private V userDefinedContent;
+
+  private XmlSchemaPathNode<U, V> prevNode;
+  private XmlSchemaPathNode<U, V> nextNode;
+
+  enum Direction {
+    PARENT(2),
+    CHILD(0),
+    CONTENT(3),
+    SIBLING(1);
+
+    // CHILD < SIBLING < PARENT < CONTENT when comparing possible paths.
+    Direction (int rank) {
+      this.rank = rank;
+    }
+
+    int getRank() {
+      return rank;
+    }
+
+    final int rank;
+  }
+
+  XmlSchemaPathNode(
+      Direction dir,
+      XmlSchemaPathNode previous,
+      XmlSchemaDocumentNode<U> node) {
+
+    update(dir, previous, node);
+  }
+
+  XmlSchemaPathNode(
+      Direction dir,
+      XmlSchemaPathNode previous,
+      XmlSchemaStateMachineNode stateMachine) {
+
+    update(dir, previous, stateMachine);
+  }
+
+  XmlSchemaDocumentNode<U> getDocumentNode() {
+    return documentNode;
+  }
+
+  XmlSchemaStateMachineNode getStateMachineNode() {
+    return stateMachineNode;
+  }
+
+  Direction getDirection() {
+    return direction;
+  }
+
+  int getIndexOfNextNodeState() {
+    return nextNodeStateIndex;
+  }
+
+  int getIteration() {
+    return iterationNum;
+  }
+
+  long getMinOccurs() {
+    return stateMachineNode.getMinOccurs();
+  }
+
+  long getMaxOccurs() {
+    return stateMachineNode.getMaxOccurs();
+  }
+
+  int getDocIteration() {
+    if (documentNode == null) {
+      return 0;
+    } else {
+      return documentNode.getIteration();
+    }
+  }
+
+  int getDocSequencePosition() {
+    if (documentNode == null) {
+      return 0;
+    } else {
+      return documentNode.getSequencePosition();
+    }
+  }
+
+  XmlSchemaPathNode getPrevious() {
+    return prevNode;
+  }
+
+  XmlSchemaPathNode getNext() {
+    return nextNode;
+  }
+
+  void setIteration(int newIteration) {
+    if (newIteration < 1) {
+      throw new IllegalArgumentException(
+          "The new iteration must be at least one, not "
+          + newIteration
+          + '.');
+
+    } else if (stateMachineNode.getMaxOccurs() < newIteration) {
+      throw new IllegalStateException(
+          "The new iteration for "
+          + stateMachineNode
+          + " of "
+          + newIteration
+          + " is greater than the maximum of "
+          + stateMachineNode.getMaxOccurs()
+          + '.');
+    }
+    iterationNum = newIteration;
+  }
+
+  void setDocumentNode(XmlSchemaDocumentNode<U> docNode) {
+    if (docNode.getStateMachineNode() != stateMachineNode) {
+      throw new IllegalArgumentException(
+          "The document node's state machine ("
+          + docNode.getStateMachineNode()
+          + ") must use the same state machine node as this path node ("
+          + stateMachineNode
+          + ").");
+    }
+    documentNode = docNode;
+  }
+
+  void setNextNode(int nextNodeIndex, XmlSchemaPathNode newNext) {
+
+    if ((nextNodeIndex == -1)
+        && ((newNext == null)
+            || newNext.getDirection().equals(Direction.CONTENT)
+            || newNext.getDirection().equals(Direction.PARENT)
+            || newNext.getDirection().equals(Direction.SIBLING))) {
+
+      /* If this is either a content node or a sibling node, no validation is
+       * needed because we didn't change our position in the document tree.
+       *
+       * If this is a parent node, no validation is possible because
+       * we do not track the prior state in the state machine.
+       *
+       * We can also reset lower nodes in the path as necessary.
+       */
+
+    } else if ((nextNodeIndex < 0)
+                || (nextNodeIndex
+                    >= stateMachineNode
+                         .getPossibleNextStates().size())) {
+      throw new IllegalArgumentException(
+          "The node index ("
+          + nextNodeIndex
+          + ") is not within the range of "
+          + documentNode.getStateMachineNode().getPossibleNextStates().size()
+          + " possible next states.");
+
+    } else if (newNext == null) {
+      throw new IllegalArgumentException("The next node must be defined.");
+
+    } else if ( !stateMachineNode
+                   .getPossibleNextStates()
+                   .get(nextNodeIndex)
+                   .equals( newNext.getStateMachineNode() ) ) {
+
+      throw new IllegalArgumentException(
+          "The next possible state at index "
+          + nextNodeIndex
+          + " does not match the state defined in the newNext.");
+    }
+
+    nextNodeStateIndex = nextNodeIndex;
+    nextNode = newNext;
+  }
+
+  /**
+   * Changes the previous node this one was pointing to.
+   * This is useful when cloning prior nodes in the chain.
+   *
+   * @param newPrevious The new previous node.
+   * @return The old previous node.
+   */
+  XmlSchemaPathNode setPreviousNode(XmlSchemaPathNode newPrevious) {
+    final XmlSchemaPathNode<U, V> oldPrevious = prevNode;
+    prevNode = newPrevious;
+    return oldPrevious;
+  }
+
+  /**
+   * Use this method when changing the the {@link XmlSchemaStateMachineNode}
+   * this <code>DocumentPathNode</code> refers to.  The next node in the
+   * path is returned, as it will be discarded internally.
+   *
+   * @param newPrevious The new previous <code>DocumentPathNode</code> this
+   *                    node is traversed from.
+   *
+   * @param newNode The new {@link XmlSchemaStateMachineNode}
+   *                this node refers to.
+   *
+   * @return The next node in the path that this node referred to, as it will
+   *         be discarded internally. 
+   */
+  void update(
+      Direction newDirection,
+      XmlSchemaPathNode newPrevious,
+      XmlSchemaDocumentNode<U> newNode) {
+
+    update(newDirection, newPrevious, newNode.getStateMachineNode());
+    documentNode = newNode;
+  }
+
+  void update(
+      Direction newDirection,
+      XmlSchemaPathNode newPrevious,
+      XmlSchemaStateMachineNode newStateMachineNode) {
+
+    direction = newDirection;
+    documentNode = null;
+    stateMachineNode = newStateMachineNode;
+    nextNodeStateIndex = -1;
+    iterationNum = 0;
+    prevNode = newPrevious;
+    nextNode = null;
+    userDefinedContent = null;
+  }
+
+  V getUserDefinedContent() {
+    return userDefinedContent;
+  }
+
+  void setUserDefinedContent(V content) {
+    userDefinedContent = content;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaRestriction.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaRestriction.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaRestriction.java	(working copy)
@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import org.apache.ws.commons.schema.XmlSchemaEnumerationFacet;
+import org.apache.ws.commons.schema.XmlSchemaFacet;
+import org.apache.ws.commons.schema.XmlSchemaFractionDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxExclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinExclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaPatternFacet;
+import org.apache.ws.commons.schema.XmlSchemaTotalDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaWhiteSpaceFacet;
+
+/**
+ * This represents an {@link XmlSchemaFacet}.  It uses an enum to more easily
+ * work with different facets, and its {@link #equals(Object)} and
+ * {@link #hashCode()} reflect that only enumerations and patterns can have
+ * multiple facets.
+ */
+class XmlSchemaRestriction {
+
+  private Type type;
+  private Object value;
+  private boolean isFixed;
+
+  enum Type {
+    ENUMERATION,
+    EXCLUSIVE_MIN,
+    EXCLUSIVE_MAX,
+    INCLUSIVE_MIN,
+    INCLUSIVE_MAX,
+    PATTERN,
+    WHITESPACE,
+    LENGTH,
+    LENGTH_MAX,
+    LENGTH_MIN,
+    DIGITS_FRACTION,
+    DIGITS_TOTAL;
+  }
+
+  XmlSchemaRestriction(XmlSchemaFacet facet) {
+    if (facet instanceof XmlSchemaEnumerationFacet) {
+      type = Type.ENUMERATION;
+    } else if (facet instanceof XmlSchemaMaxExclusiveFacet) {
+      type = Type.EXCLUSIVE_MAX;
+    } else if (facet instanceof XmlSchemaMaxInclusiveFacet) {
+      type = Type.INCLUSIVE_MAX;
+    } else if (facet instanceof XmlSchemaMinExclusiveFacet) {
+      type = Type.EXCLUSIVE_MIN;
+    } else if (facet instanceof XmlSchemaMinInclusiveFacet) {
+      type = Type.INCLUSIVE_MIN;
+    } else if (facet instanceof XmlSchemaFractionDigitsFacet) {
+      type = Type.DIGITS_FRACTION;
+    } else if (facet instanceof XmlSchemaTotalDigitsFacet) {
+      type = Type.DIGITS_TOTAL;
+    } else if (facet instanceof XmlSchemaPatternFacet) {
+      type = Type.PATTERN;
+    } else if (facet instanceof XmlSchemaWhiteSpaceFacet) {
+      type = Type.WHITESPACE;
+    } else if (facet instanceof XmlSchemaLengthFacet) {
+      type = Type.LENGTH;
+    } else if (facet instanceof XmlSchemaMinLengthFacet) {
+      type = Type.LENGTH_MIN;
+    } else if (facet instanceof XmlSchemaMaxLengthFacet) {
+      type = Type.LENGTH_MAX;
+    } else {
+      throw new IllegalArgumentException(
+          "Unrecognized facet " + facet.getClass().getName());
+    }
+
+    value = facet.getValue();
+          isFixed = facet.isFixed();
+  }
+
+  XmlSchemaRestriction(Type type) {
+    this.type = type;
+    this.value = null;
+    this.isFixed = false;
+  }
+
+  XmlSchemaRestriction(Type type, Object value, boolean isFixed) {
+    this.type = type;
+    this.value = value;
+    this.isFixed = isFixed;
+  }
+
+  Type getType() {
+    return type;
+  }
+
+  Object getValue() {
+    return value;
+  }
+
+  boolean isFixed() {
+    return isFixed;
+  }
+
+  void setValue(Object value) {
+    this.value = value;
+  }
+
+  void setFixed(boolean isFixed) {
+    this.isFixed = isFixed;
+  }
+
+  /**
+   * Generates a hash code based on the contents.
+   *
+   * If the type is an enumeration, then the isFixed and value
+   * elements are used in calculating the hash code.  All of
+   * the other Restrictions are considered to be the same.
+   *
+   * @see java.lang.Object#hashCode()
+   */
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((type == null) ? 0 : type.hashCode());
+
+    if ((type != null)
+        && ((type == Type.ENUMERATION) || (type == Type.PATTERN))) {
+
+        result = prime * result + (isFixed ? 1231 : 1237);
+        result = prime * result + ((value == null) ? 0 : value.hashCode());
+    }
+    return result;
+  }
+
+  /**
+   * Determines equality.
+   *
+   * If the type is an enumeration, then the isFixed and value
+   * elements are used determining equality.  All of the other
+   * Restrictions are considered to be equal to each other.
+   *
+   * @see java.lang.Object#equals(java.lang.Object)
+   */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (obj == null)
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    XmlSchemaRestriction other = (XmlSchemaRestriction) obj;
+    if (type != other.type)
+      return false;
+
+    if ((type != null)
+        && ((type == Type.ENUMERATION) || (type == Type.PATTERN))) {
+
+      if (isFixed != other.isFixed)
+        return false;
+      if (value == null) {
+        if (other.value != null)
+          return false;
+      } else if (!value.equals(other.value))
+        return false;
+    }
+    return true;
+  }
+
+  @Override
+  public String toString() {
+    return type.name() + ": " + value + " (Fixed: " + isFixed + ")";
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaScope.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaScope.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaScope.java	(working copy)
@@ -0,0 +1,1133 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaAnyAttribute;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaAttributeGroup;
+import org.apache.ws.commons.schema.XmlSchemaAttributeGroupMember;
+import org.apache.ws.commons.schema.XmlSchemaAttributeGroupRef;
+import org.apache.ws.commons.schema.XmlSchemaAttributeOrGroupRef;
+import org.apache.ws.commons.schema.XmlSchemaComplexContent;
+import org.apache.ws.commons.schema.XmlSchemaComplexContentExtension;
+import org.apache.ws.commons.schema.XmlSchemaComplexContentRestriction;
+import org.apache.ws.commons.schema.XmlSchemaComplexType;
+import org.apache.ws.commons.schema.XmlSchemaContent;
+import org.apache.ws.commons.schema.XmlSchemaFacet;
+import org.apache.ws.commons.schema.XmlSchemaFractionDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaParticle;
+import org.apache.ws.commons.schema.XmlSchemaPatternFacet;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
+import org.apache.ws.commons.schema.XmlSchemaSimpleContentExtension;
+import org.apache.ws.commons.schema.XmlSchemaSimpleContentRestriction;
+import org.apache.ws.commons.schema.XmlSchemaSimpleType;
+import org.apache.ws.commons.schema.XmlSchemaSimpleTypeContent;
+import org.apache.ws.commons.schema.XmlSchemaSimpleTypeList;
+import org.apache.ws.commons.schema.XmlSchemaSimpleTypeRestriction;
+import org.apache.ws.commons.schema.XmlSchemaSimpleTypeUnion;
+import org.apache.ws.commons.schema.XmlSchemaType;
+import org.apache.ws.commons.schema.XmlSchemaUse;
+import org.apache.ws.commons.schema.XmlSchemaWhiteSpaceFacet;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.apache.ws.commons.schema.utils.XmlSchemaNamed;
+
+/**
+ * The scope represents the set of types, attributes, and
+ * child groups & elements that the current type represents.
+ */
+final class XmlSchemaScope {
+
+  private static final Map<QName, List<XmlSchemaFacet>> FACETS_OF_SCHEMA_TYPES =
+      new HashMap<QName, List<XmlSchemaFacet>>();
+
+  private Map<String, XmlSchema> schemasByNamespace;
+  private Map<QName, XmlSchemaScope> scopeCache;
+
+  private XmlSchemaTypeInfo typeInfo;
+  private HashMap<QName, XmlSchemaAttribute> attributes;
+  private XmlSchemaParticle child;
+  private XmlSchemaAnyAttribute anyAttr;
+  private Set<QName> userRecognizedTypes;
+
+  static {
+    /* Until https://issues.apache.org/jira/browse/XMLSCHEMA-33
+     * makes it to the next release of Apache XML Schema (2.1.1).
+     */
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_DURATION,
+        Arrays.asList( new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_DATETIME,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_TIME,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_DATE,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_YEARMONTH,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_YEAR,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_MONTHDAY,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_DAY,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_MONTH,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_MONTH,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_BOOLEAN,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_BASE64,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_HEXBIN,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_FLOAT,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_DOUBLE,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_ANYURI,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_QNAME,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_DECIMAL,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", true) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_INTEGER,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaFractionDigitsFacet(new Integer(0), true),
+            new XmlSchemaPatternFacet("[\\-+]?[0-9]+", false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NONPOSITIVEINTEGER,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMaxInclusiveFacet(new Integer(0), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NEGATIVEINTEGER,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMaxInclusiveFacet(new Integer(-1), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_LONG,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMinInclusiveFacet(
+                new Long(-9223372036854775808L),
+                false),
+            new XmlSchemaMaxInclusiveFacet(
+                new Long(9223372036854775807L),
+                false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_INT,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMinInclusiveFacet(
+                new Integer(-2147483648),
+                false),
+            new XmlSchemaMaxInclusiveFacet(
+                new Integer(2147483647),
+                false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_SHORT,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMinInclusiveFacet(new Short((short) -32768), false),
+            new XmlSchemaMaxInclusiveFacet(new Short((short) 32767), false)}));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_BYTE,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMinInclusiveFacet(new Byte((byte) -128), false),
+            new XmlSchemaMaxInclusiveFacet(new Byte((byte) 127), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NONNEGATIVEINTEGER,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMinInclusiveFacet(new Integer(0), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_POSITIVEINTEGER,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMinInclusiveFacet(new Integer(1), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_UNSIGNEDLONG,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMaxInclusiveFacet(
+                new BigInteger("18446744073709551615"),
+                false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_UNSIGNEDINT,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMaxInclusiveFacet(new Long(4294967295L), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_UNSIGNEDSHORT,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMaxInclusiveFacet(new Integer(65535), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_UNSIGNEDBYTE,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaMaxInclusiveFacet(new Short((short) 255), false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_STRING,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("preserve", false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NORMALIZEDSTRING,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("replace", false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_TOKEN,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaWhiteSpaceFacet("collapse", false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_LANGUAGE,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaPatternFacet(
+                "[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*",
+                false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NMTOKEN,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaPatternFacet("\\c+", false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NAME,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaPatternFacet("\\i\\c*", false) }));
+
+    FACETS_OF_SCHEMA_TYPES.put(
+        Constants.XSD_NCNAME,
+        Arrays.asList(new XmlSchemaFacet[] {
+            new XmlSchemaPatternFacet("[\\i-[:]][\\c-[:]]*", false) }));
+  }
+
+  /**
+   * Initialization of members to be filled in during the walk.
+   */
+  private XmlSchemaScope() {
+    typeInfo = null;
+    attributes = null;
+    child = null;
+    anyAttr = null;
+  }
+
+  private XmlSchemaScope(XmlSchemaScope child, XmlSchemaType type) {
+    this();
+    this.schemasByNamespace = child.schemasByNamespace;
+    this.scopeCache = child.scopeCache;
+    this.userRecognizedTypes = child.userRecognizedTypes;
+
+    walk(type);
+  }
+
+  /**
+   * Initializes a new {@link XmlSchemaScope} with a base
+   * {@link XmlSchemaElement}.  The element type and
+   * attributes will be traversed, and attribute lists
+   * and element children will be retrieved.
+   *
+   * @param element The base element to build the scope from.
+   * @param substitutions The master list of substitution groups to pull from.
+   * @param userRecognizedTypes The set of types recognized by the caller.
+   */
+  XmlSchemaScope(
+      XmlSchemaType type,
+      Map<String, XmlSchema> xmlSchemasByNamespace,
+      Map<QName, XmlSchemaScope> scopeCache,
+      Set<QName> userRecognizedTypes) {
+
+    this();
+
+    schemasByNamespace = xmlSchemasByNamespace;
+    this.scopeCache = scopeCache;
+    this.userRecognizedTypes = userRecognizedTypes;
+
+    walk(type);
+  }
+
+  XmlSchemaTypeInfo getTypeInfo() {
+    return typeInfo;
+  }
+
+  Collection<XmlSchemaAttribute> getAttributesInScope() {
+    if (attributes == null) {
+      return null;
+    }
+    return attributes.values();
+  }
+
+  XmlSchemaParticle getParticle() {
+    return child;
+  }
+
+  XmlSchemaAnyAttribute getAnyAttribute() {
+    return anyAttr;
+  }
+
+  private void walk(XmlSchemaType type) {
+    if (type instanceof XmlSchemaSimpleType) {
+      walk((XmlSchemaSimpleType) type);
+    } else if (type instanceof XmlSchemaComplexType) {
+      walk((XmlSchemaComplexType) type);
+    } else {
+      throw new IllegalArgumentException(
+          "Unrecognized XmlSchemaType of type "
+          + type.getClass().getName());
+    }
+  }
+
+  private void walk(XmlSchemaSimpleType simpleType) {
+    XmlSchemaSimpleTypeContent content = simpleType.getContent();
+
+    if (content == null) {
+      /* Only anyType contains no content. We
+       * reached the root of the type hierarchy.
+       */
+      typeInfo =
+          new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.ANYTYPE);
+
+    } else if (content instanceof XmlSchemaSimpleTypeList) {
+        XmlSchemaSimpleTypeList list = (XmlSchemaSimpleTypeList) content;
+        XmlSchemaSimpleType listType = list.getItemType();
+        if (listType == null) {
+            XmlSchema schema =
+                schemasByNamespace.get(
+                    list.getItemTypeName().getNamespaceURI());
+
+            listType =
+                (XmlSchemaSimpleType) schema.getTypeByName(
+                    list.getItemTypeName());
+        }
+        if (listType == null) {
+            throw new IllegalArgumentException(
+                "Unrecognized schema type for list "
+                + getName(simpleType, "{Anonymous List Type}"));
+        }
+
+        XmlSchemaScope parentScope = getScope(listType);
+
+        switch ( parentScope.getTypeInfo().getType() ) {
+        case UNION:
+        case ATOMIC:
+          break;
+        default:
+          throw new IllegalStateException(
+              "Attempted to create a list from a "
+              + parentScope.getTypeInfo().getType()
+              + " type.");
+        }
+
+        typeInfo = new XmlSchemaTypeInfo( parentScope.getTypeInfo() );
+
+    } else if (content instanceof XmlSchemaSimpleTypeUnion) {
+        XmlSchemaSimpleTypeUnion union = (XmlSchemaSimpleTypeUnion) content;
+        QName[] namedBaseTypes = union.getMemberTypesQNames();
+        List<XmlSchemaSimpleType> baseTypes = union.getBaseTypes();
+
+        if (namedBaseTypes != null) {
+          if (baseTypes == null) {
+            baseTypes =
+                new ArrayList<XmlSchemaSimpleType>(namedBaseTypes.length);
+          }
+
+          for (QName namedBaseType : namedBaseTypes) {
+            XmlSchema schema =
+                schemasByNamespace.get( namedBaseType.getNamespaceURI() );
+            XmlSchemaSimpleType baseType =
+                (XmlSchemaSimpleType) schema.getTypeByName(namedBaseType);
+            if (baseType != null) {
+                baseTypes.add(baseType);
+            }
+          }
+        }
+
+        /* baseTypes cannot be null at this point;
+         * there must be a union of types.
+         */
+        if ((baseTypes == null) || baseTypes.isEmpty()) {
+          throw new IllegalArgumentException(
+              "Unrecognized base types for union "
+              + getName(simpleType, "{Anonymous Union Type}"));
+        }
+
+        List<XmlSchemaTypeInfo> childTypes =
+            new ArrayList<XmlSchemaTypeInfo>( baseTypes.size() );
+
+        for (XmlSchemaSimpleType baseType : baseTypes) {
+          XmlSchemaScope parentScope = getScope(baseType);
+          if (parentScope
+                .getTypeInfo()
+                .getType()
+                .equals(XmlSchemaTypeInfo.Type.UNION) ) {
+            childTypes.addAll( parentScope.getTypeInfo().getChildTypes() );
+          } else {
+            childTypes.add( parentScope.getTypeInfo() );
+          }
+        }
+
+        typeInfo = new XmlSchemaTypeInfo(childTypes);
+
+    } else if (content instanceof XmlSchemaSimpleTypeRestriction) {
+        final XmlSchemaSimpleTypeRestriction restr =
+            (XmlSchemaSimpleTypeRestriction) content;
+
+        List<XmlSchemaFacet> facets = restr.getFacets();
+        if ((facets == null) || facets.isEmpty()) {
+          // Needed until XMLSCHEMA-33 becomes available.
+          facets = FACETS_OF_SCHEMA_TYPES.get( simpleType.getQName() );
+        }
+
+        XmlSchemaTypeInfo parentTypeInfo = null;
+
+        if ( XmlSchemaBaseSimpleType.isBaseSimpleType(simpleType.getQName()) ) {
+          // If this is a base simple type, use it!
+          typeInfo =
+              new XmlSchemaTypeInfo(
+                  XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(
+                      simpleType.getQName()),
+                  mergeFacets(null, facets));
+
+        } else {
+          XmlSchemaSimpleType baseType = restr.getBaseType();
+          if (baseType == null) {
+              XmlSchema schema =
+                  schemasByNamespace.get(
+                      restr.getBaseTypeName().getNamespaceURI());
+              baseType =
+                  (XmlSchemaSimpleType) schema.getTypeByName(
+                      restr.getBaseTypeName());
+          }
+
+          if (baseType != null) {
+            final XmlSchemaScope parentScope = getScope(baseType);
+
+            /* We need to track the original type as well as the set of facets
+             * imposed on that type.  Once the recursion ends, and we make it
+             * all the way back to the first scope, the user of this type info
+             * will know the derived type and all of its imposed facets.
+             *
+             * Unions can restrict unions, lists can restrict lists, and atomic
+             * types restrict other atomic types.  We need to follow all of
+             * these too.
+             */
+            parentTypeInfo = parentScope.getTypeInfo();
+
+            HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+              mergedFacets = mergeFacets(parentTypeInfo.getFacets(), facets);
+
+            typeInfo = restrictTypeInfo(parentTypeInfo, mergedFacets);
+
+          } else {
+              throw new IllegalArgumentException(
+                  "Unrecognized base type for "
+                  + getName(simpleType, "{Anonymous Simple Type}"));
+          }
+        }
+
+        typeInfo.setUserRecognizedType(
+            getUserRecognizedType(simpleType.getQName(), parentTypeInfo));
+
+    } else {
+        throw new IllegalArgumentException(
+            "XmlSchemaSimpleType "
+            + getName(simpleType, "{Anonymous Simple Type}")
+            + "contains unrecognized XmlSchemaSimpleTypeContent "
+            + content.getClass().getName());
+    }
+  }
+
+  private void walk(XmlSchemaComplexType complexType) {
+    XmlSchemaContent complexContent =
+        (complexType.getContentModel() != null)
+        ? complexType.getContentModel().getContent()
+        : null;
+
+    /* Process the complex type extensions and restrictions.
+     * If there aren't any, the content is be defined by the particle.
+     */
+    if (complexContent != null) {
+      boolean isMixed = false;
+      if (complexType.isMixed()) {
+        isMixed = complexType.isMixed();
+      } else if (complexType.getContentModel()
+                   instanceof XmlSchemaComplexContent) {
+        isMixed =
+            ((XmlSchemaComplexContent) complexType.getContentModel())
+            .isMixed();
+      }
+
+      walk(isMixed, complexContent);
+
+    } else {
+      child = complexType.getParticle();
+      attributes = createAttributeMap( complexType.getAttributes() );
+      anyAttr = complexType.getAnyAttribute();
+      typeInfo = new XmlSchemaTypeInfo( complexType.isMixed() );
+    }
+  }
+
+  private void walk(boolean isMixed, XmlSchemaContent content) {
+    if (content instanceof XmlSchemaComplexContentExtension) {
+      XmlSchemaComplexContentExtension ext =
+          (XmlSchemaComplexContentExtension) content;
+
+      XmlSchema schema =
+          schemasByNamespace.get( ext.getBaseTypeName().getNamespaceURI() );
+      XmlSchemaType baseType = schema.getTypeByName( ext.getBaseTypeName() );
+
+      XmlSchemaParticle baseParticle = null;
+      XmlSchemaAnyAttribute baseAnyAttr = null;
+      XmlSchemaScope parentScope = null;
+
+      if (baseType != null) {
+        /* Complex content extensions add attributes and elements
+         * in addition to what was retrieved from the parent. Since
+         * there will be no collisions, it is safe to perform a
+         * straight add.
+         */
+        parentScope = getScope(baseType);
+        final Collection<XmlSchemaAttribute> parentAttrs =
+            parentScope.getAttributesInScope();
+
+        attributes = createAttributeMap( ext.getAttributes() );
+
+        if (attributes == null) {
+          attributes = createAttributeMap(parentAttrs);
+        } else if (parentAttrs != null) {
+          for (XmlSchemaAttribute parentAttr : parentAttrs) {
+            attributes.put(parentAttr.getQName(), parentAttr);
+          }
+        }
+
+        baseParticle = parentScope.getParticle();
+        baseAnyAttr = parentScope.anyAttr;
+      }
+
+      /* An extension of a complex type is equivalent to creating a sequence of
+       * two particles: the parent particle followed by the child particle.
+       */
+      if (ext.getParticle() == null) {
+        child = baseParticle;
+      } else if (baseParticle == null) {
+        child = ext.getParticle();
+      } else {
+        XmlSchemaSequence seq = new XmlSchemaSequence();
+        seq.getItems().add((XmlSchemaSequenceMember) baseParticle);
+        seq.getItems().add((XmlSchemaSequenceMember) ext.getParticle());
+        child = seq;
+      }
+
+      /* An extension of an anyAttribute means the child defines the
+       * processContents field, while a union of all namespaces between
+       * the parent and child is taken.
+       */
+      if (baseAnyAttr == null) {
+        anyAttr = ext.getAnyAttribute();
+      } else if (ext.getAnyAttribute() == null) {
+        anyAttr = baseAnyAttr;
+      } else {
+        String[] baseNamespaces = baseAnyAttr.getNamespace().split(" ");
+        String[] childNamespaces =
+            ext.getAnyAttribute().getNamespace().split(" ");
+
+        HashSet<String> namespaces = new HashSet<String>();
+        for (String baseNs : baseNamespaces) {
+          if (!baseNs.isEmpty()) {
+            namespaces.add(baseNs);
+          }
+        }
+        for (String childNs : childNamespaces) {
+          if (!childNs.isEmpty()) {
+            namespaces.add(childNs);
+          }
+        }
+
+        StringBuilder nsAsString = new StringBuilder();
+        for (String namespace : namespaces) {
+          nsAsString.append(namespace).append(" ");
+        }
+
+        anyAttr = new XmlSchemaAnyAttribute();
+        anyAttr.setNamespace( nsAsString.toString() );
+        anyAttr.setProcessContent( ext.getAnyAttribute().getProcessContent() );
+        anyAttr.setAnnotation( ext.getAnyAttribute().getAnnotation() );
+        anyAttr.setId( ext.getAnyAttribute().getId() );
+        anyAttr.setLineNumber( ext.getAnyAttribute().getLineNumber() );
+        anyAttr.setLinePosition( ext.getAnyAttribute().getLinePosition() );
+        anyAttr.setMetaInfoMap( ext.getAnyAttribute().getMetaInfoMap() );
+        anyAttr.setSourceURI( ext.getAnyAttribute().getSourceURI() );
+        anyAttr.setUnhandledAttributes( ext.getUnhandledAttributes() );
+      }
+
+      final XmlSchemaTypeInfo parentTypeInfo =
+          (parentScope == null)
+          ? null
+          : parentScope.getTypeInfo();
+
+      if ((parentTypeInfo != null)
+          && !parentTypeInfo
+                .getType()
+                .equals(XmlSchemaTypeInfo.Type.COMPLEX)) {
+        typeInfo = parentScope.getTypeInfo();
+      } else {
+        typeInfo = new XmlSchemaTypeInfo(isMixed);
+      }
+
+    } else if (content instanceof XmlSchemaComplexContentRestriction) {
+      final XmlSchemaComplexContentRestriction rstr =
+          (XmlSchemaComplexContentRestriction) content;
+
+      final XmlSchema schema =
+          schemasByNamespace.get( rstr.getBaseTypeName().getNamespaceURI() );
+
+      final XmlSchemaType baseType =
+          schema.getTypeByName( rstr.getBaseTypeName() );
+
+      XmlSchemaScope parentScope = null;
+      if (baseType != null) {
+        parentScope = getScope(baseType);
+
+        attributes =
+            mergeAttributes(
+                parentScope.attributes,
+                createAttributeMap( rstr.getAttributes() ));
+
+        child = parentScope.getParticle();
+      }
+
+      /* There is no inheritance when restricting particles.  If the schema
+       * writer wishes to include elements in the parent type, (s)he must
+       * redefine them in the child.
+       */
+      if (rstr.getParticle() != null) {
+        child = rstr.getParticle();
+      }
+
+      /* There is no inheritance when restricting attribute wildcards.
+       * The only requirement is that the namespaces of the restricted
+       * type is a subset of the namespaces of the base type.  This
+       * will not be checked here (all schemas are assumed correct).
+       */
+      anyAttr = rstr.getAnyAttribute();
+
+      final XmlSchemaTypeInfo parentTypeInfo =
+          (parentScope == null)
+          ? null
+          : parentScope.getTypeInfo();
+
+      if ((parentTypeInfo != null)
+          && !parentTypeInfo
+               .getType()
+               .equals(XmlSchemaTypeInfo.Type.COMPLEX)) {
+        typeInfo = parentTypeInfo;
+      } else {
+        typeInfo = new XmlSchemaTypeInfo(isMixed);
+      }
+
+    } else if (content instanceof XmlSchemaSimpleContentExtension) {
+      XmlSchemaSimpleContentExtension ext =
+          (XmlSchemaSimpleContentExtension) content;
+      attributes = createAttributeMap( ext.getAttributes() );
+
+      XmlSchema schema =
+          schemasByNamespace.get( ext.getBaseTypeName().getNamespaceURI() );
+      XmlSchemaType baseType = schema.getTypeByName( ext.getBaseTypeName() );
+
+      if (baseType != null) {
+        final XmlSchemaScope parentScope = getScope(baseType);
+        typeInfo = parentScope.getTypeInfo();
+
+        final Collection<XmlSchemaAttribute> parentAttrs =
+            parentScope.getAttributesInScope();
+
+        if (attributes == null) {
+          attributes = createAttributeMap(parentAttrs);
+        } else if (parentAttrs != null) {
+          for (XmlSchemaAttribute parentAttr : parentAttrs) {
+            attributes.put(parentAttr.getQName(), parentAttr);
+          }
+        }
+      }
+
+      anyAttr = ext.getAnyAttribute();
+
+    } else if (content instanceof XmlSchemaSimpleContentRestriction) {
+      XmlSchemaSimpleContentRestriction rstr =
+          (XmlSchemaSimpleContentRestriction) content;
+      attributes = createAttributeMap( rstr.getAttributes() );
+
+      XmlSchemaType baseType = null;
+      if (rstr.getBaseType() != null) {
+        baseType = rstr.getBaseType();
+      } else {
+        XmlSchema schema =
+            schemasByNamespace.get( rstr.getBaseTypeName().getNamespaceURI() );
+        baseType = schema.getTypeByName( rstr.getBaseTypeName() );
+      }
+
+      if (baseType != null) {
+        XmlSchemaScope parentScope = getScope(baseType);
+        typeInfo =
+            restrictTypeInfo(
+                parentScope.getTypeInfo(),
+                mergeFacets(
+                    parentScope.getTypeInfo().getFacets(),
+                    rstr.getFacets()));
+
+        attributes = mergeAttributes(parentScope.attributes, attributes);
+      }
+
+      anyAttr = rstr.getAnyAttribute();
+    }
+  }
+
+  private ArrayList<XmlSchemaAttribute> getAttributesOf(
+      XmlSchemaAttributeGroupRef groupRef) {
+
+    XmlSchemaAttributeGroup attrGroup = groupRef.getRef().getTarget();
+    if (attrGroup == null) {
+      XmlSchema schema =
+          schemasByNamespace.get(groupRef.getTargetQName().getNamespaceURI());
+      attrGroup = schema.getAttributeGroupByName(groupRef.getTargetQName());
+    }
+    return getAttributesOf(attrGroup);
+  }
+
+  private ArrayList<XmlSchemaAttribute> getAttributesOf(
+      XmlSchemaAttributeGroup attrGroup) {
+
+    ArrayList<XmlSchemaAttribute> attrs =
+        new ArrayList<XmlSchemaAttribute>( attrGroup.getAttributes().size() );
+
+    for (XmlSchemaAttributeGroupMember member : attrGroup.getAttributes()) {
+      if (member instanceof XmlSchemaAttribute) {
+        attrs.add( getAttribute((XmlSchemaAttribute) member, false) );
+
+      } else if (member instanceof XmlSchemaAttributeGroup) {
+        attrs.addAll( getAttributesOf((XmlSchemaAttributeGroup) member) );
+
+      } else if (member instanceof XmlSchemaAttributeGroupRef) {
+        attrs.addAll( getAttributesOf((XmlSchemaAttributeGroupRef) member) );
+
+      } else {
+        throw new IllegalArgumentException(
+            "Attribute Group "
+            + getName(attrGroup, "{Anonymous Attribute Group}")
+            + " contains unrecognized attribute group memeber type "
+            + member.getClass().getName());
+      }
+    }
+
+    return attrs;
+  }
+
+  private XmlSchemaAttribute getAttribute(
+      XmlSchemaAttribute attribute,
+      boolean forceCopy) {
+
+    if (!attribute.isRef()
+        && (attribute.getSchemaType() != null)
+        && !forceCopy) {
+
+      if ( attribute.getUse().equals(XmlSchemaUse.NONE) ) {
+        attribute.setUse(XmlSchemaUse.OPTIONAL);
+      }
+
+      return attribute;
+    }
+
+    XmlSchemaAttribute globalAttr = null;
+    QName attrQName = null;
+    if ( attribute.isRef() ) {
+      attrQName = attribute.getRefBase().getTargetQName();
+    } else {
+      attrQName = attribute.getQName();
+    }
+    final XmlSchema schema =
+        schemasByNamespace.get( attrQName.getNamespaceURI() );
+
+    if (!attribute.isRef()
+        && (forceCopy || (attribute.getSchemaType() == null))) {
+      // If we are forcing a copy, there is no reference to follow.
+      globalAttr = attribute;
+    } else {
+      if (attribute.getRef().getTarget() != null) {
+        globalAttr = attribute.getRef().getTarget();
+      } else {
+        globalAttr = schema.getAttributeByName(attrQName);
+      }
+    }
+  
+    XmlSchemaSimpleType schemaType = globalAttr.getSchemaType();
+    if (schemaType == null) {
+      final QName typeQName = globalAttr.getSchemaTypeName();
+      XmlSchema typeSchema =
+          schemasByNamespace.get( typeQName.getNamespaceURI() );
+      schemaType = (XmlSchemaSimpleType) typeSchema.getTypeByName(typeQName);
+    }
+
+    /* The attribute reference defines the attribute use and overrides the ID,
+     * default, and fixed fields.  Everything else is defined by the global
+     * attribute.
+     */
+    String fixedValue = attribute.getFixedValue();
+    if ((fixedValue != null) && (attribute != globalAttr)) {
+      fixedValue = globalAttr.getFixedValue();
+    }
+
+    String defaultValue = attribute.getDefaultValue();
+    if ((defaultValue == null)
+        && (fixedValue == null)
+        && (attribute != globalAttr)) {
+      defaultValue = globalAttr.getDefaultValue();
+    }
+
+    String id = attribute.getId();
+    if ((id == null) && (attribute != globalAttr)) {
+      id = globalAttr.getId();
+    }
+
+    XmlSchemaUse attrUsage = attribute.getUse();
+    if ( attrUsage.equals(XmlSchemaUse.NONE) ) {
+      attrUsage = XmlSchemaUse.OPTIONAL;
+    }
+
+    final XmlSchemaAttribute copy = new XmlSchemaAttribute(schema, false);
+    copy.setName( globalAttr.getName() );
+
+    copy.setAnnotation( globalAttr.getAnnotation() );
+    copy.setDefaultValue(defaultValue);
+    copy.setFixedValue(fixedValue);
+    copy.setForm( globalAttr.getForm() );
+    copy.setId(id);
+    copy.setLineNumber( attribute.getLineNumber() );
+    copy.setLinePosition( attribute.getLinePosition() );
+    copy.setMetaInfoMap( globalAttr.getMetaInfoMap() );
+    copy.setSchemaType(schemaType);
+    copy.setSchemaTypeName( globalAttr.getSchemaTypeName() );
+    copy.setSourceURI( globalAttr.getSourceURI() );
+    copy.setUnhandledAttributes( globalAttr.getUnhandledAttributes() );
+    copy.setUse(attrUsage);
+
+    return copy;
+  }
+
+  private HashMap<QName, XmlSchemaAttribute> createAttributeMap(
+      Collection<? extends XmlSchemaAttributeOrGroupRef> attrs) {
+
+    if ((attrs == null) || attrs.isEmpty()) {
+      return null;
+    }
+
+    HashMap<QName, XmlSchemaAttribute> attributes =
+        new HashMap<QName, XmlSchemaAttribute>();
+
+    for (XmlSchemaAttributeOrGroupRef attr : attrs) {
+
+      if (attr instanceof XmlSchemaAttribute) {
+        XmlSchemaAttribute attribute =
+            getAttribute((XmlSchemaAttribute) attr, false);
+
+        attributes.put(attribute.getQName(), attribute);
+
+      } else if (attr instanceof XmlSchemaAttributeGroupRef) {
+        final List<XmlSchemaAttribute> attrList =
+            getAttributesOf((XmlSchemaAttributeGroupRef) attr);
+
+        for (XmlSchemaAttribute attribute : attrList) {
+          attributes.put(attribute.getQName(), attribute);
+        }
+      }
+    }
+
+    return attributes;
+  }
+
+  private HashMap<QName, XmlSchemaAttribute> mergeAttributes(
+      HashMap<QName, XmlSchemaAttribute> parentAttrs,
+      HashMap<QName, XmlSchemaAttribute> childAttrs) {
+
+    if ((parentAttrs == null) || parentAttrs.isEmpty()) {
+      return childAttrs;
+    } else if ((childAttrs == null) || childAttrs.isEmpty()) {
+      return parentAttrs;
+    }
+
+    HashMap<QName, XmlSchemaAttribute> newAttrs =
+        (HashMap<QName, XmlSchemaAttribute>) parentAttrs.clone();
+
+    /* Child attributes inherit all parent attributes, but may
+     * change the type, usage, default value, or fixed value.
+     */
+    for (Map.Entry<QName, XmlSchemaAttribute> parentAttrEntry :
+           parentAttrs.entrySet()) {
+
+      XmlSchemaAttribute parentAttr = parentAttrEntry.getValue();
+      XmlSchemaAttribute childAttr = childAttrs.get(parentAttrEntry.getKey());
+      if (childAttr != null) {
+        XmlSchemaAttribute newAttr = getAttribute(parentAttr, true);
+
+        if (childAttr.getSchemaType() != null) {
+          newAttr.setSchemaType( childAttr.getSchemaType() );
+        }
+
+        if (childAttr.getUse() != XmlSchemaUse.NONE) {
+          newAttr.setUse( childAttr.getUse() );
+        }
+
+        // Attribute values may be defaulted or fixed, but not both.
+        if (childAttr.getDefaultValue() != null) {
+          newAttr.setDefaultValue( childAttr.getDefaultValue() );
+          newAttr.setFixedValue(null);
+
+        } else if (childAttr.getFixedValue() != null) {
+          newAttr.setFixedValue( childAttr.getFixedValue() );
+          newAttr.setDefaultValue(null);
+        }
+
+        newAttrs.put(newAttr.getQName(), newAttr);
+      }
+    }
+
+    return newAttrs;
+  }
+
+  private XmlSchemaScope getScope(XmlSchemaType type) {
+    if ((type.getQName() != null) && scopeCache.containsKey(type.getQName())) {
+      return scopeCache.get(type.getQName());
+    } else {
+      XmlSchemaScope scope = new XmlSchemaScope(this, type);
+      if (type.getQName() != null) {
+        scopeCache.put(type.getQName(), scope);
+      }
+      return scope;
+    }
+  }
+
+  private QName getUserRecognizedType(
+      QName simpleType,
+      XmlSchemaTypeInfo parent) {
+
+    if (userRecognizedTypes == null) {
+      return null;
+    } else if (simpleType == null) {
+      return (parent == null) ? null : parent.getUserRecognizedType();
+
+    } else if ( userRecognizedTypes.contains(simpleType) ) {
+      return simpleType;
+    }
+
+    if ( XmlSchemaBaseSimpleType.isBaseSimpleType(simpleType) ) {
+
+      boolean checkAnyType = true;
+      boolean checkAnySimpleType = true;
+      switch ( XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(simpleType) ) {
+      case ANYTYPE:
+        checkAnyType = false;
+      case ANYSIMPLETYPE:
+        checkAnySimpleType = false;
+      default:
+      }
+
+      if (checkAnySimpleType) {
+        final QName anySimpleType =
+            XmlSchemaBaseSimpleType.ANYSIMPLETYPE.getQName();
+        if ( userRecognizedTypes.contains(anySimpleType) ) {
+          return anySimpleType;
+        }
+      }
+
+      if (checkAnyType) {
+        final QName anyType = XmlSchemaBaseSimpleType.ANYTYPE.getQName();
+        if (userRecognizedTypes.contains(anyType)) {
+          return anyType;
+        }
+      }
+    }
+
+    return (parent == null) ? null : parent.getUserRecognizedType();
+  }
+
+  private static String getName(XmlSchemaNamed name, String defaultName) {
+    if (name.isAnonymous()) {
+      return defaultName;
+    } else {
+      return name.getName();
+    }
+  }
+
+  private static HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+    mergeFacets(
+        HashMap<XmlSchemaRestriction.Type,
+        List<XmlSchemaRestriction>> parentFacets, List<XmlSchemaFacet> child) {
+
+    if ((child == null) || child.isEmpty()) {
+      return parentFacets;
+    }
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> childFacets
+      = new  HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>(
+          child.size() );
+
+    for (XmlSchemaFacet facet : child) {
+      XmlSchemaRestriction rstr = new XmlSchemaRestriction(facet);
+      List<XmlSchemaRestriction> rstrList = childFacets.get( rstr.getType() );
+      if (rstrList == null) {
+        // Only enumerations may have more than one value.
+        if (rstr.getType() == XmlSchemaRestriction.Type.ENUMERATION) {
+          rstrList = new ArrayList<XmlSchemaRestriction>(5);
+        } else {
+          rstrList = new ArrayList<XmlSchemaRestriction>(1);
+        }
+        childFacets.put(rstr.getType(), rstrList);
+      }
+      rstrList.add(rstr);
+    }
+
+    if (parentFacets == null) {
+      return childFacets;
+    }
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> mergedFacets
+        = (HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>)
+          parentFacets.clone();
+
+    // Child facets override parent facets
+    for (Map.Entry<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+           rstrEntry : childFacets.entrySet()) {
+
+      mergedFacets.put(rstrEntry.getKey(), rstrEntry.getValue());
+    }
+
+    return mergedFacets;
+  }
+
+  private static XmlSchemaTypeInfo restrictTypeInfo(
+      XmlSchemaTypeInfo parentTypeInfo,
+      HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets) {
+
+    XmlSchemaTypeInfo typeInfo = null;
+
+    switch(parentTypeInfo.getType()) {
+    case LIST:
+      typeInfo =
+        new XmlSchemaTypeInfo(
+            parentTypeInfo.getChildTypes().get(0),
+            facets);
+      break;
+    case UNION:
+      typeInfo =
+        new XmlSchemaTypeInfo(
+            parentTypeInfo.getChildTypes(),
+            facets);
+      break;
+    case ATOMIC:
+      typeInfo =
+        new XmlSchemaTypeInfo(
+          parentTypeInfo.getBaseType(),
+          facets);
+      break;
+    default:
+      throw new IllegalStateException(
+          "Cannot restrict on a " + parentTypeInfo.getType() + " type.");
+    }
+
+    if (parentTypeInfo.getUserRecognizedType() != null) {
+      typeInfo.setUserRecognizedType( parentTypeInfo.getUserRecognizedType() );
+    }
+
+    return typeInfo;
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaStateMachineGenerator.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaStateMachineGenerator.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaStateMachineGenerator.java	(working copy)
@@ -0,0 +1,405 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.XmlSchemaAll;
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaAnyAttribute;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaChoice;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+
+/**
+ * Builds a state machine from an
+ * {@link org.apache.ws.commons.schema.XmlSchema}
+ * representing how to walk through the schema when parsing an XML document.
+ */
+final class XmlSchemaStateMachineGenerator implements XmlSchemaVisitor {
+
+  private List<XmlSchemaStateMachineNode> stack;
+  private XmlSchemaStateMachineNode startNode;
+  private Map<QName, ElementInfo> elementInfoByQName;
+
+  private static class ElementInfo {
+    final List<XmlSchemaStateMachineNode.Attribute> attributes;
+    final XmlSchemaTypeInfo typeInfo;
+    final XmlSchemaElement element;
+
+    XmlSchemaStateMachineNode stateMachineNode;
+
+    ElementInfo(
+        XmlSchemaElement element,
+        XmlSchemaTypeInfo typeInfo) {
+
+      this.element = element;
+      this.typeInfo = typeInfo;
+      this.attributes = new ArrayList<XmlSchemaStateMachineNode.Attribute>();
+      this.stateMachineNode = null;
+    }
+
+    void addAttribute(XmlSchemaAttribute attr, XmlSchemaTypeInfo attrType) {
+      attributes.add(new XmlSchemaStateMachineNode.Attribute(attr, attrType));
+    }
+  }
+
+  public XmlSchemaStateMachineGenerator() {
+    stack = new ArrayList<XmlSchemaStateMachineNode>();
+    elementInfoByQName = new HashMap<QName, ElementInfo>();
+    startNode = null;
+  }
+
+  XmlSchemaStateMachineNode getStartNode() {
+    return startNode;
+  }
+
+  Map<QName, XmlSchemaStateMachineNode> getStateMachineNodesByQName() {
+    final HashMap<QName, XmlSchemaStateMachineNode> nodes =
+        new HashMap<QName, XmlSchemaStateMachineNode>();
+
+    for (Map.Entry<QName, ElementInfo> entry : elementInfoByQName.entrySet()) {
+      nodes.put(entry.getKey(), entry.getValue().stateMachineNode);
+    }
+
+    return nodes;
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onEnterElement(XmlSchemaElement, XmlSchemaTypeInfo, boolean)
+   */
+  @Override
+  public void onEnterElement(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo typeInfo,
+      boolean previouslyVisited) {
+
+    if (!previouslyVisited) {
+      /* This is our first encounter of the element.  We do not have the
+       * attributes yet, so we cannot create a state machine node for it.
+       * However, we will have all of the attributes once onEndAttributes()
+       * is called, so we can create an ElementInfo entry for it, and wait
+       * until later to create the state machine and add it to the stack.
+       */
+      final ElementInfo info = new ElementInfo(element, typeInfo);
+      elementInfoByQName.put(element.getQName(), info);
+
+    } else {
+      /* We have previously encountered this element, which means we have
+       * already collected all of the information we needed to build an
+       * XmlSchemaStateMachineNode.  Likewise, we can just reference it.
+       */
+      final ElementInfo elemInfo =
+          elementInfoByQName.get( element.getQName() );
+      if ((elemInfo == null) || (elemInfo.stateMachineNode == null)) {
+        throw new IllegalStateException(
+            "Element "
+            + element.getQName()
+            + " was already visited, but we do not"
+            + " have a state machine for it.");
+
+      } else if ( stack.isEmpty() ) {
+        throw new IllegalStateException(
+            "Element "
+            + element.getQName()
+            + " was previously visited, but there is no"
+            + " parent state machine node to attach it to!");
+      }
+
+      XmlSchemaStateMachineNode stateMachineNode =
+          elemInfo.stateMachineNode;
+
+      /* If this element is identical in every way except for the minimum and
+       * maximum number of occurrences, we want to create a new state machine
+       * node to represent this element.
+       */
+      if ((stateMachineNode.getMinOccurs() != element.getMinOccurs())
+          || (stateMachineNode.getMaxOccurs() != element.getMaxOccurs())) {
+        stateMachineNode =
+            new XmlSchemaStateMachineNode(
+                element,
+                elemInfo.attributes,
+                elemInfo.typeInfo);
+      }
+
+      stack.get(stack.size() - 1)
+           .addPossibleNextState(stateMachineNode);
+
+      stack.add(stateMachineNode);
+    }
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onExitElement(XmlSchemaElement, XmlSchemaTypeInfo, boolean)
+   */
+  @Override
+  public void onExitElement(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo typeInfo,
+      boolean previouslyVisited) {
+
+    if ( stack.isEmpty() ) {
+      throw new IllegalStateException(
+          "Exiting "
+          + element.getQName()
+          + ", but the stack is empty.");
+    }
+
+    final XmlSchemaStateMachineNode node = stack.remove(stack.size() - 1);
+    if (!node.getNodeType().equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      throw new IllegalStateException(
+          "Exiting element "
+          + element.getQName()
+          + ", but  "
+          + node
+          + " is on the stack.");
+
+    } else if (!node.getElement().getQName().equals(element.getQName())) {
+      throw new IllegalStateException(
+          "Element "
+          + element.getQName()
+          + " is not the same in-memory copy we received on creation.  Our"
+          + " copy is of a "
+          + node.getElement().getQName());
+    }
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onVisitAttribute(XmlSchemaElement, XmlSchemaAttribute, XmlSchemaTypeInfo)
+   */
+  @Override
+  public void onVisitAttribute(
+      XmlSchemaElement element,
+      XmlSchemaAttribute attribute,
+      XmlSchemaTypeInfo attributeType) {
+
+    final ElementInfo elemInfo = elementInfoByQName.get(element.getQName());
+    if (elemInfo == null) {
+      throw new IllegalStateException(
+          "No record exists for element " + element.getQName());
+    }
+
+    elemInfo.addAttribute(attribute, attributeType);
+  }
+
+  @Override
+  public void onEndAttributes(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo elemTypeInfo) {
+
+    /* The parent of this group is an element
+     * that needs to be added to the stack.
+     */
+    final ElementInfo elemInfo = elementInfoByQName.get(element.getQName());
+
+    if (elemInfo.stateMachineNode != null) {
+      throw new IllegalStateException(
+          "Parent element "
+          + element.getQName()
+          + " is supposedly undefined, but that entry already has a state"
+          + " machine of "
+          + elemInfo.stateMachineNode);
+    }
+
+    elemInfo.stateMachineNode =
+        new XmlSchemaStateMachineNode(
+            elemInfo.element,
+            elemInfo.attributes,
+            elemInfo.typeInfo);
+
+    if ( !stack.isEmpty() ) {
+      stack.get(stack.size() - 1)
+           .addPossibleNextState(elemInfo.stateMachineNode);
+    } else {
+      // This is the root node.
+      startNode = elemInfo.stateMachineNode;
+    }
+
+    stack.add(elemInfo.stateMachineNode);
+
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onEnterSubstitutionGroup(XmlSchemaElement)
+   */
+  @Override
+  public void onEnterSubstitutionGroup(XmlSchemaElement base) {
+    if ( stack.isEmpty() ) {
+      // The root element is the base of a substitution group.
+      startNode =
+          new XmlSchemaStateMachineNode(
+              XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP,
+              base.getMinOccurs(),
+              base.getMaxOccurs());
+      stack.add(startNode);
+    } else {
+      pushGroup(
+          XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP,
+          base.getMinOccurs(),
+          base.getMaxOccurs());
+    }
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onExitSubstitutionGroup(XmlSchemaElement)
+   */
+  @Override
+  public void onExitSubstitutionGroup(XmlSchemaElement base) {
+    popGroup(XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP);
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onEnterAllGroup(XmlSchemaAll)
+   */
+  @Override
+  public void onEnterAllGroup(XmlSchemaAll all) {
+    pushGroup(
+        XmlSchemaStateMachineNode.Type.ALL,
+        all.getMinOccurs(),
+        all.getMaxOccurs());
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onExitAllGroup(XmlSchemaAll)
+   */
+  @Override
+  public void onExitAllGroup(XmlSchemaAll all) {
+    popGroup(XmlSchemaStateMachineNode.Type.ALL);
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onEnterChoiceGroup(XmlSchemaChoice)
+   */
+  @Override
+  public void onEnterChoiceGroup(XmlSchemaChoice choice) {
+    pushGroup(
+        XmlSchemaStateMachineNode.Type.CHOICE,
+        choice.getMinOccurs(),
+        choice.getMaxOccurs());
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onExitChoiceGroup(XmlSchemaChoice)
+   */
+  @Override
+  public void onExitChoiceGroup(XmlSchemaChoice choice) {
+    popGroup(XmlSchemaStateMachineNode.Type.CHOICE);
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onEnterSequenceGroup(XmlSchemaSequence)
+   */
+  @Override
+  public void onEnterSequenceGroup(XmlSchemaSequence seq) {
+    pushGroup(
+        XmlSchemaStateMachineNode.Type.SEQUENCE,
+        seq.getMinOccurs(),
+        seq.getMaxOccurs());
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onExitSequenceGroup(XmlSchemaSequence)
+   */
+  @Override
+  public void onExitSequenceGroup(XmlSchemaSequence seq) {
+    popGroup(XmlSchemaStateMachineNode.Type.SEQUENCE);
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onVisitAny(XmlSchemaAny)
+   */
+  @Override
+  public void onVisitAny(XmlSchemaAny any) {
+    final XmlSchemaStateMachineNode node =
+        new XmlSchemaStateMachineNode(any);
+
+    if ( stack.isEmpty() ) {
+      throw new IllegalStateException(
+          "Reached an wildcard with no parent!  The stack is empty.");
+    }
+
+    stack.get(stack.size() - 1).addPossibleNextState(node);
+  }
+
+  /**
+   * @see XmlSchemaVisitor#onVisitAnyAttribute(XmlSchemaElement, XmlSchemaAnyAttribute)
+   */
+  @Override
+  public void onVisitAnyAttribute(XmlSchemaElement element,
+      XmlSchemaAnyAttribute anyAttr) {
+
+    // Ignored.
+  }
+
+  private void pushGroup(
+      XmlSchemaStateMachineNode.Type groupType,
+      long minOccurs,
+      long maxOccurs) {
+
+    if ( stack.isEmpty() ) {
+      throw new IllegalStateException(
+          "Attempted to create a(n) "
+          + groupType
+          + " group with no parent - the stack is empty!");
+    }
+
+    final XmlSchemaStateMachineNode node =
+        new XmlSchemaStateMachineNode(
+            groupType,
+            minOccurs,
+            maxOccurs);
+
+    stack.get(stack.size() - 1).addPossibleNextState(node);
+    stack.add(node);
+  }
+
+  private void popGroup(XmlSchemaStateMachineNode.Type groupType) {
+    if ( stack.isEmpty() ) {
+      throw new IllegalStateException(
+          "Exiting an "
+          + groupType
+          + " group, but the stack is empty!");
+    }
+
+    final XmlSchemaStateMachineNode node = stack.remove(stack.size() - 1);
+
+    if (!node.getNodeType().equals(groupType)) {
+      throw new IllegalStateException(
+          "Attempted to pop a "
+          + groupType
+          + " off of the stack, but found a "
+          + node.getNodeType()
+          + " instead!");
+    }
+
+    if (!groupType.equals(XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP)
+        && stack.isEmpty()) {
+      throw new IllegalStateException(
+          "Popped a group of type "
+          + groupType
+          + " only to find it did not have a parent.");
+    }
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaStateMachineNode.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaStateMachineNode.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaStateMachineNode.java	(working copy)
@@ -0,0 +1,294 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+
+/**
+ * This represents a node in the state
+ * machine used when parsing an XML
+ * {@link org.w3c.dom.Document} based on its
+ * {@link org.apache.ws.commons.schema.XmlSchema}
+ * and Avro {@link org.apache.avro.Schema}.
+ *
+ * <p>
+ * A <code>SchemaStateMachineNode</code> represents one of:
+ * <ul>
+ *   <li>An element, its type, and its attributes</li>
+ *   <li>An all group</li>
+ *   <li>A choice group</li>
+ *   <li>A sequence group</li>
+ *   <li>An &lt;any&gt; wildcard element</li>
+ *   <li>A substitution group</li>
+ * </ul>
+ *
+ * As a {@link org.w3c.dom.Document} is traversed, the state machine is used
+ * to determine how to process the current element.  Two passes will be needed:
+ * the first pass will determine the correct path through the document's schema
+ * in order to properly parse the elements, and the second traversal will read
+ * the elements while following that path. 
+ * </p>
+ */
+final class XmlSchemaStateMachineNode {
+
+  private final Type nodeType;
+  private final XmlSchemaElement element;
+  private final List<Attribute> attributes;
+  private final XmlSchemaTypeInfo typeInfo;
+  private final long minOccurs;
+  private final long maxOccurs;
+  private final XmlSchemaAny any;
+
+  private List<XmlSchemaStateMachineNode> possibleNextStates;
+
+  enum Type {
+    ELEMENT,
+    SUBSTITUTION_GROUP,
+    ALL,
+    CHOICE,
+    SEQUENCE,
+    ANY
+  }
+
+  static class Attribute {
+    Attribute(XmlSchemaAttribute attribute, XmlSchemaTypeInfo attrType) {
+      this.attribute = attribute;
+      this.attrType = attrType;
+    }
+
+    XmlSchemaAttribute getAttribute() {
+      return attribute;
+    }
+
+    XmlSchemaTypeInfo getType() {
+      return attrType;
+    }
+
+    private final XmlSchemaAttribute attribute;
+    private final XmlSchemaTypeInfo attrType;
+  }
+
+  /**
+   * Constructs a new <code>SchemaStateMachineNode</code> for a group.
+   *
+   * @param nodeType The type of the group node ({@link Type#ALL},
+   *                 {@link Type#SUBSTITUTION_GROUP}, {@link Type#CHOICE},
+   *                 {@link Type#SEQUENCE}, or {@link Type#ANY}).
+   *
+   * @param minOccurs The minimum number of occurrences of this group.
+   * @param maxOccurs The maximum number of occurrences of this group.
+   *
+   * @throws IllegalArgumentException if this constructor is used to
+   *                                  define an {@link Type#ELEMENT}
+   *                                  or an {@link Type#ANY}.
+   */
+  XmlSchemaStateMachineNode(
+      Type nodeType,
+      long minOccurs,
+      long maxOccurs) {
+
+    if ( nodeType.equals(Type.ELEMENT) ) {
+      throw new IllegalArgumentException(
+          "This constructor cannot be used for elements.");
+
+    } else if ( nodeType.equals(Type.ANY) ) {
+      throw new IllegalArgumentException(
+          "This constructor cannot be used for wildcard elements.");
+    }
+
+    this.nodeType = nodeType;
+    this.minOccurs = minOccurs;
+    this.maxOccurs = maxOccurs;
+
+    this.element = null;
+    this.attributes = null;
+    this.typeInfo = null;
+    this.any = null;
+
+    this.possibleNextStates = new ArrayList<XmlSchemaStateMachineNode>();
+  }
+
+  /**
+   * Constructs a new <code>SchemaStateMachineNode</code> for an element.
+   *
+   * @param elem The {@link XmlSchemaElement} this node represents.
+   *
+   * @param attrs The {@link XmlSchemaAttribute} contained by this element.
+   *              An empty {@link List} or <code>null</code> if none.
+   *
+   * @param typeInfo The type information, if the element has simple content.
+   *                 <code>null</code> if not.
+   */
+  XmlSchemaStateMachineNode(
+      XmlSchemaElement elem,
+      List<Attribute> attrs,
+      XmlSchemaTypeInfo typeInfo)
+  {
+    this.nodeType = Type.ELEMENT;
+    this.element = elem;
+    this.attributes = attrs;
+    this.typeInfo = typeInfo;
+    this.minOccurs = elem.getMinOccurs();
+    this.maxOccurs = elem.getMaxOccurs();
+
+    this.any = null;
+
+    this.possibleNextStates = new ArrayList<XmlSchemaStateMachineNode>();
+  }
+
+  /**
+   * Constructs a {@link XmlSchemaStateMachineNode}
+   * from the {@link XmlSchemaAny}.
+   *
+   * @param any The <code>XmlSchemaAny</code> to construct the node from.
+   */
+  XmlSchemaStateMachineNode(XmlSchemaAny any) {
+    this.nodeType = Type.ANY;
+    this.any = any;
+    this.minOccurs = any.getMinOccurs();
+    this.maxOccurs = any.getMaxOccurs();
+
+    this.element = null;
+    this.attributes = null;
+    this.typeInfo = null;
+
+    this.possibleNextStates = new ArrayList<XmlSchemaStateMachineNode>();
+  }
+
+  /**
+   * The XML Schema node {@link Type} this
+   * <code>SchemaStateMachineNode</code> represents.
+   */
+  Type getNodeType() {
+    return nodeType;
+  }
+
+  /**
+   * If this <code>SchemaStateMachineNode</code> represents an
+   * {@link XmlSchemaElement}, the <code>XmlSchemaElement</code>
+   * it represents.
+   */
+  XmlSchemaElement getElement() {
+    return element;
+  }
+
+  /**
+   * If this <code>SchemaStateMachineNode</code> represents an
+   * {@link XmlSchemaElement}, the {@link XmlSchemaTypeInfo}
+   * of the element it represents.
+   */
+  XmlSchemaTypeInfo getElementType() {
+    return typeInfo;
+  }
+
+  /**
+   * If this <code>SchemaStateMachineNode</code> represents an
+   * {@link XmlSchemaElement}, the set of {@link Attribute}s
+   * associated with the element it represents.
+   */
+  List<Attribute> getAttributes() {
+    return attributes;
+  }
+
+  /**
+   * The minimum number of times this <code>SchemaStateMachineNode</code>
+   * may appear in succession.
+   */
+  long getMinOccurs() {
+    return minOccurs;
+  }
+
+  /**
+   * The maximum number of times this <code>SchemaStateMachineNode</code>
+   * may appear in succession.
+   */
+  long getMaxOccurs() {
+    return maxOccurs;
+  }
+
+  /**
+   * Returns the {@link XmlSchemaAny} associated
+   * with this node, or <code>null</code if none.
+   */
+  XmlSchemaAny getAny() {
+    return any;
+  }
+
+  /**
+   * Adds a state that could follow this <code>SchemaStateMachineNode</code>.
+   *
+   * @param next A node that could follow this one in the XML document.
+   * @return Itself, for chaining.
+   */
+  XmlSchemaStateMachineNode addPossibleNextState(
+      XmlSchemaStateMachineNode next) {
+    possibleNextStates.add(next);
+    return this;
+  }
+
+  /**
+   * Adds the set of possible states that could follow
+   * this <code>SchemaStateMachineNode</code>.
+   *
+   * @param nextStates The set of possible nodes that could
+   *                   follow this one in the XML document.
+   *
+   * @return Itself, for chaining.
+   */
+  XmlSchemaStateMachineNode addPossibleNextStates(
+      java.util.Collection<XmlSchemaStateMachineNode> nextStates) {
+
+    possibleNextStates.addAll(nextStates);
+    return this;
+  }
+
+  /**
+   * All of the known possible states that could follow this one.
+   */
+  List<XmlSchemaStateMachineNode> getPossibleNextStates() {
+    return possibleNextStates;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder name = new StringBuilder( nodeType.name() );
+    switch (nodeType) {
+    case ELEMENT:
+      name.append(": ").append( element.getQName() ).append(" [");
+      name.append(minOccurs).append(", ");
+      name.append(maxOccurs).append("]");
+      break;
+    case ANY:
+      name.append(": NS: \"").append( any.getNamespace() ).append("\", ");
+      name.append("Processing: ").append( any.getProcessContent() );
+      name.append(" [").append(minOccurs).append(", ").append(maxOccurs);
+      name.append(']');
+      break;
+    default:
+      name.append(" [").append(minOccurs).append(", ").append(maxOccurs);
+      name.append(']');
+    }
+    return name.toString();
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaTypeInfo.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaTypeInfo.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaTypeInfo.java	(working copy)
@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+
+/**
+ * Represents an element's or attribute's type, meaning either a
+ * {@link XmlSchemaBaseSimpleType} with facets, a union or list of
+ * those, or a complex type.
+ *
+ * <p>
+ * Also maintains a {@link QName} representing a type the user recognizes.
+ * In the Avro case, this is the set of XML Schema simple types that can
+ * be directly converted to Avro counterparts.
+ * </p>
+ */
+final class XmlSchemaTypeInfo {
+
+  private Type type;
+  private HashMap<XmlSchemaRestriction.Type,List<XmlSchemaRestriction>> facets;
+  private boolean isMixed;
+  private XmlSchemaBaseSimpleType baseSimpleType;
+  private QName userRecognizedType;
+  private List<XmlSchemaTypeInfo> childTypes;
+
+  enum Type {
+    LIST,
+    UNION,
+    ATOMIC,
+    COMPLEX;
+  }
+
+  XmlSchemaTypeInfo(XmlSchemaTypeInfo listType) {
+    type = Type.LIST;
+    childTypes = new ArrayList<XmlSchemaTypeInfo>(1);
+    childTypes.add(listType);
+
+    isMixed = false;
+    facets = null;
+    userRecognizedType = null;
+  }
+
+  XmlSchemaTypeInfo(
+      XmlSchemaTypeInfo listType,
+      HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets) {
+    this(listType);
+    this.facets = facets;
+  }
+
+  XmlSchemaTypeInfo(List<XmlSchemaTypeInfo> unionTypes) {
+    type = Type.UNION;
+    childTypes = unionTypes;
+
+    isMixed = false;
+    facets = null;
+    userRecognizedType = null;
+  }
+
+  XmlSchemaTypeInfo(
+      List<XmlSchemaTypeInfo> unionTypes,
+      HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets) {
+    this(unionTypes);
+    this.facets = facets;
+  }
+
+  XmlSchemaTypeInfo(XmlSchemaBaseSimpleType baseSimpleType) {
+    if (baseSimpleType.equals(XmlSchemaBaseSimpleType.ANYTYPE)) {
+      type = Type.COMPLEX;
+    } else {
+      type = Type.ATOMIC;
+    }
+
+    this.baseSimpleType = baseSimpleType;
+
+    isMixed = false;
+    facets = null;
+    childTypes = null;
+    userRecognizedType = null;
+  }
+
+  XmlSchemaTypeInfo(
+      XmlSchemaBaseSimpleType baseSimpleType,
+      HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets) {
+
+    this(baseSimpleType);
+    this.facets = facets;
+  }
+
+  XmlSchemaTypeInfo(boolean isMixed) {
+    type = Type.COMPLEX;
+    baseSimpleType = XmlSchemaBaseSimpleType.ANYTYPE;
+    this.isMixed = isMixed;
+
+    facets = null;
+    childTypes = null;
+    userRecognizedType = null;
+  }
+
+  HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> getFacets() {
+    return facets;
+  }
+
+  XmlSchemaBaseSimpleType getBaseType() {
+    return baseSimpleType;
+  }
+
+  Type getType() {
+    return type;
+  }
+
+  List<XmlSchemaTypeInfo> getChildTypes() {
+    return childTypes;
+  }
+
+  QName getUserRecognizedType() {
+    return userRecognizedType;
+  }
+
+  boolean isMixed() {
+    return isMixed;
+  }
+
+  void setUserRecognizedType(QName userRecType) {
+    userRecognizedType = userRecType;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder str = new StringBuilder("XmlSchemaTypeInfo [");
+    str.append(type).append("] Base Type: ").append(baseSimpleType);
+    str.append(" User Recognized Type: ").append(userRecognizedType);
+    str.append(" Is Mixed: ").append(isMixed);
+    str.append(" Num Children: ");
+    str.append((childTypes == null) ? 0 : childTypes.size());
+    return str.toString();
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaVisitor.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaVisitor.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaVisitor.java	(working copy)
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import org.apache.ws.commons.schema.XmlSchemaAll;
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaAnyAttribute;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaChoice;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+
+/**
+ * Defines a visitor interface for notifications when walking
+ * an {@link XmlSchema} using the {@link XmlSchemaWalker}.
+ */
+interface XmlSchemaVisitor {
+
+  void onEnterElement(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo typeInfo,
+      boolean previouslyVisited);
+
+  void onExitElement(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo typeInfo,
+      boolean previouslyVisited);
+
+  void onVisitAttribute(
+      XmlSchemaElement element,
+      XmlSchemaAttribute attribute,
+      XmlSchemaTypeInfo attributeType);
+
+  void onEndAttributes(
+      XmlSchemaElement element,
+      XmlSchemaTypeInfo typeInfo);
+
+  void onEnterSubstitutionGroup(XmlSchemaElement base);
+  void onExitSubstitutionGroup(XmlSchemaElement base);
+
+  void onEnterAllGroup(XmlSchemaAll all);
+  void onExitAllGroup(XmlSchemaAll all);
+
+  void onEnterChoiceGroup(XmlSchemaChoice choice);
+  void onExitChoiceGroup(XmlSchemaChoice choice);
+
+  void onEnterSequenceGroup(XmlSchemaSequence seq);
+  void onExitSequenceGroup(XmlSchemaSequence seq);
+
+  void onVisitAny(XmlSchemaAny any);
+
+  void onVisitAnyAttribute(
+      XmlSchemaElement element,
+      XmlSchemaAnyAttribute anyAttr);
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaWalker.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaWalker.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/XmlSchemaWalker.java	(working copy)
@@ -0,0 +1,529 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaAll;
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaChoice;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaGroup;
+import org.apache.ws.commons.schema.XmlSchemaGroupParticle;
+import org.apache.ws.commons.schema.XmlSchemaGroupRef;
+import org.apache.ws.commons.schema.XmlSchemaObject;
+import org.apache.ws.commons.schema.XmlSchemaParticle;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaSequenceMember;
+import org.apache.ws.commons.schema.XmlSchemaType;
+
+/**
+ * Walks an {@link XmlSchema} from a starting {@link XmlSchemaElement},
+ * notifying attached visitors as it descends.
+ */
+final class XmlSchemaWalker {
+
+  private Set<QName> userRecognizedTypes;
+
+  private final XmlSchemaCollection schemas;
+  private final ArrayList<XmlSchemaVisitor> visitors;
+  private final Map<QName, List<XmlSchemaElement>> elemsBySubstGroup;
+  private final Map<String, XmlSchema> schemasByNamespace;
+  private final Map<QName, XmlSchemaScope> scopeCache;
+  private final Set<QName> visitedElements;
+
+  /**
+   * Initializes the {@link XmlSchemaWalker} with the
+   * {@link XmlScheamCollection} to reference when following
+   * an {@link XmlSchemaElement}.
+   */
+  XmlSchemaWalker(XmlSchemaCollection xmlSchemas) {
+    if (xmlSchemas == null) {
+      throw new IllegalArgumentException(
+          "Input XmlSchemaCollection cannot be null.");
+    }
+
+    schemas = xmlSchemas;
+    visitors = new ArrayList<XmlSchemaVisitor>(1);
+
+    schemasByNamespace = new HashMap<String, XmlSchema>();
+    elemsBySubstGroup = new HashMap<QName, List<XmlSchemaElement>>();
+
+    for (XmlSchema schema : schemas.getXmlSchemas()) {
+      schemasByNamespace.put(schema.getTargetNamespace(), schema);
+
+      for (XmlSchemaElement elem : schema.getElements().values()) {
+        if (elem.getSubstitutionGroup() != null) {
+          List<XmlSchemaElement> elems =
+              elemsBySubstGroup.get( elem.getSubstitutionGroup() );
+          if (elems == null) {
+            elems = new ArrayList<XmlSchemaElement>();
+            elemsBySubstGroup.put(elem.getSubstitutionGroup(), elems);
+          }
+          elems.add(elem);
+        }
+      }
+    }
+
+    scopeCache = new HashMap<QName, XmlSchemaScope>();
+    visitedElements = new java.util.HashSet<QName>();
+    userRecognizedTypes = null;
+  }
+
+  XmlSchemaWalker(XmlSchemaCollection xmlSchemas, XmlSchemaVisitor visitor) {
+    this(xmlSchemas);
+    if (visitor != null) {
+      visitors.add(visitor);
+    }
+  }
+
+  XmlSchemaWalker addVisitor(XmlSchemaVisitor visitor) {
+    visitors.add(visitor);
+    return this;
+  }
+
+  XmlSchemaWalker removeVisitor(XmlSchemaVisitor visitor) {
+    if (visitor != null) {
+      visitors.remove(visitor);
+    }
+    return this;
+  }
+
+  void clear() {
+    scopeCache.clear();
+    visitedElements.clear();
+  }
+
+  void setUserRecognizedTypes(Set<QName> userRecognizedTypes) {
+    this.userRecognizedTypes = userRecognizedTypes;
+  }
+
+  Set<QName> getUserRecognizedTypes() {
+    return userRecognizedTypes;
+  }
+
+  // Depth-first search.  Visitors will build a stack of XmlSchemaParticle.
+  void walk(XmlSchemaElement element) {
+    element = getElement(element, false);
+
+    final XmlSchemaElement substGroupElem = element;
+
+    /* If this element is the root of a
+     * substitution group, notify the visitors.
+     */
+    List<XmlSchemaElement> substitutes = null;
+    if ( elemsBySubstGroup.containsKey( getElementQName(element) ) ) {
+      substitutes = elemsBySubstGroup.get( element.getQName() );
+
+      for (XmlSchemaVisitor visitor : visitors) {
+        visitor.onEnterSubstitutionGroup(substGroupElem);
+      }
+
+      // Force a copy to change the min & max occurs.
+      element = getElement(element, true);
+      element.setMinOccurs(XmlSchemaParticle.DEFAULT_MIN_OCCURS);
+      element.setMaxOccurs(XmlSchemaParticle.DEFAULT_MAX_OCCURS);
+    }
+
+    XmlSchemaType schemaType = element.getSchemaType();
+    if (schemaType == null) {
+      final QName typeQName = element.getSchemaTypeName();
+      if (typeQName != null) {
+        XmlSchema schema =
+            schemasByNamespace.get( typeQName.getNamespaceURI() );
+        schemaType = schema.getTypeByName(typeQName);
+      }
+    }
+
+    if (schemaType != null) {
+      XmlSchemaScope scope = null;
+      if ((schemaType.getQName() != null)
+          && scopeCache.containsKey( schemaType.getQName())) {
+        scope = scopeCache.get(schemaType.getQName());
+      } else {
+        scope =
+            new XmlSchemaScope(
+                schemaType,
+                schemasByNamespace,
+                scopeCache,
+                userRecognizedTypes);
+        if (schemaType.getQName() != null) {
+          scopeCache.put(schemaType.getQName(), scope);
+        }
+      }
+
+      // 1. Fetch all attributes as a List<XmlSchemaAttribute>.
+      final Collection<XmlSchemaAttribute> attrs =
+          scope.getAttributesInScope();
+      final XmlSchemaTypeInfo typeInfo = scope.getTypeInfo();
+
+      // 2. for each visitor, call visitor.startElement(element, type);
+      final boolean previouslyVisited =
+          (!element.isAnonymous()
+              && visitedElements.contains( element.getQName() ));
+
+      for (XmlSchemaVisitor visitor : visitors) {
+        visitor.onEnterElement(element, typeInfo, previouslyVisited);
+      }
+
+      if (!element.isAnonymous() && !previouslyVisited) {
+        visitedElements.add( element.getQName() );
+      }
+
+      // If we already visited this element, skip the attributes and child.
+      if (!previouslyVisited) {
+
+        // 3. Walk the attributes in the element, retrieving type information.
+        if (attrs != null) {
+          for (XmlSchemaAttribute attr : attrs) {
+            XmlSchemaType attrType = attr.getSchemaType();
+            XmlSchemaScope attrScope = null;
+            if ((attrType.getQName() != null)
+                && scopeCache.containsKey( attrType.getQName() )) {
+              attrScope = scopeCache.get( attrType.getQName() );
+            } else {
+              attrScope =
+                  new XmlSchemaScope(
+                      attr.getSchemaType(),
+                      schemasByNamespace,
+                      scopeCache,
+                      userRecognizedTypes);
+
+              if (attrType.getName() != null) {
+                scopeCache.put(attrType.getQName(), attrScope);
+              }
+            }
+    
+            final XmlSchemaTypeInfo attrTypeInfo = attrScope.getTypeInfo();
+      
+            for (XmlSchemaVisitor visitor : visitors) {
+              visitor.onVisitAttribute(element, attr, attrTypeInfo);
+            }
+          }
+        }
+    
+        // 4. Visit the anyAttribute, if any.
+        if (scope.getAnyAttribute() != null) {
+          for (XmlSchemaVisitor visitor : visitors) {
+            visitor.onVisitAnyAttribute(element, scope.getAnyAttribute());
+          }
+        }
+
+        /* 5. Notify that we visited all of the
+         *    attributes (even if there weren't any).
+         */
+        for (XmlSchemaVisitor visitor : visitors) {
+          visitor.onEndAttributes(element, typeInfo);
+        }
+
+        // 6. Walk the child groups and elements (if any), depth-first.
+        final XmlSchemaParticle child = scope.getParticle();
+        if (child != null) {
+          walk(child);
+        }
+      }
+
+      /* 7. On the way back up, call
+       * visitor.endElement(element, type, attributes);
+       */
+      for (XmlSchemaVisitor visitor : visitors) {
+        visitor.onExitElement(element, typeInfo, previouslyVisited);
+      }
+
+    } else if ( !element.isAbstract() ) {
+      throw new IllegalStateException(
+          "Element "
+          + element.getQName()
+          + " is not abstract and has no type.");
+    }
+
+    // 8. Now handle substitute elements, if any.
+    if (substitutes != null) {
+      for (XmlSchemaElement substitute : substitutes) {
+        walk(substitute);
+      }
+
+      for (XmlSchemaVisitor visitor : visitors) {
+        visitor.onExitSubstitutionGroup(substGroupElem);
+      }
+    }
+  }
+
+  private void walk(XmlSchemaParticle particle) {
+    if (particle instanceof XmlSchemaGroupRef) {
+      XmlSchemaGroupRef groupRef = (XmlSchemaGroupRef) particle;
+      XmlSchemaGroupParticle group = groupRef.getParticle();
+      if (group == null) {
+        XmlSchema schema =
+            schemasByNamespace.get( groupRef.getRefName().getNamespaceURI() );
+
+        group = schema.getGroupByName( groupRef.getRefName() ).getParticle();
+      }
+      walk(group, groupRef.getMinOccurs(), groupRef.getMaxOccurs());
+
+    } else if (particle instanceof XmlSchemaGroupParticle) {
+      walk((XmlSchemaGroupParticle) particle,
+           particle.getMinOccurs(),
+           particle.getMaxOccurs());
+
+    } else if (particle instanceof XmlSchemaElement) {
+      walk((XmlSchemaElement) particle);
+
+    } else if (particle instanceof XmlSchemaAny) {
+      for (XmlSchemaVisitor visitor : visitors) {
+        visitor.onVisitAny((XmlSchemaAny) particle);
+      }
+
+    } else {
+      throw new IllegalArgumentException(
+          "Unknown particle type "
+          + particle.getClass().getName());
+    }
+
+  }
+
+  private void walk(
+      XmlSchemaGroupParticle group,
+      long minOccurs,
+      long maxOccurs) {
+
+    // Only make a copy of the particle if the minOccurs or maxOccurs was set.
+    final boolean forceCopy =
+        ((minOccurs != group.getMinOccurs())
+            || (maxOccurs != group.getMaxOccurs()));
+
+    // 1. Determine the group particle type.
+    XmlSchemaAll all = null;
+    XmlSchemaChoice choice = null;
+    XmlSchemaSequence seq = null;
+
+    ArrayList<XmlSchemaParticle> children = null;
+
+    if (group instanceof XmlSchemaAll) {
+      all = (XmlSchemaAll) group;
+
+    } else if (group instanceof XmlSchemaChoice) {
+      choice = (XmlSchemaChoice) group;
+
+    } else if (group instanceof XmlSchemaSequence) {
+      seq = (XmlSchemaSequence) group;
+
+    } else {
+      throw new IllegalArgumentException(
+          "Unrecognized XmlSchemaGroupParticle of type "
+          + group.getClass().getName());
+    }
+
+    // 2. Make a copy if necessary.
+    if (forceCopy) {
+      if (all != null) {
+        XmlSchemaAll copy = new XmlSchemaAll();
+        copy.setAnnotation( all.getAnnotation() );
+        copy.setId( all.getId() );
+        copy.setLineNumber( all.getLineNumber() );
+        copy.setLinePosition( all.getLinePosition() );
+        copy.setMetaInfoMap( all.getMetaInfoMap() );
+        copy.setMinOccurs(minOccurs);
+        copy.setMaxOccurs(maxOccurs);
+        copy.setSourceURI( all.getSourceURI() );
+        copy.setUnhandledAttributes( all.getUnhandledAttributes() );
+        copy.getItems().addAll( all.getItems() );
+
+        all = copy;
+
+      } else if (choice != null) {
+        XmlSchemaChoice copy = new XmlSchemaChoice();
+        copy.setAnnotation( choice.getAnnotation() );
+        copy.setId( choice.getId() );
+        copy.setLineNumber( choice.getLineNumber() );
+        copy.setLinePosition( choice.getLinePosition() );
+        copy.setMinOccurs(minOccurs);
+        copy.setMaxOccurs(maxOccurs);
+        copy.setMetaInfoMap( choice.getMetaInfoMap() );
+        copy.setSourceURI( choice.getSourceURI() );
+        copy.setUnhandledAttributes( choice.getUnhandledAttributes() );
+        copy.getItems().addAll( choice.getItems() );
+
+        choice = copy;
+
+      } else if (seq != null) {
+        XmlSchemaSequence copy = new XmlSchemaSequence();
+        copy.setAnnotation( seq.getAnnotation() );
+        copy.setId( seq.getId() );
+        copy.setLineNumber( seq.getLineNumber() );
+        copy.setLinePosition( seq.getLinePosition() );
+        copy.setMinOccurs(minOccurs);
+        copy.setMaxOccurs(maxOccurs);
+        copy.setMetaInfoMap( seq.getMetaInfoMap() );
+        copy.setSourceURI( seq.getSourceURI() );
+        copy.setUnhandledAttributes( seq.getUnhandledAttributes() );
+
+        seq = copy;
+      }
+    }
+
+    // 3. Notify the visitors.
+    for (XmlSchemaVisitor visitor : visitors) {
+      if (all != null) {
+        visitor.onEnterAllGroup(all);
+      } else if (choice != null) {
+        visitor.onEnterChoiceGroup(choice);
+      } else if (seq != null) {
+        visitor.onEnterSequenceGroup(seq);
+      }
+    }
+
+    // 4. Walk the children.
+    if (all != null) {
+      children = new ArrayList<XmlSchemaParticle>( all.getItems().size() );
+      children.addAll( all.getItems() );
+
+    } else if (choice != null) {
+      children = new ArrayList<XmlSchemaParticle>( choice.getItems().size() );
+      for (XmlSchemaObject item : choice.getItems()) {
+        if (item instanceof XmlSchemaGroup) {
+          children.add(((XmlSchemaGroup) item).getParticle());
+        } else if (item instanceof XmlSchemaParticle) {
+          children.add((XmlSchemaParticle) item);
+        } else {
+          throw new IllegalArgumentException(
+              "Choice child is not an XmlSchemaGroup or XmlSchemaParticle; "
+              + "it is a "
+              + item.getClass().getName());
+        }
+      }
+
+    } else if (seq != null) {
+      children = new ArrayList<XmlSchemaParticle>( seq.getItems().size() );
+      for (XmlSchemaSequenceMember item : seq.getItems()) {
+        if (item instanceof XmlSchemaGroup) {
+          children.add(((XmlSchemaGroup) item).getParticle());
+        } else if (item instanceof XmlSchemaParticle) {
+          children.add((XmlSchemaParticle) item);
+        } else {
+          throw new IllegalArgumentException(
+              "Sequence child is not an XmlSchemaGroup or XmlSchemaParticle; "
+              + "it is a "
+              + item.getClass().getName());
+        }
+      }
+    }
+
+    if (children == null) {
+      throw new IllegalStateException(
+          "Could not process group of type " + group.getClass().getName());
+    }
+
+    for (XmlSchemaParticle child : children) {
+      walk(child);
+    }
+
+    // 5. Notify the visitors we are exiting the group.
+    for (XmlSchemaVisitor visitor : visitors) {
+      if (all != null) {
+        visitor.onExitAllGroup(all);
+      } else if (choice != null) {
+        visitor.onExitChoiceGroup(choice);
+      } else if (seq != null) {
+        visitor.onExitSequenceGroup(seq);
+      }
+    }
+  }
+
+  /**
+   * If the provided {@link XmlSchemaElement} is a reference, track down the
+   * original and add the minimum and maximum occurrence fields.  Otherwise,
+   * just return the provided <code>element</code>.
+   *
+   * @param element The element to get the definition of.
+   * @return The real {@link XmlSchemaElement}.
+   */
+  private XmlSchemaElement getElement(
+      XmlSchemaElement element,
+      boolean isSubstitutionGroup) {
+
+    if (!element.isRef() && !isSubstitutionGroup) {
+      return element;
+    }
+
+    final QName elemQName = getElementQName(element);
+    final XmlSchema schema =
+        schemasByNamespace.get( elemQName.getNamespaceURI() );
+
+    XmlSchemaElement globalElem = null;
+    if ( !element.isRef() ) {
+      globalElem = element;
+    } else if (element.getRef().getTarget() != null) {
+      globalElem = element.getRef().getTarget();
+    } else {
+      globalElem = schema.getElementByName(elemQName);
+    }
+
+    /* An XML Schema element reference defines the id, minOccurs, and maxOccurs
+     * attributes, while the global element definition defines id and all other
+     * attributes.  This combines the two together.
+     */
+    String id = element.getId();
+    if (id == null) {
+      id = globalElem.getId();
+    }
+
+    final XmlSchemaElement copy = new XmlSchemaElement(schema, false);
+    copy.setName( globalElem.getName() );
+    copy.setAbstract( globalElem.isAbstract() );
+    copy.setAnnotation( globalElem.getAnnotation() );
+    copy.setBlock( globalElem.getBlock() );
+    copy.setDefaultValue( globalElem.getDefaultValue() );
+    copy.setFinal( globalElem.getFinal() );
+    copy.setFixedValue( globalElem.getFixedValue() );
+    copy.setForm( globalElem.getForm() );
+    copy.setId(id);
+    copy.setLineNumber( element.getLineNumber() );
+    copy.setLinePosition( element.getLinePosition() );
+    copy.setMaxOccurs( element.getMaxOccurs() );
+    copy.setMinOccurs( element.getMinOccurs() );
+    copy.setMetaInfoMap( globalElem.getMetaInfoMap() );
+    copy.setNillable( globalElem.isNillable() );
+    copy.setType( globalElem.getSchemaType() );
+    copy.setSchemaTypeName( globalElem.getSchemaTypeName() );
+    copy.setSourceURI( globalElem.getSourceURI() );
+    copy.setSubstitutionGroup( globalElem.getSubstitutionGroup() );
+    copy.setUnhandledAttributes( globalElem.getUnhandledAttributes() );
+
+    return copy;
+  }
+
+  private static QName getElementQName(XmlSchemaElement element) {
+    if ( element.isRef() ) {
+      return element.getRefBase().getTargetQName();
+    } else {
+      return element.getQName();
+    }
+  }
+}
Index: lang/java/xml/src/main/java/org/apache/avro/xml/package-info.java
===================================================================
--- lang/java/xml/src/main/java/org/apache/avro/xml/package-info.java	(revision 0)
+++ lang/java/xml/src/main/java/org/apache/avro/xml/package-info.java	(working copy)
@@ -0,0 +1,298 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * <h1>Convert XML Documents to Avro, and Back, through XML Schema</h1>
+ *
+ * <p>
+ * {@link org.apache.avro.xml.XmlDatumWriter} generates an Avro
+ * {@link org.apache.avro.Schema} from one or more XML Schemas, and
+ * will write XML Documents into Avro format using that Avro schema.
+ * </p>
+ *
+ * <p>
+ * {@link org.apache.avro.xml.XmlDatumReader} will read Avro data using an Avro
+ * schema generated by <code>XmlDatumWriter</code>, and use it to reconstruct
+ * the original XML document.  Conversion from XML to Avro is lossy (more
+ * details below), and the Avro schema generated by <code>XmlDatumWriter</code>
+ * contains the locations of the XML Schemas used to generate it.
+ * </p>
+ *
+ * <p>
+ * {@link org.apache.avro.xml.XmlDatumConfig} is used to configure
+ * <code>XmlDatumWriter</code>. The {@link java.net.URL}s and
+ * {@link java.io.File}s containing XML Schemas are defined there,
+ * as well as the root node in the XML Schema to use to generate
+ * the corresponding Avro <code>Schema</code>.
+ * </p>
+ *
+ * <h2>Avro Schema Generation</h2>
+ *
+ * <p>
+ * The following describes how an Avro Schema will be generated from an XML
+ * Schema.
+ * </p>
+ *
+ * <h3>XML Elements Map to Avro Records</h3>
+ *
+ * <p>
+ * XML elements are represented as Avro records.  Each of the element's
+ * attributes are stored as a field in the record.  The element's content is
+ * stored as a field named after the element.  If the element has simple
+ * content, that content will be stored directly.  If the element has child
+ * elements, they are stored as an array of union of those children.
+ * </p>
+ *
+ * <p>
+ * The content of empty mixed elements will be stored as a string, while the
+ * content of non-empty mixed elements will be an array of union of the child
+ * element types, along with string.
+ * </p>
+ *
+ * <p>
+ * <b>Note:</b> Unlike XML attributes, Avro fields do not have their own
+ * namespace.  This means that two attributes with the same name but different
+ * namespaces cannot co-exist in the same Avro record, and an error will be
+ * thrown when the element's record is generated.
+ * </p>
+ * <p>
+ * In addition, because the children of the element are stored in a field under
+ * the element's name, no attribute in the element can have the same name as
+ * the element itself.
+ * </p>
+ *
+ * <h3>XML Simple Type Mapping to Avro Types</h3>
+ *
+ * <p>
+ * The following is a mapping of XML Schema simple types to their Avro
+ * counterparts.  Any derived types of these XML Schema simple types will also
+ * be represented using this type.
+ * </p>
+ * 
+ * <table border="1">
+ *   <thead>
+ *     <tr>
+ *       <th>XML Schema Type</th>
+ *       <th>Avro Schema Type</th>
+ *       <th>Logical Type / Record Structure</th>
+ *     </tr>
+ *   </thead>
+ *   <tbody>
+ *     <tr>
+ *       <td><code>boolean</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.BOOLEAN}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>decimal</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.BYTES}</td>
+ *       <td>Logical Type <code>decimal</code></td>
+ *     </tr>
+ *     <tr>
+ *       <td><code>double</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.DOUBLE}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>float</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.FLOAT}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>base64</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.BYTES}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>hexBinary</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.BYTES}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>long</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.LONG}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>unsignedInt</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.LONG}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>int</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.INT}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>unsignedShort</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.INT}</td>
+ *       <td />
+ *     </tr>
+ *     <tr>
+ *       <td><code>QName</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.RECORD}</td>
+ *       <td>
+ *         <table border="1">
+ *           <thead>
+ *             <tr>
+ *               <th>Field</th>
+ *               <th>Type</th>
+ *               <th>Value</th>
+ *             </tr>
+ *           </thead>
+ *           <tbody>
+ *             <tr>
+ *               <td>namespace</td>
+ *               <td><code>string</code></td>
+ *               <td>The <code>QName</code>'s namespace</td>
+ *             </tr>
+ *             <tr>
+ *               <td>localPart</td>
+ *               <td><code>string</code></td>
+ *               <td>The <code>QName</code>'s local name.</td>
+ *             </tr>
+ *           </tbody>
+ *         </table>
+ *       </td>
+ *     </tr>
+ *     <tr>
+ *       <td><code>list</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.ARRAY}</td>
+ *       <td/>
+ *     </tr>
+ *     <tr>
+ *       <td><code>union</code></td>
+ *       <td>{@link org.apache.avro.Schema.Type.UNION}</td>
+ *       <td/>
+ *     </tr>
+ *   </tbody>
+ * </table>
+ *
+ * <h4><code>decimal</code></h4>
+ * 
+ * The <code>totalDigits</code> and <code>fractionDigits</code> facets will be
+ * used to define the <code>decimal</code>'s precision and scale, respectively.
+ * If not defined, the default precision is 34 (following the IEEE 754R
+ * Decimal128 format), and the default scale is 8.
+ *
+ * <h4><code>Enums</code></h4>
+ *
+ * If all of the <code>enumeration</code> facet values can be represented as an
+ * Avro {@link org.apache.avro.Schema.Type.ENUM}, an Avro enum will be used.
+ * Otherwise, the original type will be used instead.
+ *
+ * <h3>Avro Map Generation</h3>
+ *
+ * <p>
+ * If an element has exactly one non-optional attribute of type
+ * <code>ID</code>, an Avro {@link org.apache.avro.Schema.Type.MAP} will be
+ * generated for that element, and its direct siblings.
+ * </p>
+ *
+ * <p>
+ * If multiple differently-named children of the same element can be
+ * represented as maps, an Avro map of union of those elements will be
+ * generated instead.  However, only elements of the same name and type
+ * will exist in the same map instance.
+ * </p>
+ *
+ * <p>
+ * XML Elements will not be re-ordered in the Avro document, so if elements of
+ * the same name and type are not direct siblings, they will not co-exist in
+ * the same map.  Separate maps will be generated instead.  Consider the
+ * following:
+ * </p>
+ *
+ * <pre>
+ *   &lt;!-- In XML Schema -->
+ *   &lt;element name="map">
+ *     &lt;complexType>
+ *       &lt;simpleContent type="string" />
+ *       &lt;attribute name="id" type="ID" />
+ *     &lt;/complexType>
+ *   &lt;/element>
+ *   &lt;element name="record" type="string" />
+ *
+ *   &lt;!-- In XML Document -->
+ *   &lt;map id="id1">This is the first record in a map.&lt;/map>
+ *   &lt;map id="id2">This is the second record in the same map.&lt;/map>
+ *   &lt;record>This ends the previous map.&lt;/record>
+ *   &lt;map id="id3">This is the start of a new map.&lt;/map>
+ * </pre>
+ * 
+ * <h3>Wildcard Elements and Attributes</h3>
+ *
+ * Wildcard elements (<code>&lt;any&gt;</code>) and attributes
+ * (<code>&lt;anyAttribute&gt;</code>) do not have an equivalent concept in
+ * Avro, and likewise are skipped over.  Any elements and attributes acting
+ * as wildcards in the XML document will not appear in the Avro document.
+ *
+ * <h3>Optional Attributes and Nillable Elements</h3>
+ *
+ * Optional attributes and nillable elements will be represented as a
+ * union of null and the simple type, as per Avro's handling of optional
+ * values.  If the element or attribute was already a union, the null
+ * type will be added to that union.
+ *
+ * <h2>Generating an Avro Document From XML</h2>
+ *
+ * <p>
+ * {@link org.apache.avro.xml.XmlDatumWriter} will generate an Avro schema
+ * from one or more XML Schemas using the above specification, and write
+ * an XML {@link org.w3c.dom.Document} to an Avro {org.apache.avro.io.Encoder}
+ * accordingly.  The generated Avro <code>Schema</code> can be retrieved from
+ * {@link org.apache.avro.xml.XmlDatumWriter#getSchema()} before encoding the
+ * first XML <code>Document</code>.
+ * </p>
+ *
+ * <p>
+ * A {@link org.apache.avro.xml.XmlDatumConfig} is required to set up the
+ * <code>XmlDatumWriter</code>.  This is used to indicate where to read the
+ * XML Schemas from, and also to define the root element in the corresponding
+ * XML Documents.  (XML Schemas do not have a way to indicate what their root
+ * element is.)
+ * </p>
+ *
+ * <p>
+ * <code>XmlDatumWriter</code> will encode the
+ * {@link org.apache.avro.xml.XmlDatumConfig} in the resulting Avro
+ * <code>Schema</code>, allowing for <code>XmlDatumReader</code> to reconstruct
+ * the XML <code>Document</code> as best it can.  (Wildcard elements and
+ * attributes are lost, and will not reappear in regenerated XML Documents.)
+ * </p>
+ *
+ * <h2>Generating an XML Document From Avro</h2>
+ *
+ * <p>
+ * {@link org.apache.avro.xml.XmlDatumReader} will construct an XML
+ * {@link org.w3c.dom.Document} from an Avro schema generated by
+ * <code>XmlDatumWriter</code> and a {@link org.apache.avro.io.Decoder}.
+ * The <code>XmlDatumWriter</code>'s generated {@link org.apache.avro.Schema}
+ * is required as it contains information on how to retrieve the corresponding
+ * XML Schemas.
+ * </p>
+ *
+ * <p>
+ * However, the resulting document will not be precisely reconstructed.  Any
+ * wildcard elements and attributes were not encoded in Avro, and likewise
+ * cannot be reconstructed.  In addition, namespace prefixes will not match,
+ * as they are also not encoded in Avro.  Of course, the new prefixes will
+ * map namespaces and scopes correctly.
+ * </p>
+ */
+package org.apache.avro.xml;
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroSchemaApplier.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroSchemaApplier.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroSchemaApplier.java	(working copy)
@@ -0,0 +1,208 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+import static org.junit.Assert.*;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.SortedMap;
+
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+import javax.xml.transform.stream.StreamSource;
+
+
+import org.apache.avro.Schema;
+import org.apache.avro.xml.AvroRecordInfo;
+import org.apache.avro.xml.AvroSchemaApplier;
+import org.apache.avro.xml.AvroSchemaGenerator;
+import org.apache.avro.xml.Utils;
+import org.apache.avro.xml.XmlSchemaDocumentNode;
+import org.apache.avro.xml.XmlSchemaMultiBaseUriResolver;
+import org.apache.avro.xml.XmlSchemaPathFinder;
+import org.apache.avro.xml.XmlSchemaPathNode;
+import org.apache.avro.xml.XmlSchemaStateMachineGenerator;
+import org.apache.avro.xml.XmlSchemaStateMachineNode;
+import org.apache.avro.xml.XmlSchemaWalker;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+public class TestAvroSchemaApplier {
+
+  private static XmlSchemaStateMachineNode root;
+  private static SAXParserFactory spf;
+  private static Schema avroSchema;
+
+  private SAXParser saxParser;
+  private XmlSchemaPathFinder pathCreator;
+
+  @BeforeClass
+  public static void createStateMachine() throws FileNotFoundException {
+    File file =
+        UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+
+    ArrayList<File> schemaFiles = new ArrayList<File>(1);
+    schemaFiles.add(file);
+
+    // 1. Construct the Avro Schema
+    XmlSchemaCollection collection = null;
+    FileReader fileReader = null;
+    AvroSchemaGenerator visitor =
+        new AvroSchemaGenerator(null, null, schemaFiles);
+    try {
+      fileReader = new FileReader(file);
+
+      collection = new XmlSchemaCollection();
+      collection.setSchemaResolver(new XmlSchemaMultiBaseUriResolver());
+      collection.read(new StreamSource(fileReader, file.getAbsolutePath()));
+
+    } finally {
+      if (fileReader != null) {
+        try {
+          fileReader.close();
+        } catch (IOException ioe) {
+          ioe.printStackTrace();
+        }
+      }
+    }
+
+    XmlSchemaElement elem = getElementOf(collection, "root");
+    XmlSchemaWalker walker = new XmlSchemaWalker(collection, visitor);
+    walker.setUserRecognizedTypes( Utils.getAvroRecognizedTypes() );
+    walker.walk(elem);
+
+    avroSchema = visitor.getSchema();
+
+    visitor.clear();
+    walker.clear();
+
+    // 2. Construct the state machine.
+    XmlSchemaStateMachineGenerator generator =
+        new XmlSchemaStateMachineGenerator();
+
+    walker.removeVisitor(visitor).addVisitor(generator);
+
+    walker.walk(elem);
+
+    root = generator.getStartNode();
+
+    spf = SAXParserFactory.newInstance();
+    spf.setNamespaceAware(true);
+  }
+
+  @Before
+  public void createSaxParser() throws Exception {
+    saxParser = spf.newSAXParser();
+    pathCreator = new XmlSchemaPathFinder(root);
+  }
+
+  @Test
+  public void test() throws Exception {
+    // 1. Build the XML Document Path.
+    final File xsdFile =
+        UtilsForTests.buildFile(
+            "src",
+            "test",
+            "resources",
+            "test3_grandchildren.xml");
+
+    try {
+      saxParser.parse(xsdFile, pathCreator);
+    } catch (SAXException e) {
+      e.printStackTrace();
+      throw e;
+    }
+
+    XmlSchemaPathNode rootPath =
+        pathCreator.getXmlSchemaDocumentPath();
+
+    XmlSchemaDocumentNode<AvroRecordInfo> rootDoc = rootPath.getDocumentNode();
+
+    assertNotNull(rootPath);
+    assertNotNull(rootDoc);
+
+    // 2. Confirm the Avro Schema conforms to the XML Schema
+    AvroSchemaApplier applier = new AvroSchemaApplier(avroSchema, true);
+
+    applier.apply(rootPath);
+
+    final int numElemsProcessed = checkDoc(rootDoc);
+    assertEquals(18, numElemsProcessed);
+  }
+
+  private int checkDoc(XmlSchemaDocumentNode<AvroRecordInfo> doc) {
+    int numElemsProcessed = 0;
+    if (doc
+          .getStateMachineNode()
+          .getNodeType()
+          .equals(XmlSchemaStateMachineNode.Type.ELEMENT)) {
+      assertNotNull( doc.getUserDefinedContent() );
+
+      final AvroRecordInfo recordInfo = doc.getUserDefinedContent();
+      final Schema schema = recordInfo.getAvroSchema();
+      assertTrue(
+          schema.getType().equals(Schema.Type.RECORD)
+          || schema.getType().equals(Schema.Type.MAP));
+
+      assertEquals(
+          doc.getStateMachineNode().getElement().getName(),
+          schema.getName());
+
+      ++numElemsProcessed;
+    } else {
+      assertNull( doc.getUserDefinedContent() );
+    }
+
+    for (int iter = 1; iter <= doc.getIteration(); ++iter) {
+      final SortedMap<Integer, XmlSchemaDocumentNode<AvroRecordInfo>>
+        children = doc.getChildren(iter);
+
+      if (children != null) {
+        for (Map.Entry<Integer, XmlSchemaDocumentNode<AvroRecordInfo>> child :
+              children.entrySet()) {
+          numElemsProcessed += checkDoc(child.getValue());
+        }
+      }
+    }
+    return numElemsProcessed;
+  }
+
+  private static XmlSchemaElement getElementOf(
+      XmlSchemaCollection collection,
+      String name) {
+
+    XmlSchemaElement elem = null;
+    for (XmlSchema schema : collection.getXmlSchemas()) {
+      elem = schema.getElementByName(name);
+      if (elem != null) {
+        break;
+      }
+    }
+    return elem;
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroSchemaGenerator.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroSchemaGenerator.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroSchemaGenerator.java	(working copy)
@@ -0,0 +1,942 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.avro.Schema;
+import org.apache.avro.xml.AvroSchemaGenerator;
+import org.apache.avro.xml.Utils;
+import org.apache.avro.xml.XmlSchemaMultiBaseUriResolver;
+import org.apache.avro.xml.XmlSchemaWalker;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.junit.Test;
+
+/**
+ * Verifies the {@link AvroSchemaGenerator} generates the expected
+ * {@link Schema} for <code>src/test/resources/test_schema.xsd</code>.
+ */
+public class TestAvroSchemaGenerator {
+
+  @Test
+  public void testSchema() throws Exception {
+    File file =
+        UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+    ArrayList<File> schemaFiles = new ArrayList<File>(1);
+    schemaFiles.add(file);
+
+    Schema schema = createSchemaOf(file, "root");
+
+    UtilsForTests.assertEquivalent(getExpectedTestSchema(), schema);
+  }
+
+  @Test
+  public void testComplexSchema() throws Exception {
+    File file =
+        UtilsForTests.buildFile(
+            "src",
+            "test",
+            "resources",
+            "complex_schema.xsd");
+
+    Schema schema = createSchemaOf(file, "root");
+
+    UtilsForTests.assertEquivalent(getExpectedComplexSchema(), schema);
+  }
+
+  private static Schema createSchemaOf(File file, String rootName) throws Exception {
+    ArrayList<File> schemaFiles = new ArrayList<File>(1);
+    schemaFiles.add(file);
+
+    XmlSchemaCollection collection = null;
+    FileReader fileReader = null;
+    AvroSchemaGenerator visitor =
+        new AvroSchemaGenerator(null, null, schemaFiles);
+    try {
+      fileReader = new FileReader(file);
+
+      collection = new XmlSchemaCollection();
+      collection.setSchemaResolver(new XmlSchemaMultiBaseUriResolver());
+      collection.read(new StreamSource(fileReader, file.getAbsolutePath()));
+
+    } finally {
+      if (fileReader != null) {
+        try {
+          fileReader.close();
+        } catch (IOException ioe) {
+          ioe.printStackTrace();
+        }
+      }
+    }
+
+    XmlSchemaElement elem = getElementOf(collection, rootName);
+    XmlSchemaWalker walker = new XmlSchemaWalker(collection, visitor);
+    walker.setUserRecognizedTypes( Utils.getAvroRecognizedTypes() );
+    walker.walk(elem);
+
+    Schema schema = visitor.getSchema();
+
+    visitor.clear();
+    walker.clear();
+
+    return schema;
+  }
+
+  private static XmlSchemaElement getElementOf(
+      XmlSchemaCollection collection,
+      String name) {
+
+    XmlSchemaElement elem = null;
+    for (XmlSchema schema : collection.getXmlSchemas()) {
+      elem = schema.getElementByName(name);
+      if (elem != null) {
+        break;
+      }
+    }
+    return elem;
+  }
+
+  private static Schema getExpectedTestSchema() {
+    final String namespace = "org.apache.avro.AvroTest";
+
+    Schema optionalStringSchema = getOptionalStringSchema();
+
+    List<Schema> optionalStringArrayTypes = new ArrayList<Schema>(2);
+    optionalStringArrayTypes.add(
+        Schema.createArray(Schema.create(Schema.Type.STRING)));
+    optionalStringArrayTypes.add( Schema.create(Schema.Type.NULL) );
+    Schema optionalStringArraySchema =
+        Schema.createUnion(optionalStringArrayTypes);
+
+    Schema optionalDoubleSchema = getOptionalDoubleSchema();
+
+    List<Schema> optionalLongTypes = new ArrayList<Schema>(2);
+    optionalLongTypes.add( Schema.create(Schema.Type.LONG) );
+    optionalLongTypes.add( Schema.create(Schema.Type.NULL) );
+    Schema optionalLongSchema = Schema.createUnion(optionalLongTypes);
+
+    Schema optionalIntSchema = getOptionalIntSchema();
+
+    Schema optionalBooleanSchema = getOptionalBooleanSchema();
+
+    Schema optionalBinarySchema = getOptionalBinarySchema();
+
+    List<Schema> optionalFloatTypes = new ArrayList<Schema>(2);
+    optionalFloatTypes.add( Schema.create(Schema.Type.FLOAT) );
+    optionalFloatTypes.add( Schema.create(Schema.Type.NULL) );
+    Schema optionalFloatSchema = Schema.createUnion(optionalFloatTypes);
+
+    List<Schema> optionalQNameTypes = new ArrayList<Schema>(2);
+    optionalQNameTypes.add( getQNameSchema() );
+    optionalQNameTypes.add(Schema.create(Schema.Type.NULL));
+    Schema optionalQNameSchema = Schema.createUnion(optionalQNameTypes);
+
+    List<Schema.Field> rootFields = new ArrayList<Schema.Field>();
+    rootFields.add(
+        new Schema.Field("anySimpleType", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("duration", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("dateTime", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("date", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("time", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("gYearMonth", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("gYear", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("gMonthDay", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("gDay", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("gMonth", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("anyURI", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("qname", optionalQNameSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("string", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("token", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("language", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("nmtoken", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("name", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("ncName", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("id", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("idref", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("entity", optionalStringSchema, null, null) );
+    rootFields.add(
+        new Schema.Field("nmtokens", optionalStringArraySchema, null, null));
+    rootFields.add(
+        new Schema.Field("idrefs", optionalStringArraySchema, null, null));
+    rootFields.add(
+        new Schema.Field("entities", optionalStringArraySchema, null, null));
+    rootFields.add(
+        new Schema.Field("integer", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("negativeInteger", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("positiveInteger", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("unsignedLong", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("long", optionalLongSchema, null, null));
+    rootFields.add(
+        new Schema.Field("unsignedInt", optionalLongSchema, null, null));
+    rootFields.add(
+        new Schema.Field("int", optionalIntSchema, null, null));
+    rootFields.add(
+        new Schema.Field("short", optionalIntSchema, null, null));
+    rootFields.add(
+        new Schema.Field("byte", optionalIntSchema, null, null));
+    rootFields.add(
+        new Schema.Field("unsignedShort", optionalIntSchema, null, null));
+    rootFields.add(
+        new Schema.Field("unsignedByte", optionalIntSchema, null, null));
+    rootFields.add(
+        new Schema.Field("boolean", optionalBooleanSchema, null, null));
+    rootFields.add(
+        new Schema.Field("base64Binary", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("hexBinary", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("decimal", optionalBinarySchema, null, null));
+    rootFields.add(
+        new Schema.Field("float", optionalFloatSchema, null, null));
+    rootFields.add(
+        new Schema.Field("double", optionalDoubleSchema, null, null));
+
+    rootFields.add(
+        new Schema.Field(
+            "normalizedString",
+            optionalStringSchema,
+            null,
+            null) );
+
+    rootFields.add(
+        new Schema.Field(
+            "nonPositiveInteger",
+            optionalBinarySchema,
+            null,
+            null));
+
+    rootFields.add(
+        new Schema.Field(
+            "nonNegativeInteger",
+            optionalBinarySchema,
+            null,
+            null));
+
+    ArrayList<String> nonNullPrimitiveEnumSymbols = new ArrayList<String>();
+    nonNullPrimitiveEnumSymbols.add("boolean");
+    nonNullPrimitiveEnumSymbols.add("int");
+    nonNullPrimitiveEnumSymbols.add("long");
+    nonNullPrimitiveEnumSymbols.add("float");
+    nonNullPrimitiveEnumSymbols.add("double");
+    nonNullPrimitiveEnumSymbols.add("decimal");
+    nonNullPrimitiveEnumSymbols.add("bytes");
+    nonNullPrimitiveEnumSymbols.add("string");
+
+    Schema nonNullPrimitiveEnumSchema =
+        Schema.createEnum(
+            "nonNullPrimitive",
+            "Enumeration of symbols in "
+            + "{http://avro.apache.org/AvroTest}nonNullPrimitive",
+            namespace + ".enums",
+            nonNullPrimitiveEnumSymbols);
+
+    Schema.Field nonNullPrimitiveEnumField =
+        new Schema.Field(
+            "nonNullPrimitive",
+            nonNullPrimitiveEnumSchema,
+            "Simple type {http://www.w3.org/2001/XMLSchema}anyType",
+            null);
+
+    Schema nonNullPrimitiveRecord =
+        Schema.createRecord(
+            "nonNullPrimitive",
+            null,
+            namespace,
+            false);
+
+    List<Schema.Field> nonNullPrimitiveFields = new ArrayList<Schema.Field>();
+    nonNullPrimitiveFields.add(nonNullPrimitiveEnumField);
+    nonNullPrimitiveRecord.setFields(nonNullPrimitiveFields);
+
+    ArrayList<String> primitiveEnumSymbols =
+        (ArrayList<String>) nonNullPrimitiveEnumSymbols.clone();
+    primitiveEnumSymbols.add("null");
+
+    Schema primitiveEnumSchema =
+        Schema.createEnum(
+            "primitive",
+            "Enumeration of symbols in "
+            + "{http://avro.apache.org/AvroTest}primitive",
+            namespace + ".enums",
+            primitiveEnumSymbols);
+
+    Schema.Field primitiveEnumField =
+        new Schema.Field(
+            "primitive",
+            primitiveEnumSchema,
+            "Simple type {http://www.w3.org/2001/XMLSchema}anyType",
+            null);
+
+    Schema primitiveRecord =
+        Schema.createRecord(
+            "primitive",
+            null,
+            namespace,
+            false);
+
+    ArrayList<Schema.Field> primitiveFields = new ArrayList<Schema.Field>(1);
+    primitiveFields.add(primitiveEnumField);
+    primitiveRecord.setFields(primitiveFields);
+
+    Schema recordSchema =
+        Schema.createRecord("record", null, namespace, false);
+
+    Schema mapRecordSchema =
+        Schema.createRecord("map", null, namespace, false);
+
+    Schema mapSchema =
+        Schema.createMap(mapRecordSchema);
+
+    Schema listSchema =
+        Schema.createRecord("list", null, namespace, false);
+
+    List<Schema> listChildren =
+        new ArrayList<Schema>();
+    listChildren.add(recordSchema);
+    listChildren.add(mapSchema);
+    listChildren.add(primitiveRecord);
+
+    Schema listChildSchema =
+        Schema.createArray(Schema.createUnion(listChildren));
+
+    List<Schema.Field> listFields = new ArrayList<Schema.Field>();
+    listFields.add(
+        new Schema.Field(
+            "list",
+            listChildSchema,
+            "Children of {http://avro.apache.org/AvroTest}list",
+            null));
+    listFields.add(
+        new Schema.Field("size", optionalBinarySchema, null, null));
+
+    listSchema.setFields(listFields);
+
+    Schema tupleSchema =
+        Schema.createRecord("tuple", null, namespace, false);
+
+    List<Schema> tupleChildren =
+        new ArrayList<Schema>();
+    tupleChildren.add(primitiveRecord);
+    tupleChildren.add(nonNullPrimitiveRecord);
+    tupleChildren.add(recordSchema);
+    tupleChildren.add(mapSchema);
+    tupleChildren.add(listSchema);
+
+    Schema tupleChildSchema =
+        Schema.createArray(Schema.createUnion(tupleChildren));
+
+    List<Schema.Field> tupleChildrenFields =
+        new ArrayList<Schema.Field>();
+
+    tupleChildrenFields.add(
+        new Schema.Field(
+            "tuple",
+            tupleChildSchema,
+            "Children of {http://avro.apache.org/AvroTest}tuple",
+            null));
+
+    tupleSchema.setFields(tupleChildrenFields);
+
+    List<Schema> recordChildSchemas = new ArrayList<Schema>();
+    recordChildSchemas.add(primitiveRecord);
+    recordChildSchemas.add(nonNullPrimitiveRecord);
+    recordChildSchemas.add(recordSchema);
+    recordChildSchemas.add(listSchema);
+    recordChildSchemas.add(tupleSchema);
+    recordChildSchemas.add(mapSchema);
+
+    Schema recordChildSchema =
+        Schema.createArray(Schema.createUnion(recordChildSchemas));
+
+    ArrayList<Schema.Field> recordFields = new ArrayList<Schema.Field>(); 
+    recordFields.add(
+        new Schema.Field(
+            "record",
+            recordChildSchema,
+            "Children of {http://avro.apache.org/AvroTest}record",
+            null));
+
+    recordSchema.setFields(recordFields);
+
+    List<Schema> mapChildSchemas = new ArrayList<Schema>();
+    mapChildSchemas.add(primitiveRecord);
+    mapChildSchemas.add(nonNullPrimitiveRecord);
+    mapChildSchemas.add(recordSchema);
+    mapChildSchemas.add(listSchema);
+    mapChildSchemas.add(tupleSchema);
+    mapChildSchemas.add(mapSchema);
+
+    Schema mapChildSchema =
+        Schema.createArray(Schema.createUnion(mapChildSchemas));
+
+    List<Schema.Field> mapFields = new ArrayList<Schema.Field>();
+    mapFields.add(
+        new Schema.Field(
+            "mapId",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    mapFields.add(
+        new Schema.Field(
+            "map",
+            mapChildSchema,
+            "Children of {http://avro.apache.org/AvroTest}map",
+            null));
+
+    mapRecordSchema.setFields(mapFields);
+
+    Schema rootChildSchema =
+        Schema.createArray(Schema.createUnion(mapChildSchemas));
+
+    rootFields.add(
+        new Schema.Field(
+            "root",
+            rootChildSchema,
+            "Children of {http://avro.apache.org/AvroTest}root",
+            null) );
+
+    Schema rootSchema = Schema.createRecord("root", null, namespace, false);
+    rootSchema.setFields(rootFields);
+
+    return rootSchema;
+  }
+
+  private static Schema getExpectedComplexSchema() {
+    final String namespace = "avro.complex_schema";
+
+    Schema firstMapValue =
+        Schema.createRecord("value", null, namespace, false);
+
+    // simpleRestriction
+    List<Schema.Field> simpleRestrictionFields = new ArrayList<Schema.Field>();
+    simpleRestrictionFields.add(
+        new Schema.Field(
+            "default",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    simpleRestrictionFields.add(
+        new Schema.Field(
+            "fixed",
+            Schema.create(Schema.Type.INT),
+            null,
+            null));
+
+    List<Schema> simpleRestrictionTypes = new ArrayList<Schema>(2);
+    simpleRestrictionTypes.add( Schema.create(Schema.Type.BOOLEAN) );
+    simpleRestrictionTypes.add( Schema.create(Schema.Type.BYTES) );
+
+    simpleRestrictionFields.add(
+        new Schema.Field(
+            "simpleRestriction",
+            Schema.createUnion(simpleRestrictionTypes),
+            "Simple type null",
+            null));
+
+    Schema simpleRestrictionSchema =
+        Schema.createRecord("simpleRestriction", null, namespace, false);
+    simpleRestrictionSchema.setFields(simpleRestrictionFields);
+
+    // simpleExtension
+    List<Schema.Field> simpleExtensionFields = new ArrayList<Schema.Field>();
+    simpleExtensionFields.add(
+        new Schema.Field(
+            "default",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    simpleExtensionFields.add(
+        new Schema.Field(
+            "fixed",
+            Schema.create(Schema.Type.INT),
+            null,
+            null));
+
+    List<Schema> simpleExtensionTypes = new ArrayList<Schema>();
+    simpleExtensionTypes.add( Schema.create(Schema.Type.BOOLEAN) );
+    simpleExtensionTypes.add( Schema.create(Schema.Type.BYTES) );
+
+    simpleExtensionFields.add(
+        new Schema.Field(
+            "simpleExtension",
+            Schema.createUnion(simpleExtensionTypes),
+            "Simple type null",
+            null));
+
+    Schema simpleExtensionSchema =
+        Schema.createRecord("simpleExtension", null, namespace, false);
+    simpleExtensionSchema.setFields(simpleExtensionFields);
+
+    // anyAndFriends
+    List<Schema.Field> anyAndFriendsFields = new ArrayList<Schema.Field>();
+    anyAndFriendsFields.add(
+        new Schema.Field(
+            "anyAndFriends",
+            Schema.create(Schema.Type.STRING),
+            "Simple type null",
+            null));
+
+    Schema anyAndFriendsSchema =
+        Schema.createRecord("anyAndFriends", null, namespace, false);
+    anyAndFriendsSchema.setFields(anyAndFriendsFields);
+
+    // prohibit and children
+    List<Schema.Field> fixedSchemaFields = new ArrayList<Schema.Field>();
+    fixedSchemaFields.add(
+        new Schema.Field(
+            "fixed",
+            Schema.create(Schema.Type.BYTES),
+            "Simple type {http://www.w3.org/2001/XMLSchema}decimal",
+            null));
+
+    Schema fixedSchema = Schema.createRecord("fixed", null, namespace, false);
+    fixedSchema.setFields(fixedSchemaFields);
+
+    List<Schema.Field> prohibitFields = new ArrayList<Schema.Field>();
+    prohibitFields.add(
+        new Schema.Field(
+            "prohibit",
+            Schema.createArray(
+                Schema.createUnion(
+                    Collections.singletonList(fixedSchema))),
+            "Children of {urn:avro:complex_schema}prohibit",
+            null));
+
+    Schema prohibitSchema =
+        Schema.createRecord("prohibit", null, namespace, false);
+    prohibitSchema.setFields(prohibitFields);
+
+    // allTheThings and children
+    List<Schema.Field> firstMapValueFields = new ArrayList<Schema.Field>();
+    firstMapValueFields.add(
+        new Schema.Field(
+            "value",
+            getOptionalBinarySchema(),
+            "Simple type {http://www.w3.org/2001/XMLSchema}decimal",
+            null));
+
+        firstMapValue.setFields(firstMapValueFields);
+
+    List<Schema> firstMapChildren = new ArrayList<Schema>();
+    firstMapChildren.add(firstMapValue);
+
+    List<Schema.Field> firstMapFields = new ArrayList<Schema.Field>();
+    firstMapFields.add(
+        new Schema.Field(
+            "firstMap",
+            Schema.createArray(Schema.createUnion(firstMapChildren)),
+            "Children of {urn:avro:complex_schema}firstMap",
+            null));
+
+    firstMapFields.add(
+        new Schema.Field("id", Schema.create(Schema.Type.STRING), null, null));
+
+    Schema firstMapRecord =
+        Schema.createRecord(
+            "firstMap",
+            null,
+            namespace,
+            false);
+    firstMapRecord.setFields(firstMapFields);
+
+    List<Schema.Field> secondMapFields = new ArrayList<Schema.Field>();
+    secondMapFields.add(
+        new Schema.Field("id", Schema.create(Schema.Type.STRING), null, null));
+    secondMapFields.add(
+        new Schema.Field(
+            "value",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+    secondMapFields.add(
+        new Schema.Field(
+            "secondMap",
+            Schema.create(Schema.Type.NULL),
+            "This element contains no attributes and no children.",
+            null));
+
+    Schema secondMapRecord =
+        Schema.createRecord("secondMap", null, namespace, false);
+    secondMapRecord.setFields(secondMapFields);
+
+    List<Schema> unionOfMaps = new ArrayList<Schema>();
+    unionOfMaps.add(firstMapRecord);
+    unionOfMaps.add(secondMapRecord);
+
+    Schema mapUnionOfMaps =
+        Schema.createMap( Schema.createUnion(unionOfMaps) );
+
+    List<Schema.Field> allTheThingsFields = new ArrayList<Schema.Field>();
+    allTheThingsFields.add(
+        new Schema.Field(
+            "id",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    allTheThingsFields.add(
+        new Schema.Field(
+            "truth",
+            Schema.create(Schema.Type.BOOLEAN),
+            null,
+            null));
+
+    List<Schema> listOfNumbersTypes = new ArrayList<Schema>(2);
+    listOfNumbersTypes.add( Schema.create(Schema.Type.INT) );
+    listOfNumbersTypes.add( Schema.create(Schema.Type.BYTES) );
+    Schema listOfNumbersSchema =
+        Schema.createArray(Schema.createUnion(listOfNumbersTypes));
+
+    allTheThingsFields.add(
+        new Schema.Field(
+            "listOfNumbers",
+            listOfNumbersSchema,
+            null,
+            null));
+
+    allTheThingsFields.add(
+        new Schema.Field(
+            "allTheThings",
+            Schema.createArray(
+                Schema.createUnion(
+                    Collections.singletonList(mapUnionOfMaps))),
+            "Children of {urn:avro:complex_schema}allTheThings",
+            null));
+
+    Schema allTheThingsRecord =
+        Schema.createRecord("allTheThings", null, namespace, false);
+    allTheThingsRecord.setFields(allTheThingsFields);
+
+    Schema allTheThingsSchema =
+        Schema.createMap(allTheThingsRecord);
+
+    // Backtrack and children
+    List<String> avroEnumSymbols = new ArrayList<String>(6);
+    avroEnumSymbols.add("avro");
+    avroEnumSymbols.add("json");
+    avroEnumSymbols.add("xml");
+    avroEnumSymbols.add("thrift");
+    avroEnumSymbols.add("rest_li");
+    avroEnumSymbols.add("protobuf");
+
+    Schema avroEnumSchema =
+        Schema.createEnum(
+            "avroEnum",
+            "Enumeration of symbols in {urn:avro:complex_schema}avroEnum",
+            namespace + ".enums",
+            avroEnumSymbols);
+
+    Schema avroEnumRecord =
+        Schema.createRecord(
+            "avroEnum",
+            null,
+            namespace,
+            false);
+
+    ArrayList<Schema.Field> avroEnumFields = new ArrayList<Schema.Field>();
+    avroEnumFields.add(
+        new Schema.Field(
+            "avroEnum",
+            avroEnumSchema,
+            "Simple type {http://www.w3.org/2001/XMLSchema}anyType",
+            null));
+    avroEnumRecord.setFields(avroEnumFields);
+
+    Schema xmlEnumRecord =
+        Schema.createRecord("xmlEnum", null, namespace, false);
+
+    List<Schema.Field> xmlEnumFields = new ArrayList<Schema.Field>();
+    xmlEnumFields.add(
+        new Schema.Field(
+            "xmlEnum",
+            Schema.create(Schema.Type.STRING),
+            "Simple type {http://www.w3.org/2001/XMLSchema}anyType",
+            null));
+
+    xmlEnumRecord.setFields(xmlEnumFields);
+
+    Schema unsignedLongList =
+        Schema.createRecord("unsignedLongList", null, namespace, false);
+
+    List<Schema.Field> unsignedLongListFields = new ArrayList<Schema.Field>();
+    unsignedLongListFields.add(
+        new Schema.Field(
+            "unsignedLongList",
+            Schema.createArray(Schema.create(Schema.Type.BYTES)),
+            "Simple type null",
+            null));
+    unsignedLongList.setFields(unsignedLongListFields);
+
+    Schema listOfUnion =
+        Schema.createRecord("listOfUnion", null, namespace, false);
+
+    List<Schema> listOfUnionTypes = new ArrayList<Schema>();
+    listOfUnionTypes.add( Schema.create(Schema.Type.BYTES) );
+    listOfUnionTypes.add( Schema.create(Schema.Type.BOOLEAN) );
+    listOfUnionTypes.add( Schema.create(Schema.Type.INT) );
+    listOfUnionTypes.add( Schema.create(Schema.Type.STRING) );
+
+    List<Schema.Field> listOfUnionFields = new ArrayList<Schema.Field>();
+    listOfUnionFields.add(
+        new Schema.Field(
+            "listOfUnion",
+            Schema.createArray( Schema.createUnion(listOfUnionTypes) ),
+            "Simple type null",
+            null));
+    listOfUnion.setFields(listOfUnionFields);
+
+    List<Schema.Field> qNameFields = new ArrayList<Schema.Field>();
+    qNameFields.add(
+        new Schema.Field(
+            "qName",
+            getQNameSchema(),
+            "Simple type {http://www.w3.org/2001/XMLSchema}QName",
+            null));
+    Schema qNameSchema =
+        Schema.createRecord("qName", null, namespace, false);
+    qNameSchema.setFields(qNameFields);
+
+    Schema backtrackSchema =
+        Schema.createRecord(
+            "backtrack",
+            " This forces backtracking through the different schema options. "
+            + "Consider the following elements: <backtrack> "
+            + "<qName>avro:qName</qName> <avroEnum>avro</avroEnum> "
+            + "<xmlEnum>rest.li</xmlEnum> <xmlEnum>xml</xmlEnum> "
+            + "<unsignedLongList>18446744073709551615 1844674407370955 "
+            + "12579</unsignedLongList> <listOfUnion>true 18446744073709551616"
+            + " false -2147483648 -1234.567 avro</listOfUnion> </backtrack> "
+            + "The first four elements in the list can match either the first "
+            + "choice group or the second sequence group, and by default the "
+            + "first branch will be taken. It is not until the last child "
+            + "element, <listOfUnion>, is reached, that it becomes clear the "
+            + "choice group should not be followed. ",
+            namespace,
+            false);
+
+    List<Schema> backtrackChildren = new ArrayList<Schema>();
+    backtrackChildren.add(qNameSchema);
+    backtrackChildren.add(avroEnumRecord);
+    backtrackChildren.add(xmlEnumRecord);
+    backtrackChildren.add(unsignedLongList);
+    backtrackChildren.add(listOfUnion);
+
+    List<Schema.Field> backtrackFields = new ArrayList<Schema.Field>();
+    backtrackFields.add(
+        new Schema.Field(
+            "backtrack",
+            Schema.createArray(Schema.createUnion(backtrackChildren)),
+            "Children of {urn:avro:complex_schema}backtrack",
+            null) );
+
+    backtrackSchema.setFields(backtrackFields);
+
+    // complexExtension
+    List<Schema.Field> complexExtensionFields = new ArrayList<Schema.Field>();
+
+    complexExtensionFields.add(
+        new Schema.Field("optional", getOptionalStringSchema(), null, null));
+
+    complexExtensionFields.add(
+        new Schema.Field(
+            "defaulted",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    List<Schema> complexExtensionChildren = new ArrayList<Schema>(3);
+    complexExtensionChildren.add(unsignedLongList);
+    complexExtensionChildren.add(listOfUnion);
+    complexExtensionChildren.add(fixedSchema);
+
+    complexExtensionFields.add(
+        new Schema.Field(
+            "complexExtension",
+            Schema.createArray(Schema.createUnion(complexExtensionChildren)),
+            "Children of {urn:avro:complex_schema}complexExtension",
+            null));
+
+    Schema complexExtensionSchema =
+        Schema.createRecord("complexExtension", null, namespace, false);
+    complexExtensionSchema.setFields(complexExtensionFields);
+
+    // mixedType
+    List<Schema> mixedTypeTypes = new ArrayList<Schema>();
+    mixedTypeTypes.add( Schema.create(Schema.Type.STRING) );
+    mixedTypeTypes.add(listOfUnion);
+    mixedTypeTypes.add(unsignedLongList);
+
+    List<Schema.Field> mixedTypeFields = new ArrayList<Schema.Field>();
+    mixedTypeFields.add(
+        new Schema.Field(
+            "mixedType",
+            Schema.createArray(Schema.createUnion(mixedTypeTypes)),
+            "Children of {urn:avro:complex_schema}mixedType",
+            null));
+
+    Schema mixedTypeSchema =
+        Schema.createRecord("mixedType", null, namespace, false);
+    mixedTypeSchema.setFields(mixedTypeFields);
+
+    // realRoot
+    Schema realRootSchema =
+        Schema.createRecord("realRoot", null, namespace, false);
+
+    List<Schema.Field> realRootSchemaFields = new ArrayList<Schema.Field>();
+    realRootSchemaFields.add(
+        new Schema.Field(
+            "month",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    realRootSchemaFields.add(
+        new Schema.Field(
+          "year",
+          Schema.create(Schema.Type.STRING),
+          null,
+          null));
+
+    realRootSchemaFields.add(
+        new Schema.Field(
+            "day",
+            Schema.create(Schema.Type.STRING),
+            null,
+            null));
+
+    List<Schema> realRootChildren = new ArrayList<Schema>();
+    realRootChildren.add(backtrackSchema);
+    realRootChildren.add(allTheThingsSchema);
+    realRootChildren.add(prohibitSchema);
+    realRootChildren.add(anyAndFriendsSchema);
+    realRootChildren.add(simpleExtensionSchema);
+    realRootChildren.add(simpleRestrictionSchema);
+    realRootChildren.add(complexExtensionSchema);
+    realRootChildren.add(mixedTypeSchema);
+
+    realRootSchemaFields.add(
+        new Schema.Field(
+            "realRoot",
+            Schema.createArray(Schema.createUnion(realRootChildren)),
+            "Children of {urn:avro:complex_schema}realRoot",
+            null));
+
+    realRootSchema.setFields(realRootSchemaFields);
+
+    return Schema.createUnion( Collections.singletonList(realRootSchema));
+  }
+
+  private static Schema getOptionalStringSchema() {
+    List<Schema> optionalStringTypes = new ArrayList<Schema>(2);
+    optionalStringTypes.add( Schema.create(Schema.Type.STRING) );
+    optionalStringTypes.add( Schema.create(Schema.Type.NULL) );
+    return Schema.createUnion(optionalStringTypes);
+  }
+
+  private static Schema getQNameSchema() {
+    Schema qNameSchema =
+        Schema.createRecord(
+            "qName",
+            "Qualified Name",
+            "org.w3.www.2001.XMLSchema",
+            false);
+
+    List<Schema.Field> qNameFields = new ArrayList<Schema.Field>(2);
+    qNameFields.add(
+        new Schema.Field(
+            "namespace",
+            Schema.create(Schema.Type.STRING),
+            "The namespace of this qualified name.",
+            null));
+    qNameFields.add(
+        new Schema.Field(
+            "localPart",
+            Schema.create(Schema.Type.STRING),
+            "The local part of this qualified name.",
+            null));
+    qNameSchema.setFields(qNameFields);
+
+    return qNameSchema;
+  }
+
+  private static Schema getOptionalDoubleSchema() {
+    List<Schema> optionalDoubleTypes = new ArrayList<Schema>(2);
+    optionalDoubleTypes.add( Schema.create(Schema.Type.DOUBLE) );
+    optionalDoubleTypes.add( Schema.create(Schema.Type.NULL) );
+    return Schema.createUnion(optionalDoubleTypes);
+  }
+
+  private static Schema getOptionalBooleanSchema() {
+    List<Schema> optionalBooleanTypes = new ArrayList<Schema>(2);
+    optionalBooleanTypes.add( Schema.create(Schema.Type.BOOLEAN) );
+    optionalBooleanTypes.add( Schema.create(Schema.Type.NULL) );
+    return Schema.createUnion(optionalBooleanTypes);
+  }
+
+  private static Schema getOptionalIntSchema() {
+    List<Schema> optionalIntTypes = new ArrayList<Schema>(2);
+    optionalIntTypes.add( Schema.create(Schema.Type.INT) );
+    optionalIntTypes.add( Schema.create(Schema.Type.NULL) );
+    return Schema.createUnion(optionalIntTypes);
+  }
+
+  private static Schema getOptionalBinarySchema() {
+    List<Schema> optionalBinaryTypes = new ArrayList<Schema>(2);
+    optionalBinaryTypes.add( Schema.create(Schema.Type.BYTES) );
+    optionalBinaryTypes.add( Schema.create(Schema.Type.NULL) );
+    return Schema.createUnion(optionalBinaryTypes);
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroToXmlAndBack.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroToXmlAndBack.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestAvroToXmlAndBack.java	(working copy)
@@ -0,0 +1,208 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+
+import javax.xml.namespace.QName;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import org.apache.avro.Schema;
+import org.apache.avro.io.DecoderFactory;
+import org.apache.avro.io.EncoderFactory;
+import org.apache.avro.io.JsonDecoder;
+import org.apache.avro.io.JsonEncoder;
+import org.apache.avro.xml.XmlDatumConfig;
+import org.apache.avro.xml.XmlDatumReader;
+import org.apache.avro.xml.XmlDatumWriter;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.w3c.dom.Document;
+
+/**
+ * Tests converting an XML document to an Avro datum and back.
+ */
+public class TestAvroToXmlAndBack {
+
+  private static DocumentBuilderFactory dbf;
+  private static EncoderFactory avroEncoderFactory;
+  private static DecoderFactory avroDecoderFactory;
+
+  private DocumentBuilder docBuilder;
+
+  /**
+   * @throws java.lang.Exception
+   */
+  @BeforeClass
+  public static void setUpBeforeClass() throws Exception {
+    dbf = DocumentBuilderFactory.newInstance();
+    dbf.setNamespaceAware(true);
+
+    avroEncoderFactory = EncoderFactory.get();
+    avroDecoderFactory = DecoderFactory.get();
+  }
+
+  /**
+   * @throws java.lang.Exception
+   */
+  @Before
+  public void setUp() throws Exception {
+    docBuilder = dbf.newDocumentBuilder();
+  }
+
+  @Test
+  public void testRoot() throws Exception {
+    final QName root = new QName("http://avro.apache.org/AvroTest", "root");
+
+    final File schemaFile =
+        UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+
+    final File xmlFile =
+        UtilsForTests.buildFile("src", "test", "resources", "test1_root.xml");
+
+    final XmlDatumConfig config =
+        new XmlDatumConfig(
+            schemaFile,
+            "http://avro.apache.org/AvroTest",
+            root);
+
+    runTest(config, xmlFile);
+  }
+
+  @Test
+  public void testChildren() throws Exception {
+    final QName root = new QName("http://avro.apache.org/AvroTest", "root");
+    final File schemaFile =
+        UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+
+    final File xmlFile =
+        UtilsForTests.buildFile("src",
+                                "test",
+                                "resources",
+                                "test2_children.xml");
+
+    final XmlDatumConfig config =
+        new XmlDatumConfig(
+            schemaFile,
+            "http://avro.apache.org/AvroTest",
+            root);
+
+    runTest(config, xmlFile);
+  }
+
+  @Test
+  public void testGrandchildren() throws Exception {
+    final QName root = new QName("http://avro.apache.org/AvroTest", "root");
+
+    final File schemaFile =
+        UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+
+    final File xmlFile =
+        UtilsForTests.buildFile("src",
+                                "test",
+                                "resources",
+                                "test3_grandchildren.xml");
+
+    final XmlDatumConfig config =
+        new XmlDatumConfig(
+            schemaFile,
+            "http://avro.apache.org/AvroTest",
+            root);
+
+    runTest(config, xmlFile);
+  }
+
+  @Test
+  public void testComplex() throws Exception {
+    final QName root = new QName("urn:avro:complex_schema", "root");
+    final File complexSchemaFile =
+        UtilsForTests.buildFile("src",
+                                "test",
+                                "resources",
+                                "complex_schema.xsd");
+
+    final File testSchemaFile =
+        UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+
+    final File xmlFile = 
+        UtilsForTests.buildFile("src",
+                                "test",
+                                "resources",
+                                "complex_test1.xml");
+
+    final XmlDatumConfig config =
+        new XmlDatumConfig(complexSchemaFile, "urn:avro:complex_schema", root);
+    config.addSchemaFile(testSchemaFile);
+
+    final Document xmlDoc = docBuilder.parse(xmlFile);
+
+    final Document outDoc = convertToAvroAndBack(config, xmlDoc);
+
+    final File expectedXml =
+        UtilsForTests.buildFile("src",
+                                "test",
+                                "resources",
+                                "complex_test1_out.xml");
+
+    final Document expectedDoc = docBuilder.parse(expectedXml);
+
+    UtilsForTests.assertEquivalent(expectedDoc, outDoc);
+  }
+
+  private static Document convertToAvroAndBack(
+      XmlDatumConfig config,
+      Document xmlDoc) throws Exception {
+
+    final XmlDatumWriter writer = new XmlDatumWriter(config);
+    final Schema xmlToAvroSchema = writer.getSchema();
+
+    final ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+
+    final JsonEncoder encoder =
+        avroEncoderFactory.jsonEncoder(xmlToAvroSchema, outStream, true);
+
+    writer.write(xmlDoc, encoder);
+
+    encoder.flush();
+
+    final ByteArrayInputStream inStream =
+        new ByteArrayInputStream( outStream.toByteArray() );
+
+    final JsonDecoder decoder =
+        avroDecoderFactory.jsonDecoder(xmlToAvroSchema, inStream);
+
+    final XmlDatumReader reader = new XmlDatumReader();
+    reader.setSchema(xmlToAvroSchema);
+
+    return reader.read(null, decoder);
+  }
+
+  private void runTest(XmlDatumConfig config, File xmlFile) throws Exception {
+
+    final Document xmlDoc = docBuilder.parse(xmlFile);
+
+    final Document outDoc = convertToAvroAndBack(config, xmlDoc);
+
+    UtilsForTests.assertEquivalent(xmlDoc, outDoc);
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestDomBuilderFromSax.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestDomBuilderFromSax.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestDomBuilderFromSax.java	(working copy)
@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.io.FileReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.avro.xml.DomBuilderFromSax;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.w3c.dom.Document;
+
+public class TestDomBuilderFromSax {
+
+  private static final File TEST_SCHEMA =
+      UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+
+  private static SAXParserFactory spf;
+  private static DocumentBuilderFactory dbf;
+
+  private SAXParser saxParser;
+  private DocumentBuilder domParser;
+
+  @BeforeClass
+  public static void setUpFactories() {
+    dbf = DocumentBuilderFactory.newInstance();
+    dbf.setNamespaceAware(true);
+
+    spf = SAXParserFactory.newInstance();
+    spf.setNamespaceAware(true);
+  }
+
+  @Before
+  public void setUpTest() throws Exception {
+    saxParser = spf.newSAXParser();
+    domParser = dbf.newDocumentBuilder();
+  }
+
+  @Test
+  public void testRoot() throws Exception {
+    runTest(
+        TEST_SCHEMA,
+        UtilsForTests.buildFile("src", "test", "resources", "test1_root.xml"));
+  }
+
+  @Test
+  public void testChildren() throws Exception {
+    runTest(
+        TEST_SCHEMA,
+        UtilsForTests.buildFile(
+            "src",
+            "test",
+            "resources",
+            "test2_children.xml"));
+  }
+
+  @Test
+  public void testGrandchildren() throws Exception {
+    runTest(
+        TEST_SCHEMA,
+        UtilsForTests.buildFile(
+            "src",
+            "test",
+            "resources",
+            "test3_grandchildren.xml"));
+  }
+
+  private void runTest(File schemaFile, File xmlFile) throws Exception {
+    XmlSchemaCollection xmlSchemas = new XmlSchemaCollection();
+
+    FileReader schemaFileReader = new FileReader(schemaFile);
+
+    StreamSource schemaSource =
+        new StreamSource(schemaFileReader, schemaFile.getName());
+    xmlSchemas.read(schemaSource);
+
+    schemaFileReader.close();
+
+    // Parse the document using a real DOM parser
+    final Document expectedDoc = domParser.parse(xmlFile);
+
+    // Parse the document using a SAX parser
+    DomBuilderFromSax builder = new DomBuilderFromSax(xmlSchemas);
+    saxParser.parse(xmlFile, builder);
+
+    final Document actualDoc = builder.getDocument();
+
+    UtilsForTests.assertEquivalent(expectedDoc, actualDoc);
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestSaxWalkerOverDom.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestSaxWalkerOverDom.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestSaxWalkerOverDom.java	(working copy)
@@ -0,0 +1,539 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+import org.w3c.dom.Document;
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
+
+import org.apache.avro.xml.SaxWalkerOverDom;
+import org.junit.Test;
+
+/**
+ * Reads the <code>src/test/resources/test_schema.xsd</code>
+ * file as an XML document and confirms the correct events
+ * are triggered.
+ */
+public class TestSaxWalkerOverDom {
+
+  private static class AttrInfo {
+
+    static List<AttrInfo> getAttributesOf(Attributes attrs) {
+      ArrayList<AttrInfo> newAttrs = new ArrayList<AttrInfo>();
+
+      for (int a = 0; a < attrs.getLength(); ++a) {
+        newAttrs.add(
+            new AttrInfo(
+                attrs.getURI(a),
+                attrs.getLocalName(a),
+                attrs.getQName(a),
+                attrs.getValue(a)) );
+      }
+
+      return newAttrs;
+    }
+
+    AttrInfo(String ns, String ln, String qn, String v) {
+      namespace = new String(ns);
+      localName = new String(ln);
+      qName = new String(qn);
+      value = new String(v);
+    }
+
+    private String namespace;
+    private String localName;
+    private String qName;
+    private String value;
+  }
+
+  private static class StackEntry {
+    enum Type {
+      ELEMENT,
+      TEXT
+    }
+
+    StackEntry(String v) {
+      type = Type.TEXT;
+      value = v;
+      namespace = null;
+      localName = null;
+      qName = null;
+      attributes = null;
+    }
+
+    StackEntry(String ns, String ln, String qn, Attributes attrs) {
+      type = Type.ELEMENT;
+      namespace = ns;
+      localName = ln;
+      qName = qn;
+      attributes = AttrInfo.getAttributesOf(attrs);
+      value = null;
+    }
+
+    boolean equals(String v) {
+      return stringsEqual(value, v);
+    }
+
+    boolean equals(String ns, String ln, String qn, Attributes attrs) {
+      if (!stringsEqual(namespace, ns)
+          || !stringsEqual(localName, ln)
+          || !stringsEqual(qName, qn)
+          || (attributes.size() > attrs.getLength()))
+      {
+        throw new IllegalStateException(
+            "Expected element [\""
+            + namespace
+            + "\", \""
+            + localName
+            + "\", \""
+            + qName
+            + "\", "
+            + attributes.size()
+            + " attrs] does not match actual of [\""
+            + ns
+            + "\", \""
+            + ln
+            + "\", \""
+            + qn
+            + "\", "
+            + attrs.getLength()
+            + " attrs].");
+      }
+
+      for (int index = 0; index < attributes.size(); ++index) {
+        AttrInfo attribute = attributes.get(index);
+        final String actual = attrs.getValue(attribute.qName);
+
+        if ( !attribute.value.equals(actual) ) {
+          return false;
+        }
+
+        if (!attrs
+               .getValue(attribute.namespace, attribute.localName)
+               .equals(actual) ) {
+          System.err.println(
+              "Attribute [\""
+              + attribute.namespace
+              + "\", \""
+              + attribute.localName
+              + "\"] has a value of \""
+              + attribute.value
+              + "\" which does not match the actual value of \""
+              + actual
+              + "\".  ");
+          return false;
+        }
+      }
+
+      return true;
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder str = new StringBuilder(type.name());
+      str.append(": ");
+
+      if (type.equals(Type.ELEMENT)) {
+        str.append("namespace=\"").append(namespace);
+        str.append("\", localName=\"").append(localName);
+        str.append("\", qName=\"").append(qName);
+        str.append("\", attributes={ ");
+
+        if (attributes != null) {
+          for (int index = 0; index < attributes.size(); ++index) {
+            AttrInfo attribute = attributes.get(index);
+            str.append("[Attr: namespace=\"").append(attribute.namespace);
+            str.append("\", localName=\"").append(attribute.localName);
+            str.append("\", qName=\"").append( attribute.qName);
+            str.append("\", value=\"").append( attribute.value).append("\"] ");
+          }
+        }
+
+        str.append('}');
+
+      } else if (type.equals(Type.TEXT)) {
+        str.append('\"').append(value).append('\"');
+      }
+
+      return str.toString();
+    }
+
+    private static boolean stringsEqual(String lhs, String rhs) {
+      if (((lhs != null) && (rhs != null) && lhs.equals(rhs))
+          || ((lhs == null) && (rhs == null))) {
+
+        return true;
+
+      } else {
+        throw new IllegalArgumentException(
+            "\""
+            + lhs
+            + "\" does not match \""
+            + rhs
+            + "\"");
+      }
+    }
+
+    Type type;
+    String namespace;
+    String localName;
+    String qName;
+    String value;
+    List<AttrInfo> attributes;
+  }
+
+  /**
+   * Used to confirm the {@link SaxWalkerOverDom} walker generates
+   * the exact same events as a real {@link SAXParser}.
+   */
+  private static class ContentValidator implements ContentHandler {
+
+    ContentValidator(
+        List<StackEntry> stack,
+        Map<String, List<String>> prefixMappings) {
+
+      this.stack = stack;
+      this.prefixMappings = prefixMappings;
+    }
+
+    @Override
+    public void startDocument() throws SAXException { }
+
+    @Override
+    public void endDocument() throws SAXException {
+      if ( !stack.isEmpty() ) {
+        throw new SAXException(
+            "Reaced the end of the document early; expected "
+            + stack.size()
+            + " more elements.");
+      }
+    }
+
+    @Override
+    public void startElement(
+        String uri,
+        String localName,
+        String qName,
+        Attributes atts) throws SAXException {
+
+      if ( stack.isEmpty() ) {
+        throw new SAXException(
+            "Element "
+            + toString(uri, localName, qName, atts)
+            + " is not expected; stack is empty!");
+      }
+
+      StackEntry entry = stack.remove(0);
+
+      if (entry.type != StackEntry.Type.ELEMENT) {
+        throw new SAXException(
+            "Expected text of ("
+            + entry
+            + ") but received element of ("
+            + toString(uri, localName, qName, atts)
+            + ").");
+      }
+
+      if ( !entry.equals(uri, localName, qName, atts) ) {
+        throw new SAXException(
+            "Expected element ("
+            + entry
+            + ") does not match actual ("
+            + toString(uri, localName, qName, atts)
+            + ").");
+      }
+    }
+
+    @Override
+    public void endElement(
+        String uri,
+        String localName,
+        String qName)
+        throws SAXException
+    {
+    }
+
+    @Override
+    public void characters(
+        char[] ch,
+        int start,
+        int length)
+        throws SAXException {
+
+      final String value = toString(ch, start, length);
+
+      if ( stack.isEmpty() ) {
+        throw new SAXException(
+            "Unexpected string \"" + value + "\"; stack is empty!");
+      }
+
+      StackEntry entry = stack.remove(0);
+
+      if (!entry.type.equals(StackEntry.Type.TEXT)) {
+        throw new SAXException(
+            "Unexpected string \""
+            + value
+            + "\"; was expecting element ("
+            + entry
+            + ").");
+      }
+
+      if ( !entry.equals(value) ) {
+        throw new SAXException(
+            "Expected string \""
+            + entry
+            + "\" but received \""
+            + value
+            + "\".");
+      }
+    }
+
+    @Override
+    public void startPrefixMapping(String prefix, String uri)
+        throws SAXException {
+
+      if ( !prefixMappings.containsKey(prefix) ) {
+        throw new SAXException(
+            "Prefix \""
+            + prefix
+            + "\" and URI \""
+            + uri
+            + "\" are not expected.");
+      }
+
+      /* This is a quick and dirty test; in reality the prefix-to-namespace
+       * mapping is only valid if it exists inside the current scope.  That
+       * said, keeping track of the scope is a much more difficult problem.
+       */
+      final List<String> namespaces = prefixMappings.get(prefix);
+      boolean found = false;
+      for (String namespace : namespaces) {
+        if (namespace.equals(uri)) {
+          found = true;
+          break;
+        }
+      }
+      if (!found) {
+        throw new SAXException(
+            "Prefix \""
+            + prefix
+            + "\" does not have a namespace of \""
+            + uri
+            + "\".");
+      }
+    }
+
+    @Override
+    public void endPrefixMapping(String prefix) throws SAXException {
+      if ( !prefixMappings.containsKey(prefix) ) {
+        throw new SAXException("Prefix \"" + prefix + "\" is not expected.");
+      }
+    }
+
+    @Override
+    public void setDocumentLocator(Locator locator) {
+      throw new UnsupportedOperationException("This should not be called.");
+    }
+
+    @Override
+    public void ignorableWhitespace(char[] ch, int start, int length)
+        throws SAXException {
+      throw new UnsupportedOperationException("This should not be called.");
+    }
+
+    @Override
+    public void processingInstruction(String target, String data)
+        throws SAXException {
+      throw new UnsupportedOperationException("This should not be called.");
+    }
+
+    @Override
+    public void skippedEntity(String name) throws SAXException {
+      throw new UnsupportedOperationException("This should not be called.");
+    }
+
+    private static String toString(
+        String uri, String localName, String qName, Attributes attrs) {
+
+      StringBuilder str = new StringBuilder("namespace=\"");
+      str.append(uri).append("\", localName=\"").append(localName);
+      str.append("\", qName=\"").append(qName).append("\", attributes={ ");
+
+      for (int index = 0; index < attrs.getLength(); ++index) {
+        str.append("[Attr: namespace=\"").append( attrs.getURI(index) );
+        str.append("\", localName=\"").append( attrs.getLocalName(index) );
+        str.append("\", qName=\"").append( attrs.getQName(index) );
+        str.append("\", value=\"").append( attrs.getValue(index) );
+        str.append("\"] ");
+      }
+
+      str.append('}');
+
+      return str.toString();
+    }
+
+    private static String toString(char[] ch, int start, int length) {
+      return new String(ch, start, length);
+    }
+
+    private List<StackEntry> stack;
+    private Map<String, List<String>> prefixMappings;
+  }
+
+  /**
+   * This is traversed by a SAX parser to retrieve the expected SAX events.
+   */
+  private static class StackBuilder extends DefaultHandler {
+
+    public StackBuilder() {
+      stack = new ArrayList<StackEntry>();
+      prefixMappings = new HashMap<String, List<String>>();
+    }
+
+    public ArrayList<StackEntry> getStack() {
+      return stack;
+    }
+
+    public Map<String, List<String>> getPrefixMappings() {
+      return prefixMappings;
+    }
+
+    @Override
+    public void startDocument() throws SAXException {
+      stack.clear();
+    }
+
+    @Override
+    public void startElement(
+        String uri,
+        String localName,
+        String qName,
+        Attributes atts) throws SAXException {
+
+      stack.add( new StackEntry(uri, localName, qName, atts) );
+    }
+
+    @Override
+    public void characters(
+        char[] ch,
+        int start,
+        int length)
+        throws SAXException {
+
+      stack.add( new StackEntry( new String(ch, start, length) ) );
+    }
+
+    @Override
+    public void startPrefixMapping(String prefix, String uri)
+        throws SAXException {
+
+      List<String> mappings = prefixMappings.get(prefix);
+      if (mappings == null) {
+        mappings = new ArrayList<String>(1);
+        prefixMappings.put(prefix, mappings);
+      }
+      mappings.add(uri);
+    }
+
+    private final ArrayList<StackEntry> stack;
+    private final Map<String, List<String>> prefixMappings;
+  }
+
+  @Test
+  public void testRoot() throws Exception {
+    final File xmlFile =
+        UtilsForTests.buildFile("src", "test", "resources", "test1_root.xml");
+    runTest(xmlFile);
+  }
+
+  @Test
+  public void testChildren() throws Exception {
+    final File xmlFile =
+        UtilsForTests.buildFile(
+            "src",
+            "test",
+            "resources",
+            "test2_children.xml");
+
+    runTest(xmlFile);
+  }
+
+  @Test
+  public void testGrandchildren() throws Exception {
+    final File xmlFile =
+        UtilsForTests.buildFile(
+            "src",
+            "test",
+            "resources",
+            "test3_grandchildren.xml");
+
+    runTest(xmlFile);
+  }
+
+  private static void runTest(File xmlFile) throws Exception {
+    StackBuilder stackBuilder = new StackBuilder();
+
+    // Parse the document using a real SAX parser
+    SAXParserFactory spf = SAXParserFactory.newInstance();
+    spf.setNamespaceAware(true);
+    SAXParser saxParser = spf.newSAXParser();
+    saxParser.parse(xmlFile, stackBuilder);
+
+    // Parse the document using a DOM parser
+    final DocumentBuilderFactory dbFactory =
+        DocumentBuilderFactory.newInstance();
+    dbFactory.setNamespaceAware(true);
+    final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
+    final Document doc = dBuilder.parse(xmlFile);
+
+    /* Walk the DOM, firing off SAX events, and
+     * confirm they match the real SAX events.
+     */
+    final List<StackEntry> stack = stackBuilder.getStack();
+    final int stackSize = stack.size();
+
+    final SaxWalkerOverDom walker =
+        new SaxWalkerOverDom(
+            new ContentValidator(stack, stackBuilder.getPrefixMappings()));
+
+    try {
+      walker.walk(doc);
+    } catch (Exception e) {
+      throw new RuntimeException(
+          "Traversed through element "
+          + (stackSize - stack.size())
+          + " before failing.",
+          e);
+    }
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestSchemaWalker.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestSchemaWalker.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestSchemaWalker.java	(working copy)
@@ -0,0 +1,968 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.transform.stream.StreamSource;
+
+import org.junit.Assert;
+
+import org.apache.avro.xml.XmlSchemaBaseSimpleType;
+import org.apache.avro.xml.XmlSchemaMultiBaseUriResolver;
+import org.apache.avro.xml.XmlSchemaRestriction;
+import org.apache.avro.xml.XmlSchemaTypeInfo;
+import org.apache.avro.xml.XmlSchemaVisitor;
+import org.apache.avro.xml.XmlSchemaWalker;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaAll;
+import org.apache.ws.commons.schema.XmlSchemaAny;
+import org.apache.ws.commons.schema.XmlSchemaAnyAttribute;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaChoice;
+import org.apache.ws.commons.schema.XmlSchemaCollection;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaFractionDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaParticle;
+import org.apache.ws.commons.schema.XmlSchemaPatternFacet;
+import org.apache.ws.commons.schema.XmlSchemaSequence;
+import org.apache.ws.commons.schema.XmlSchemaUse;
+import org.apache.ws.commons.schema.XmlSchemaWhiteSpaceFacet;
+import org.junit.Test;
+
+public class TestSchemaWalker {
+
+  private static enum Type {
+    ELEMENT,
+    SEQUENCE,
+    CHOICE,
+    ALL,
+    SUBSTITUTION_GROUP
+  }
+
+  private static class StackEntry {
+    StackEntry(Type type) {
+      this.type = type;
+      this.name = null;
+      this.typeName = null;
+      this.facets = null;
+      this.baseType = null;
+      this.minOccurs = 1;
+      this.maxOccurs = 1;
+    }
+
+    StackEntry(Type type, long minOccurs, long maxOccurs) {
+      this(type);
+      this.minOccurs = minOccurs;
+      this.maxOccurs = maxOccurs;
+    }
+
+    StackEntry(Type type, String name) {
+      this(type);
+      this.name = name;
+      this.typeName = null;
+    }
+
+    StackEntry(Type type, String name, String typeName) {
+      this(type, name);
+      this.typeName = typeName;
+    }
+
+    StackEntry(
+        Type type,
+        String name,
+        String typeName,
+        XmlSchemaBaseSimpleType baseType) {
+
+      this(type, name, typeName);
+      this.baseType = baseType;
+    }
+
+    StackEntry(
+        Type type,
+        String name,
+        String typeName,
+        long minOccurs,
+        long maxOccurs) {
+
+      this(type, name, typeName);
+      this.minOccurs = minOccurs;
+      this.maxOccurs = maxOccurs;
+    }
+
+    StackEntry(
+        Type type,
+        String name,
+        String typeName,
+        XmlSchemaBaseSimpleType baseType,
+        long minOccurs,
+        long maxOccurs) {
+
+      this(type, name, typeName, baseType);
+      this.minOccurs = minOccurs;
+      this.maxOccurs = maxOccurs;
+    }
+
+    StackEntry(
+        Type type,
+        String name,
+        String typeName,
+        XmlSchemaBaseSimpleType baseType,
+        Set<XmlSchemaRestriction> facets) {
+
+      this(type, name, typeName, baseType);
+      this.facets = facets;
+    }
+
+    StackEntry(
+        Type type,
+        String name,
+        String typeName,
+        XmlSchemaBaseSimpleType baseType,
+        long minOccurs,
+        long maxOccurs,
+        Set<XmlSchemaRestriction> facets) {
+
+      this(type, name, typeName, baseType, minOccurs, maxOccurs);
+      this.facets = facets;
+      
+    }
+
+    Type type;
+    String name;
+    String typeName;
+    Set<XmlSchemaRestriction> facets;
+    long minOccurs;
+    long maxOccurs;
+    XmlSchemaBaseSimpleType baseType;
+  }
+
+  private static class Attribute {
+    public Attribute(
+        String name,
+        String typeName,
+        XmlSchemaTypeInfo.Type type,
+        XmlSchemaBaseSimpleType baseType) {
+
+      this.name = name;
+      this.typeName = typeName;
+      this.isOptional = false;
+      this.type = type;
+      this.baseType = baseType;
+    }
+
+    public Attribute(
+        String name,
+        String typeName,
+        XmlSchemaTypeInfo.Type type,
+        XmlSchemaBaseSimpleType baseType,
+        boolean isOptional) {
+
+      this(name, typeName, type, baseType);
+      this.isOptional = isOptional;
+    }
+
+    public Attribute(
+        String name,
+        String typeName,
+        XmlSchemaTypeInfo.Type type,
+        XmlSchemaBaseSimpleType baseType,
+        Set<XmlSchemaRestriction> facets) {
+
+      this(name, typeName, type, baseType);
+      this.facets = facets;
+    }
+
+    public Attribute(
+        String name,
+        String typeName,
+        XmlSchemaTypeInfo.Type type,
+        XmlSchemaBaseSimpleType baseType,
+        boolean isOptional,
+        Set<XmlSchemaRestriction> facets) {
+
+      this(name, typeName, type, baseType, isOptional);
+      this.facets = facets;
+    }
+
+    String name;
+    String typeName;
+    boolean isOptional;
+    Set<XmlSchemaRestriction> facets;
+    XmlSchemaBaseSimpleType baseType;
+    XmlSchemaTypeInfo.Type type;
+  }
+
+  private static class Visitor implements XmlSchemaVisitor {
+
+    Visitor(
+        List<StackEntry> stack,
+        HashMap<String, List<Attribute>> attributes) {
+
+      this.stack = stack;
+      this.attributes = attributes;
+    }
+
+    @Override
+    public void onEnterElement(
+        XmlSchemaElement element,
+        XmlSchemaTypeInfo typeInfo,
+        boolean previouslyVisited) {
+
+      StackEntry next = pop();
+      if (next.type != Type.ELEMENT) {
+        throw new IllegalStateException(
+            "Expected a "
+            + next.type
+            + " named \""
+            + next.name
+            + "\" but received an element named \""
+            + element.getName() + "\".");
+
+      } else if (!next.name.equals( element.getName() )) {
+        throw new IllegalStateException(
+            "Expected an element named \""
+            + next.name
+            + "\" but received an element named "
+            + element.getName()
+            + "\"");
+
+      } else if ((next.typeName == null)
+                 && !element.getSchemaType().isAnonymous()) {
+
+        throw new IllegalStateException(
+            "Expected the element named \""
+            + next.name
+            + "\" to carry an anonymous type, but the type was "
+            + element.getSchemaType().getQName());
+
+      } else if ((next.typeName != null)
+                 && element.getSchemaType().isAnonymous()) {
+        throw new IllegalStateException(
+            "Expected the element named \""
+            + next.name
+            + "\" to carry a type named \""
+            + next.typeName
+            + "\"; but the type was anonymous instead.");
+      }
+
+      checkMinAndMaxOccurs(next, element);
+
+      if (typeInfo != null) {
+        checkFacets(next.name, typeInfo, next.facets);
+
+        if ((next.baseType == null)
+            && (typeInfo.getBaseType() != null)
+            && !typeInfo
+                  .getBaseType()
+                  .equals(XmlSchemaBaseSimpleType.ANYTYPE)) {
+
+          throw new IllegalStateException(
+              "Element \""
+              + next.name
+              + "\" was not expected to have an Avro schema,"
+              + " but has a schema of "
+              + typeInfo.getBaseType());
+
+        } else if ((next.baseType != null)
+                   && (typeInfo.getBaseType() == null)) {
+
+          throw new IllegalStateException(
+              "Element \""
+              + next.name
+              + "\" was expected to have a schema of "
+              + next.baseType
+              + " but instead has no schema.");
+
+        } else if ((next.baseType != null)
+                   && !next.baseType.equals(typeInfo.getBaseType())) {
+          throw new IllegalStateException(
+              "Element \""
+              + next.name
+              + "\" was expected to have a schema of "
+              + next.baseType
+              + " but instead has a schema of "
+              + typeInfo.getBaseType());
+        }
+
+      } else if (next.baseType != null) {
+        throw new IllegalStateException(
+            "Expected a schema of "
+            + next.baseType
+            + " but received none.");
+      }
+
+      if ((next.facets != null) && !next.facets.isEmpty()) {
+        StringBuilder errMsg = new StringBuilder("Element \"");
+        errMsg.append(next.name);
+        errMsg.append("\" was expected to have the following facets, ");
+        errMsg.append("but did not:");
+
+        for (XmlSchemaRestriction facet : next.facets) {
+          errMsg.append(" \"").append(facet).append('\"');
+        }
+
+        throw new IllegalStateException( errMsg.toString() );
+      }
+    }
+
+    @Override
+    public void onExitElement(
+        XmlSchemaElement element,
+        XmlSchemaTypeInfo typeInfo,
+        boolean previouslyVisited) {
+
+      if (!previouslyVisited && attributes.containsKey( element.getName() )) {
+        List<Attribute> remainingAttrs = attributes.get( element.getName() );
+        if ( !remainingAttrs.isEmpty() ) {
+          StringBuilder errMsg = new StringBuilder("Element \"");
+          errMsg.append( element.getName() );
+          errMsg.append("\" did not have the expected attributes ");
+          errMsg.append("of the following names:");
+          for (Attribute attr : remainingAttrs) {
+            errMsg.append(" \"").append( attr.name ).append('\"');
+          }
+          throw new IllegalStateException( errMsg.toString() );
+        }
+      }
+    }
+
+    @Override
+    public void onVisitAttribute(
+        XmlSchemaElement element,
+        XmlSchemaAttribute attribute,
+        XmlSchemaTypeInfo attributeType) {
+
+      if ( !attributes.containsKey( element.getName() ) ) {
+        throw new IllegalStateException(
+            "No attributes were expected for \""
+            + element.getName()
+            + "\", but \""
+            + attribute.getQName()
+            + "\" was found.");
+      }
+
+      List<Attribute> attrs = attributes.get( element.getName() );
+      boolean found = false;
+      int index = 0;
+
+      for (; index < attrs.size(); ++index) {
+        Attribute attr = attrs.get(index);
+        if ( attr.name.equals( attribute.getName() ) ) {
+          if ((attr.typeName == null)
+              && !attribute.getSchemaType().isAnonymous()) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" whose type was expected to be anonymous, "
+                + "but actually is named \""
+                + attribute.getSchemaType().getName()
+                + "\"");
+
+          } else if ((attr.typeName != null)
+                     && attribute.getSchemaType().isAnonymous()) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" whose type was expected to be \""
+                + attr.typeName
+                + "\"; but is anonymous instead.");
+
+          } else if ((attr.typeName != null)
+                     && !attr.typeName.equals(
+                         attribute.getSchemaType().getName())) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\"; its type was expected to be \""
+                + attr.typeName
+                + "\" but instead was \""
+                + attribute.getSchemaType().getName()
+                + "\"");
+
+          } else if (attr.isOptional
+                     && !attribute.getUse().equals(XmlSchemaUse.OPTIONAL)) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" whose usage was expected to be optional, but instead is "
+                + attribute.getUse());
+
+          } else if (!attr.isOptional
+                     && attribute.getUse().equals(XmlSchemaUse.OPTIONAL)) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" whose usage was expected to be required,"
+                + " but is actually optional.");
+
+          } else if (!attr.type.equals(attributeType.getType())) {
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" whose type was expected to be "
+                + attr.type
+                + " but actually was "
+                + attributeType.getType());
+
+          } else if (attr.type.equals(XmlSchemaTypeInfo.Type.ATOMIC)
+                     && !attr.baseType.equals(attributeType.getBaseType())) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" whose type was expected to be "
+                + attr.baseType.name()
+                + " but actually was "
+                + attributeType.getBaseType());
+
+          } else if (attr.type.equals(XmlSchemaTypeInfo.Type.LIST)
+                     && !attr.baseType.equals(
+                         attributeType.getChildTypes().get(0).getBaseType())) {
+
+            throw new IllegalStateException(
+                "Element \""
+                + element.getName()
+                + "\" has an attribute named \""
+                + attr.name
+                + "\" with a type of "
+                + attr.type
+                + " whose base type is expected to be "
+                + attr.baseType
+                + " but actually is "
+                + attributeType.getChildTypes().get(0).getBaseType());
+
+          } else {
+
+            checkFacets(attr.name, attributeType, attr.facets);
+
+            found = true;
+            break;
+          }
+        }
+      }
+
+      if (found) {
+        attrs.remove(index);
+      } else {
+        throw new IllegalStateException(
+            "Element \""
+            + element.getName()
+            + "\" has unexpected attribute \""
+            + attribute.getName()
+            + "\"");
+      }
+    }
+
+    @Override
+    public void onEndAttributes(
+        XmlSchemaElement element,
+        XmlSchemaTypeInfo elemTypeInfo) {
+      
+    }
+
+    @Override
+    public void onEnterSubstitutionGroup(XmlSchemaElement base) {
+      StackEntry next = pop();
+
+      if (next.type != Type.SUBSTITUTION_GROUP) {
+        throw new IllegalStateException(
+            "Expected a "
+            + next.type
+            + " but instead found a substition group of \""
+            + base.getName()
+            + "\"");
+
+      } else if (!next.name.equals( base.getName() )) {
+        throw new IllegalStateException(
+            "Expected a substitution group for element \""
+            + next.name
+            + "\", but instead received one for \""
+            + base.getName()
+            + "\"");
+
+      } else if (next.minOccurs != base.getMinOccurs()) {
+        throw new IllegalStateException(
+            "Expected a substitution group for element \""
+            + next.name
+            + "\" and min occurs of "
+            + next.minOccurs
+            + ", but received a min occurs of "
+            + base.getMinOccurs());
+
+      } else if (next.maxOccurs != base.getMaxOccurs()) {
+        throw new IllegalStateException(
+            "Expected a substitution group for element \""
+            + next.name
+            + "\" and max occurs of "
+            + next.maxOccurs
+            + ", but received a max occurs of "
+            + base.getMaxOccurs());
+      }
+    }
+
+    @Override
+    public void onExitSubstitutionGroup(XmlSchemaElement base) { }
+
+    @Override
+    public void onEnterAllGroup(XmlSchemaAll all) {
+      StackEntry next = pop();
+      if (next.type != Type.ALL) {
+        throw new IllegalStateException(
+            "Expected a " + next.type + " but received an All group.");
+      }
+      checkMinAndMaxOccurs(next, all);
+    }
+
+    @Override
+    public void onExitAllGroup(XmlSchemaAll all) { }
+
+    @Override
+    public void onEnterChoiceGroup(XmlSchemaChoice choice) {
+      StackEntry next = pop();
+      if (next.type != Type.CHOICE) {
+        throw new IllegalStateException(
+            "Expected a " + next.type + " but received a Choice group.");
+      }
+      checkMinAndMaxOccurs(next, choice);
+    }
+
+    @Override
+    public void onExitChoiceGroup(XmlSchemaChoice choice) { }
+
+    @Override
+    public void onEnterSequenceGroup(XmlSchemaSequence seq) {
+      StackEntry next = pop();
+      if (next.type != Type.SEQUENCE) {
+        throw new IllegalStateException(
+            "Expected a " + next.type + " but received a Sequence group.");
+      }
+      checkMinAndMaxOccurs(next, seq);
+    }
+
+    @Override
+    public void onExitSequenceGroup(XmlSchemaSequence seq) { }
+
+    @Override
+    public void onVisitAny(XmlSchemaAny any) {
+      throw new IllegalStateException(
+          "No Any types were expected in the schema.");
+    }
+
+    @Override
+    public void onVisitAnyAttribute(XmlSchemaElement element,
+        XmlSchemaAnyAttribute anyAttr) {
+
+      throw new IllegalStateException(
+          "No anyAttribute types were expected in the schema.");
+    }
+
+    private static void checkMinAndMaxOccurs(
+        StackEntry next,
+        XmlSchemaParticle particle) {
+
+      if (next.minOccurs != particle.getMinOccurs()) {
+        throw new IllegalStateException(
+            "Expected a minOccurs of "
+            + next.minOccurs
+            + " for "
+            + next.type
+            + " \""
+            + next.name
+            + "\", but found a minOccurs of "
+            + particle.getMinOccurs());
+
+      } else if (next.maxOccurs != particle.getMaxOccurs()) {
+        throw new IllegalStateException(
+            "Expected a maxOccurs of "
+            + next.maxOccurs
+            + " for "
+            + next.type
+            + " \""
+            + next.name
+            + "\", but found a maxOccurs of "
+            + particle.getMaxOccurs());
+      }
+    }
+
+    private StackEntry pop() {
+      if ( stack.isEmpty() ) {
+        throw new IllegalStateException("Ran out of stack!");
+      }
+
+      StackEntry entry = stack.get(0);
+      stack.remove(entry);
+      return entry;
+    }
+
+    private List<StackEntry> stack;
+    private HashMap<String, List<Attribute>> attributes;
+  }
+
+  /**
+   * Test for src/main/resources/test_schema.xsd
+   */
+  @Test
+  public void test() throws Exception {
+    // Build the expectations.
+    ArrayList<Attribute> attrGroupAttrs = new ArrayList<Attribute>(43);
+    
+    attrGroupAttrs.add(
+        new Attribute(
+            "anySimpleType",
+            "anySimpleType",
+            XmlSchemaTypeInfo.Type.ATOMIC,
+            XmlSchemaBaseSimpleType.ANYSIMPLETYPE,
+            true));
+
+    HashSet<XmlSchemaRestriction> whiteSpaceCollapseFixedRestrictions =
+        new HashSet<XmlSchemaRestriction>();
+
+    whiteSpaceCollapseFixedRestrictions.add(
+        new XmlSchemaRestriction(
+            new XmlSchemaWhiteSpaceFacet("collapse", true)) );
+
+    attrGroupAttrs.add( new Attribute("duration",     "duration",     XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DURATION,   true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("dateTime",     "dateTime",     XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DATETIME,   true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("date",         "date",         XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DATE,       true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("time",         "time",         XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.TIME,       true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("gYearMonth",   "gYearMonth",   XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.YEARMONTH,  true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("gYear",        "gYear",        XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.YEAR,       true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("gDay",         "gDay",         XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DAY,        true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("gMonth",       "gMonth",       XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.MONTH,      true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("gMonthDay",    "gMonthDay",    XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.MONTHDAY,   true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("boolean",      "boolean",      XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.BOOLEAN,    true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("base64Binary", "base64Binary", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.BIN_BASE64, true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("hexBinary",    "hexBinary",    XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.BIN_HEX,    true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("float",        "float",        XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.FLOAT,      true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("double",       "double",       XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DOUBLE,     true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("anyURI",       "anyURI",       XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.ANYURI,     true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+    attrGroupAttrs.add( new Attribute("qname",        "QName",        XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.QNAME,      true, (Set<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone()) );
+
+    HashSet<XmlSchemaRestriction> decimalFacets = (HashSet<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone();
+    decimalFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.DIGITS_FRACTION, new Integer(0), false) );
+
+    attrGroupAttrs.add( new Attribute("decimal",      null,      XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL,    true, decimalFacets) );
+
+
+    HashSet<XmlSchemaRestriction> integerFacets = (HashSet<XmlSchemaRestriction>) whiteSpaceCollapseFixedRestrictions.clone();
+    integerFacets.add( new XmlSchemaRestriction(new XmlSchemaFractionDigitsFacet(new Integer(0), true)));
+    integerFacets.add( new XmlSchemaRestriction(new XmlSchemaPatternFacet("[\\-+]?[0-9]+", false)));
+    attrGroupAttrs.add( new Attribute("integer", "integer", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, integerFacets) );
+
+    HashSet<XmlSchemaRestriction> nonPositiveIntegerFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    nonPositiveIntegerFacets.add( new XmlSchemaRestriction(new XmlSchemaMaxInclusiveFacet(new Integer(0), false)) );
+    attrGroupAttrs.add( new Attribute("nonPositiveInteger", "nonPositiveInteger", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, nonPositiveIntegerFacets) );
+
+    HashSet<XmlSchemaRestriction> negativeIntegerFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    negativeIntegerFacets.add( new XmlSchemaRestriction(new XmlSchemaMaxInclusiveFacet(new Integer(-1), false)) );
+    attrGroupAttrs.add( new Attribute("negativeInteger", "negativeInteger", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, negativeIntegerFacets) );
+
+    HashSet<XmlSchemaRestriction> longFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    longFacets.add( new XmlSchemaRestriction(new XmlSchemaMinInclusiveFacet(new Long(-9223372036854775808L), false)) );
+    longFacets.add( new XmlSchemaRestriction(new XmlSchemaMaxInclusiveFacet(new Long( 9223372036854775807L), false)) );
+    attrGroupAttrs.add( new Attribute("long", "long", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, longFacets) );
+
+    HashSet<XmlSchemaRestriction> intFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    intFacets.add( new XmlSchemaRestriction( new XmlSchemaMinInclusiveFacet(new Integer(-2147483648), false) ) );
+    intFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(2147483647, false) ) );
+    attrGroupAttrs.add( new Attribute("int", "int", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, intFacets) );
+
+    HashSet<XmlSchemaRestriction> shortFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    shortFacets.add( new XmlSchemaRestriction( new XmlSchemaMinInclusiveFacet(new Short((short) -32768), false) ) );
+    shortFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(new Short((short)  32767), false) ) );
+    attrGroupAttrs.add( new Attribute("short", "short", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, shortFacets) );
+
+    HashSet<XmlSchemaRestriction> byteFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    byteFacets.add( new XmlSchemaRestriction( new XmlSchemaMinInclusiveFacet(new Byte((byte) -128), false) ) );
+    byteFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(new Byte((byte)  127), false) ) );
+    attrGroupAttrs.add( new Attribute("byte", "byte", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, byteFacets) );
+
+    HashSet<XmlSchemaRestriction> nonNegativeIntegerFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    nonNegativeIntegerFacets.add( new XmlSchemaRestriction( new XmlSchemaMinInclusiveFacet(new Integer(0), false) ) );
+    attrGroupAttrs.add( new Attribute("nonNegativeInteger", "nonNegativeInteger", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, nonNegativeIntegerFacets) );
+
+    HashSet<XmlSchemaRestriction> positiveIntegerFacets = (HashSet<XmlSchemaRestriction>) integerFacets.clone();
+    positiveIntegerFacets.add( new XmlSchemaRestriction(new XmlSchemaMinInclusiveFacet(new Integer(1), false)) );
+    attrGroupAttrs.add( new Attribute("positiveInteger", "positiveInteger", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, positiveIntegerFacets) );
+
+    HashSet<XmlSchemaRestriction> unsignedLongFacets = (HashSet<XmlSchemaRestriction>) nonNegativeIntegerFacets.clone();
+    unsignedLongFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(new BigInteger("18446744073709551615"), false) ) );
+    attrGroupAttrs.add( new Attribute("unsignedLong", "unsignedLong", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, unsignedLongFacets) );
+
+    HashSet<XmlSchemaRestriction> unsignedIntFacets = (HashSet<XmlSchemaRestriction>) nonNegativeIntegerFacets.clone();
+    unsignedIntFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(new Long(4294967295L), false) ) );
+    attrGroupAttrs.add( new Attribute("unsignedInt", "unsignedInt", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, unsignedIntFacets) );
+
+    HashSet<XmlSchemaRestriction> unsignedShortFacets = (HashSet<XmlSchemaRestriction>) nonNegativeIntegerFacets.clone();
+    unsignedShortFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(new Integer(65535), false) ) );
+    attrGroupAttrs.add( new Attribute("unsignedShort", "unsignedShort", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, unsignedShortFacets) );
+
+    HashSet<XmlSchemaRestriction> unsignedByteFacets = (HashSet<XmlSchemaRestriction>) nonNegativeIntegerFacets.clone();
+    unsignedByteFacets.add( new XmlSchemaRestriction( new XmlSchemaMaxInclusiveFacet(new Short((short) 255), false) ) );
+    attrGroupAttrs.add( new Attribute("unsignedByte", "unsignedByte", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, unsignedByteFacets) );
+
+    HashSet<XmlSchemaRestriction> stringFacets = new HashSet<XmlSchemaRestriction>();
+    stringFacets.add( new XmlSchemaRestriction( new XmlSchemaWhiteSpaceFacet("preserve", false) ) );
+    attrGroupAttrs.add( new Attribute("string", "string", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, stringFacets) );
+
+    HashSet<XmlSchemaRestriction> normalizedStringFacets = new HashSet<XmlSchemaRestriction>();
+    normalizedStringFacets.add( new XmlSchemaRestriction( new XmlSchemaWhiteSpaceFacet("replace", false) ) );
+    attrGroupAttrs.add( new Attribute("normalizedString", "normalizedString", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, normalizedStringFacets) );
+
+    HashSet<XmlSchemaRestriction> tokenFacets = new HashSet<XmlSchemaRestriction>();
+    tokenFacets.add( new XmlSchemaRestriction( new XmlSchemaWhiteSpaceFacet("collapse", false) ) );
+    attrGroupAttrs.add( new Attribute("token", "token", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, tokenFacets) );
+
+    HashSet<XmlSchemaRestriction> languageFacets = (HashSet<XmlSchemaRestriction>) tokenFacets.clone();
+    languageFacets.add( new XmlSchemaRestriction( new XmlSchemaPatternFacet("[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*", false) ) );
+    attrGroupAttrs.add( new Attribute("language", "language", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, languageFacets) );
+
+    HashSet<XmlSchemaRestriction> nmTokenFacets = (HashSet<XmlSchemaRestriction>) tokenFacets.clone();
+    nmTokenFacets.add( new XmlSchemaRestriction( new XmlSchemaPatternFacet("\\c+", false) ) );
+    attrGroupAttrs.add( new Attribute("nmtoken", "NMTOKEN", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, nmTokenFacets) );
+
+    HashSet<XmlSchemaRestriction> nameFacets = (HashSet<XmlSchemaRestriction>) tokenFacets.clone();
+    nameFacets.add( new XmlSchemaRestriction( new XmlSchemaPatternFacet("\\i\\c*", false) ) );
+    attrGroupAttrs.add( new Attribute("name", "Name", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, nameFacets) );
+
+    HashSet<XmlSchemaRestriction> ncNameFacets = (HashSet<XmlSchemaRestriction>) tokenFacets.clone();
+    ncNameFacets.add( new XmlSchemaRestriction( new XmlSchemaPatternFacet("[\\i-[:]][\\c-[:]]*", false) ) );
+    attrGroupAttrs.add( new Attribute("ncName", "NCName", XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, ncNameFacets) );
+
+    attrGroupAttrs.add( new Attribute("id",       "ID",       XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, (Set<XmlSchemaRestriction>) ncNameFacets.clone()) );
+    attrGroupAttrs.add( new Attribute("idref",    "IDREF",    XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, (Set<XmlSchemaRestriction>) ncNameFacets.clone()) );
+    attrGroupAttrs.add( new Attribute("idrefs",   "IDREFS",   XmlSchemaTypeInfo.Type.LIST,   XmlSchemaBaseSimpleType.STRING, true, null) );
+    attrGroupAttrs.add( new Attribute("entity",   "ENTITY",   XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, true, (Set<XmlSchemaRestriction>) ncNameFacets.clone()) );
+    attrGroupAttrs.add( new Attribute("entities", "ENTITIES", XmlSchemaTypeInfo.Type.LIST,   XmlSchemaBaseSimpleType.STRING, true, null) );
+    attrGroupAttrs.add( new Attribute("nmtokens", "NMTOKENS", XmlSchemaTypeInfo.Type.LIST,   XmlSchemaBaseSimpleType.STRING, true, null) );
+
+    HashSet<XmlSchemaRestriction> nonNullPrimitiveTypeFacets =
+        new HashSet<XmlSchemaRestriction>(14);
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "boolean",  false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "int",      false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "long",     false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "float",    false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "double",   false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "decimal",  false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "bytes",    false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "string",   false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.PATTERN,     "\\c+",     false) );
+    nonNullPrimitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.WHITESPACE,  "collapse", false) );
+
+    XmlSchemaBaseSimpleType nonNullPrimitiveType = XmlSchemaBaseSimpleType.STRING;
+    XmlSchemaBaseSimpleType primitiveType = XmlSchemaBaseSimpleType.STRING;
+
+    HashSet<XmlSchemaRestriction> primitiveTypeFacets =
+        new HashSet<XmlSchemaRestriction>(15);
+    primitiveTypeFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION, "null",     false) );
+    primitiveTypeFacets.addAll(nonNullPrimitiveTypeFacets);
+
+    LinkedList<StackEntry> stack = new LinkedList<StackEntry>();
+
+    // Indentation follows tree.
+    stack.add( new StackEntry(Type.ELEMENT, "root") );
+      stack.add( new StackEntry(Type.SEQUENCE) );
+        stack.add( new StackEntry(Type.CHOICE, 0, Long.MAX_VALUE) );
+          stack.add( new StackEntry(Type.ELEMENT, "primitive", "primitiveType", primitiveType, (Set<XmlSchemaRestriction>)primitiveTypeFacets.clone()) );
+          stack.add( new StackEntry(Type.ELEMENT, "nonNullPrimitive", "nonNullPrimitiveType", nonNullPrimitiveType, (Set<XmlSchemaRestriction>) nonNullPrimitiveTypeFacets.clone()) );
+          stack.add( new StackEntry(Type.SUBSTITUTION_GROUP, "record") );
+            stack.add( new StackEntry(Type.ELEMENT, "record", "recordType") );
+              stack.add( new StackEntry(Type.SEQUENCE) );
+                stack.add( new StackEntry(Type.CHOICE, 0, Long.MAX_VALUE) );
+/* 10 */          stack.add( new StackEntry(Type.ELEMENT, "primitive", "primitiveType", primitiveType, (Set<XmlSchemaRestriction>)primitiveTypeFacets.clone()) );
+                  stack.add( new StackEntry(Type.ELEMENT, "nonNullPrimitive", "nonNullPrimitiveType", nonNullPrimitiveType, (Set<XmlSchemaRestriction>) nonNullPrimitiveTypeFacets.clone()) );
+                  stack.add( new StackEntry(Type.SUBSTITUTION_GROUP, "record") );
+                    stack.add( new StackEntry(Type.ELEMENT, "record", "recordType") );
+                    stack.add( new StackEntry(Type.ELEMENT, "map") );
+                      stack.add( new StackEntry(Type.SEQUENCE) );
+                      stack.add( new StackEntry(Type.CHOICE, 0, Long.MAX_VALUE) );
+                        stack.add( new StackEntry(Type.ELEMENT, "primitive", "primitiveType", primitiveType, (Set<XmlSchemaRestriction>)primitiveTypeFacets.clone()) );
+                        stack.add( new StackEntry(Type.ELEMENT, "nonNullPrimitive", "nonNullPrimitiveType", nonNullPrimitiveType, (Set<XmlSchemaRestriction>) nonNullPrimitiveTypeFacets.clone()) );
+                        stack.add( new StackEntry(Type.SUBSTITUTION_GROUP, "record") );
+/* 20 */                  stack.add( new StackEntry(Type.ELEMENT, "record", "recordType") );
+                          stack.add( new StackEntry(Type.ELEMENT, "map") );
+                        stack.add( new StackEntry(Type.ELEMENT, "list") );
+                          stack.add( new StackEntry(Type.CHOICE) );
+                            stack.add( new StackEntry(Type.ELEMENT, "primitive", "primitiveType", primitiveType, 1, 100, (Set<XmlSchemaRestriction>)primitiveTypeFacets.clone()) );
+                            stack.add( new StackEntry(Type.SUBSTITUTION_GROUP, "record", "recordType", 1, 100) );
+                              stack.add( new StackEntry(Type.ELEMENT, "record", "recordType", 1, 1) );
+                              stack.add( new StackEntry(Type.ELEMENT, "map") );
+                        stack.add( new StackEntry(Type.ELEMENT, "tuple") );
+                          stack.add( new StackEntry(Type.ALL) );
+/* 30 */                    stack.add( new StackEntry(Type.ELEMENT, "primitive", "primitiveType", primitiveType, (Set<XmlSchemaRestriction>)primitiveTypeFacets.clone()) );
+                            stack.add( new StackEntry(Type.ELEMENT, "nonNullPrimitive", "nonNullPrimitiveType", nonNullPrimitiveType, (Set<XmlSchemaRestriction>)nonNullPrimitiveTypeFacets.clone()) );
+                            stack.add( new StackEntry(Type.SUBSTITUTION_GROUP, "record") );
+                              stack.add( new StackEntry(Type.ELEMENT, "record", "recordType") );
+                              stack.add( new StackEntry(Type.ELEMENT, "map") );
+                            stack.add( new StackEntry(Type.ELEMENT, "list") );
+                  stack.add( new StackEntry(Type.ELEMENT, "list") );
+                  stack.add( new StackEntry(Type.ELEMENT, "tuple") );
+            stack.add( new StackEntry(Type.ELEMENT, "map") );
+          stack.add( new StackEntry(Type.ELEMENT, "list") );
+          stack.add( new StackEntry(Type.ELEMENT, "tuple") );
+
+
+    HashMap<String, List<Attribute>> attributes = new HashMap<String, List<Attribute>>();
+    attributes.put("root", attrGroupAttrs);
+
+    HashSet<XmlSchemaRestriction> listAttrFacets = (HashSet<XmlSchemaRestriction>) nonNegativeIntegerFacets.clone();
+    listAttrFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.EXCLUSIVE_MAX, 100, false) );
+    ArrayList<Attribute> listAttributes = new ArrayList<Attribute>(1);
+    listAttributes.add( new Attribute("size", null, XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.DECIMAL, true, listAttrFacets) );
+    attributes.put("list", listAttributes);
+
+    HashSet<XmlSchemaRestriction> mapAttrFacets = (HashSet<XmlSchemaRestriction>) ncNameFacets.clone();
+    mapAttrFacets.add( new XmlSchemaRestriction(XmlSchemaRestriction.Type.LENGTH_MIN, 1, false) );
+    ArrayList<Attribute> mapAttributes = new ArrayList<Attribute>(1);
+    mapAttributes.add( new Attribute("mapId", null, XmlSchemaTypeInfo.Type.ATOMIC, XmlSchemaBaseSimpleType.STRING, mapAttrFacets) );
+    attributes.put("map", mapAttributes);
+
+    // Compare against the actual.
+    final Visitor visitor = new Visitor(stack, attributes);
+    final int numEntries = stack.size();
+
+    XmlSchemaCollection collection = null;
+    FileReader fileReader = null;
+    try {
+      File file =
+          UtilsForTests.buildFile("src", "test", "resources", "test_schema.xsd");
+      fileReader = new FileReader(file);
+
+      collection = new XmlSchemaCollection();
+      collection.setSchemaResolver(new XmlSchemaMultiBaseUriResolver());
+      collection.read(new StreamSource(fileReader, file.getAbsolutePath()));
+
+    } finally {
+      if (fileReader != null) {
+        try {
+          fileReader.close();
+        } catch (IOException ioe) {
+          ioe.printStackTrace();
+        }
+      }
+    }
+
+    XmlSchemaElement elem = getElementOf(collection, "root");
+    XmlSchemaWalker walker = new XmlSchemaWalker(collection, visitor);
+    try {
+      walker.walk(elem);
+    } catch (Exception e) {
+      throw new IllegalStateException("Failed on stack entry " + (numEntries - stack.size()), e);
+    }
+
+    Assert.assertTrue( stack.isEmpty() );
+  }
+
+  private static void checkFacets(
+      String nextName,
+      XmlSchemaTypeInfo typeInfo,
+      Set<XmlSchemaRestriction> nextFacets) {
+    final HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+    facets = typeInfo.getFacets();
+
+  if ((facets == null) && (nextFacets != null)) {
+    throw new IllegalStateException(
+        "Expected "
+        + nextFacets.size()
+        + " facets for element \""
+        + nextName
+        + "\" but received null facets.");
+
+  } else if ((facets != null)
+             && facets.isEmpty()
+             && (nextFacets != null)
+             && !nextFacets.isEmpty()) {
+    throw new IllegalStateException(
+        "Expected "
+        + nextFacets.size()
+        + " facets for element \""
+        + nextName
+        + "\" but found none.");
+
+  } else if ((facets != null)
+             && !facets.isEmpty()
+             && (nextFacets != null)
+             && nextFacets.isEmpty()) {
+
+    throw new IllegalStateException(
+        "Element " + nextName + " has facets, but none were expected.");
+  }
+
+  if (facets != null) {
+    for (Map.Entry<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+         facetsForType : facets.entrySet()) {
+
+      for (XmlSchemaRestriction facet : facetsForType.getValue()) {
+        if (!nextFacets.remove(facet)) {
+          throw new IllegalStateException(
+              "Element \""
+              + nextName
+              + "\" has unexpected facet \""
+              + facet
+              + "\".");
+        }
+      }
+    }
+  }
+
+  }
+
+  private static XmlSchemaElement getElementOf(XmlSchemaCollection collection, String name) {
+    XmlSchemaElement elem = null;
+    for (XmlSchema schema : collection.getXmlSchemas()) {
+      elem = schema.getElementByName(name);
+      if (elem != null) {
+        break;
+      }
+    }
+    return elem;
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestUtils.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestUtils.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestUtils.java	(working copy)
@@ -0,0 +1,223 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import static org.junit.Assert.*;
+
+import java.math.MathContext;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+
+import org.apache.avro.Schema;
+import org.apache.avro.xml.Utils;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.junit.Assert;
+
+public class TestUtils {
+
+  private static String NAMESPACE_URI =
+      "http://www.sec.gov/Archives/edgar/data/1013237/000143774913004187/"
+      + "fds-20130228.xsd";
+
+  private static String EXPECTED_RESULT =
+      "gov.sec.www.Archives.edgar.data.1013237.000143774913004187."
+      + "fds_20130228.xsd";
+
+  private static ArrayList<QName> avroUnrecognizedTypes;
+
+  @Test
+  public void testGetAvroNamespaceForString() throws URISyntaxException {
+    Assert.assertEquals(
+        EXPECTED_RESULT,
+        Utils.getAvroNamespaceFor(NAMESPACE_URI));
+  }
+
+  @Test
+  public void testGetAvroNamespaceForURL()
+      throws MalformedURLException, URISyntaxException {
+    Assert.assertEquals(
+        EXPECTED_RESULT,
+        Utils.getAvroNamespaceFor(new URL(NAMESPACE_URI)));
+  }
+
+  @Test
+  public void testGetAvroNamespaceForURI() throws URISyntaxException {
+    Assert.assertEquals(
+        EXPECTED_RESULT,
+        Utils.getAvroNamespaceFor(new URI(NAMESPACE_URI)));
+  }
+
+  @Test
+  public void testUblUrn() throws URISyntaxException {
+    URI uri =
+        new URI("urn:oasis:names:specification:ubl:schema:xsd:"
+                + "ApplicationResponse-2");
+    
+    Assert.assertEquals(
+        "oasis.names.specification.ubl.schema.xsd.ApplicationResponse_2",
+        Utils.getAvroNamespaceFor(uri));
+  }
+
+  @BeforeClass
+  public static void setUpUnrecognizedTypes() {
+    avroUnrecognizedTypes = new ArrayList<QName>();
+
+    avroUnrecognizedTypes.add(Constants.XSD_ANY);
+    avroUnrecognizedTypes.add(Constants.XSD_BYTE);
+    avroUnrecognizedTypes.add(Constants.XSD_ENTITIES);
+    avroUnrecognizedTypes.add(Constants.XSD_ENTITY);
+    avroUnrecognizedTypes.add(Constants.XSD_IDREF);
+    avroUnrecognizedTypes.add(Constants.XSD_IDREFS);
+    avroUnrecognizedTypes.add(Constants.XSD_INTEGER);
+    avroUnrecognizedTypes.add(Constants.XSD_LANGUAGE);
+    avroUnrecognizedTypes.add(Constants.XSD_NAME);
+    avroUnrecognizedTypes.add(Constants.XSD_NCNAME);
+    avroUnrecognizedTypes.add(Constants.XSD_NEGATIVEINTEGER);
+    avroUnrecognizedTypes.add(Constants.XSD_NMTOKEN);
+    avroUnrecognizedTypes.add(Constants.XSD_NMTOKENS);
+    avroUnrecognizedTypes.add(Constants.XSD_NONNEGATIVEINTEGER);
+    avroUnrecognizedTypes.add(Constants.XSD_NONPOSITIVEINTEGER);
+    avroUnrecognizedTypes.add(Constants.XSD_NORMALIZEDSTRING);
+    avroUnrecognizedTypes.add(Constants.XSD_POSITIVEINTEGER);
+    avroUnrecognizedTypes.add(Constants.XSD_SCHEMA);
+    avroUnrecognizedTypes.add(Constants.XSD_TOKEN);
+    avroUnrecognizedTypes.add(Constants.XSD_UNSIGNEDBYTE);
+    avroUnrecognizedTypes.add(Constants.XSD_ANYSIMPLETYPE);
+    avroUnrecognizedTypes.add(Constants.XSD_DURATION);
+    avroUnrecognizedTypes.add(Constants.XSD_DATETIME);
+    avroUnrecognizedTypes.add(Constants.XSD_TIME);
+    avroUnrecognizedTypes.add(Constants.XSD_DATE);
+    avroUnrecognizedTypes.add(Constants.XSD_YEARMONTH);
+    avroUnrecognizedTypes.add(Constants.XSD_YEAR);
+    avroUnrecognizedTypes.add(Constants.XSD_MONTHDAY);
+    avroUnrecognizedTypes.add(Constants.XSD_DAY);
+    avroUnrecognizedTypes.add(Constants.XSD_MONTH);
+    avroUnrecognizedTypes.add(Constants.XSD_STRING);
+    avroUnrecognizedTypes.add(Constants.XSD_ANYURI);
+    avroUnrecognizedTypes.add(Constants.XSD_NOTATION);
+    avroUnrecognizedTypes.add(Constants.XSD_UNSIGNEDLONG);
+  }
+
+  @Test
+  public void testGetAvroRecognizedTypes() {
+    final Set<QName> recTypes = Utils.getAvroRecognizedTypes();
+
+    assertTrue( recTypes.contains(Constants.XSD_ANYTYPE) );
+    assertTrue( recTypes.contains(Constants.XSD_BOOLEAN) );
+    assertTrue( recTypes.contains(Constants.XSD_DECIMAL) );
+    assertTrue( recTypes.contains(Constants.XSD_DOUBLE) );
+    assertTrue( recTypes.contains(Constants.XSD_FLOAT) );
+    assertTrue( recTypes.contains(Constants.XSD_BASE64) );
+    assertTrue( recTypes.contains(Constants.XSD_HEXBIN) );
+    assertTrue( recTypes.contains(Constants.XSD_LONG) );
+    assertTrue( recTypes.contains(Constants.XSD_ID) );
+    assertTrue( recTypes.contains(Constants.XSD_INT) );
+    assertTrue( recTypes.contains(Constants.XSD_UNSIGNEDINT) );
+    assertTrue( recTypes.contains(Constants.XSD_UNSIGNEDSHORT) );
+    assertTrue( recTypes.contains(Constants.XSD_QNAME) );
+
+    for (QName unrecognizedType : avroUnrecognizedTypes) {
+      assertFalse( recTypes.contains(unrecognizedType) );
+    }
+  }
+
+  @Test
+  public void testGetAvroSchemaTypeForQName() {
+    assertEquals(
+        Schema.Type.STRING,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_ANYTYPE));
+
+    assertEquals(
+        Schema.Type.BOOLEAN,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_BOOLEAN));
+
+    assertEquals(
+        Schema.Type.BYTES,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_DECIMAL));
+
+    assertEquals(
+        Schema.Type.DOUBLE,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_DOUBLE));
+
+    assertEquals(
+        Schema.Type.FLOAT,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_FLOAT));
+
+    assertEquals(
+        Schema.Type.BYTES,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_BASE64));
+
+    assertEquals(
+        Schema.Type.BYTES,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_HEXBIN));
+
+    assertEquals(
+        Schema.Type.LONG,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_LONG));
+
+    assertEquals(
+        Schema.Type.STRING,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_ID));
+
+    assertEquals(
+        Schema.Type.INT,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_INT));
+
+    assertEquals(
+        Schema.Type.LONG,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_UNSIGNEDINT));
+
+    assertEquals(
+        Schema.Type.INT,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_UNSIGNEDSHORT));
+
+    assertEquals(
+        Schema.Type.RECORD,
+        Utils.getAvroSchemaTypeFor(Constants.XSD_QNAME));
+
+    for (QName unrecognizedType : avroUnrecognizedTypes) {
+      assertNull( Utils.getAvroSchemaTypeFor(unrecognizedType) );
+    }
+  }
+
+  @Test
+  public void testCreateDecimalSchema() {
+    XmlSchemaTypeInfo decimalType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL);
+    decimalType.setUserRecognizedType(Constants.XSD_DECIMAL);
+
+    Schema decimalSchema =
+        Utils.getAvroSchemaFor(decimalType, Constants.XSD_DECIMAL, false);
+
+    assertEquals(Schema.Type.BYTES, decimalSchema.getType());
+    assertEquals("decimal", decimalSchema.getJsonProp("logicalType").asText());
+
+    assertEquals(MathContext.DECIMAL128.getPrecision(),
+                 decimalSchema.getJsonProp("precision").asInt());
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaBaseSimpleType.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaBaseSimpleType.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaBaseSimpleType.java	(working copy)
@@ -0,0 +1,301 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+
+import org.apache.avro.xml.XmlSchemaBaseSimpleType;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class TestXmlSchemaBaseSimpleType {
+
+  private static List<QName> nonBaseTypes;
+
+  @BeforeClass
+  public static void setUpNonBaseTypes() {
+    nonBaseTypes = new ArrayList<QName>(28);
+
+    nonBaseTypes.add(Constants.XSD_ANY);
+    nonBaseTypes.add(Constants.XSD_BYTE);
+    nonBaseTypes.add(Constants.XSD_ENTITIES);
+    nonBaseTypes.add(Constants.XSD_ENTITY);
+    nonBaseTypes.add(Constants.XSD_ID);
+    nonBaseTypes.add(Constants.XSD_IDREF);
+    nonBaseTypes.add(Constants.XSD_IDREFS);
+    nonBaseTypes.add(Constants.XSD_INT);
+    nonBaseTypes.add(Constants.XSD_INTEGER);
+    nonBaseTypes.add(Constants.XSD_LANGUAGE);
+    nonBaseTypes.add(Constants.XSD_LONG);
+    nonBaseTypes.add(Constants.XSD_NAME);
+    nonBaseTypes.add(Constants.XSD_NCNAME);
+    nonBaseTypes.add(Constants.XSD_NEGATIVEINTEGER);
+    nonBaseTypes.add(Constants.XSD_NMTOKEN);
+    nonBaseTypes.add(Constants.XSD_NMTOKENS);
+    nonBaseTypes.add(Constants.XSD_NONNEGATIVEINTEGER);
+    nonBaseTypes.add(Constants.XSD_NONPOSITIVEINTEGER);
+    nonBaseTypes.add(Constants.XSD_NORMALIZEDSTRING);
+    nonBaseTypes.add(Constants.XSD_POSITIVEINTEGER);
+    nonBaseTypes.add(Constants.XSD_SCHEMA);
+    nonBaseTypes.add(Constants.XSD_SHORT);
+    nonBaseTypes.add(Constants.XSD_TOKEN);
+    nonBaseTypes.add(Constants.XSD_UNSIGNEDBYTE);
+    nonBaseTypes.add(Constants.XSD_UNSIGNEDINT);
+    nonBaseTypes.add(Constants.XSD_UNSIGNEDLONG);
+    nonBaseTypes.add(Constants.XSD_UNSIGNEDSHORT);
+  }
+
+  @Test
+  public void testMappings() {
+    assertEquals(Constants.XSD_ANYTYPE,
+                 XmlSchemaBaseSimpleType.ANYTYPE.getQName());
+
+    assertEquals(Constants.XSD_ANYSIMPLETYPE,
+        XmlSchemaBaseSimpleType.ANYSIMPLETYPE.getQName());
+
+    assertEquals(Constants.XSD_DURATION,
+        XmlSchemaBaseSimpleType.DURATION.getQName());
+
+    assertEquals(Constants.XSD_DATETIME,
+        XmlSchemaBaseSimpleType.DATETIME.getQName());
+
+    assertEquals(Constants.XSD_TIME,
+        XmlSchemaBaseSimpleType.TIME.getQName());
+
+    assertEquals(Constants.XSD_DATE,
+        XmlSchemaBaseSimpleType.DATE.getQName());
+
+    assertEquals(Constants.XSD_YEARMONTH,
+        XmlSchemaBaseSimpleType.YEARMONTH.getQName());
+
+    assertEquals(Constants.XSD_YEAR,
+        XmlSchemaBaseSimpleType.YEAR.getQName());
+
+    assertEquals(Constants.XSD_MONTHDAY,
+        XmlSchemaBaseSimpleType.MONTHDAY.getQName());
+
+    assertEquals(Constants.XSD_DAY,
+        XmlSchemaBaseSimpleType.DAY.getQName());
+
+    assertEquals(Constants.XSD_MONTH,
+        XmlSchemaBaseSimpleType.MONTH.getQName());
+
+    assertEquals(Constants.XSD_STRING,
+        XmlSchemaBaseSimpleType.STRING.getQName());
+
+    assertEquals(Constants.XSD_BOOLEAN,
+        XmlSchemaBaseSimpleType.BOOLEAN.getQName());
+
+    assertEquals(Constants.XSD_BASE64,
+        XmlSchemaBaseSimpleType.BIN_BASE64.getQName());
+
+    assertEquals(Constants.XSD_HEXBIN,
+        XmlSchemaBaseSimpleType.BIN_HEX.getQName());
+
+    assertEquals(Constants.XSD_FLOAT,
+        XmlSchemaBaseSimpleType.FLOAT.getQName());
+
+    assertEquals(Constants.XSD_DECIMAL,
+        XmlSchemaBaseSimpleType.DECIMAL.getQName());
+
+    assertEquals(Constants.XSD_DOUBLE,
+        XmlSchemaBaseSimpleType.DOUBLE.getQName());
+
+    assertEquals(Constants.XSD_ANYURI,
+        XmlSchemaBaseSimpleType.ANYURI.getQName());
+
+    assertEquals(Constants.XSD_QNAME,
+        XmlSchemaBaseSimpleType.QNAME.getQName());
+
+    assertEquals(Constants.XSD_NOTATION,
+        XmlSchemaBaseSimpleType.NOTATION.getQName());
+  }
+
+  @Test
+  public void testReverseMappings() {
+    assertEquals(
+        XmlSchemaBaseSimpleType.ANYTYPE,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_ANYTYPE));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.ANYSIMPLETYPE,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(
+            Constants.XSD_ANYSIMPLETYPE));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.DURATION,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_DURATION));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.DATETIME,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_DATETIME));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.TIME,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_TIME));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.DATE,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_DATE));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.YEARMONTH,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_YEARMONTH));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.YEAR,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_YEAR));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.MONTHDAY,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_MONTHDAY));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.DAY,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_DAY));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.MONTH,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_MONTH));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.STRING,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_STRING));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.BOOLEAN,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_BOOLEAN));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.BIN_BASE64,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_BASE64));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.BIN_HEX,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_HEXBIN));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.FLOAT,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_FLOAT));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.DECIMAL,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_DECIMAL));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.DOUBLE,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_DOUBLE));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.ANYURI,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_ANYURI));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.QNAME,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_QNAME));
+
+    assertEquals(
+        XmlSchemaBaseSimpleType.NOTATION,
+        XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(Constants.XSD_NOTATION));
+
+    for (QName nonBaseType : nonBaseTypes) {
+      final XmlSchemaBaseSimpleType simpleType =
+          XmlSchemaBaseSimpleType.getBaseSimpleTypeFor(nonBaseType);
+      assertNull(nonBaseType + " -> " + simpleType, simpleType);
+    }
+  }
+
+  @Test
+  public void testIsBaseSimpleType() {
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_ANYTYPE) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_ANYSIMPLETYPE));
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_DURATION) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_DATETIME) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_TIME) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_DATE) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_YEARMONTH) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_YEAR) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_MONTHDAY) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_DAY) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_MONTH) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_STRING) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_BOOLEAN) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_BASE64) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_HEXBIN) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_FLOAT) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_DECIMAL) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_DOUBLE) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_ANYURI) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_QNAME) );
+
+    assertTrue(
+        XmlSchemaBaseSimpleType.isBaseSimpleType(Constants.XSD_NOTATION) );
+
+    for (QName nonBaseType : nonBaseTypes) {
+      assertFalse(
+          nonBaseType.toString(),
+          XmlSchemaBaseSimpleType.isBaseSimpleType(nonBaseType) );
+    }
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaElementValidator.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaElementValidator.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaElementValidator.java	(working copy)
@@ -0,0 +1,2443 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import static org.junit.Assert.*;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.bind.ValidationException;
+import javax.xml.namespace.QName;
+
+
+import org.apache.avro.xml.XmlSchemaBaseSimpleType;
+import org.apache.avro.xml.XmlSchemaElementValidator;
+import org.apache.avro.xml.XmlSchemaNamespaceContext;
+import org.apache.avro.xml.XmlSchemaRestriction;
+import org.apache.avro.xml.XmlSchemaStateMachineNode;
+import org.apache.avro.xml.XmlSchemaTypeInfo;
+import org.apache.ws.commons.schema.XmlSchema;
+import org.apache.ws.commons.schema.XmlSchemaAttribute;
+import org.apache.ws.commons.schema.XmlSchemaElement;
+import org.apache.ws.commons.schema.XmlSchemaUse;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.xml.sax.Attributes;
+
+public class TestXmlSchemaElementValidator {
+
+  private static final String NAMESPACE = "urn:avro:test";
+  private static final String PREFIX = "avro";
+
+  private static final String PROHIBITED = "prohibited";
+  private static final String REQUIRED = "required";
+  private static final String OPTIONAL = "optional";
+
+  private static XmlSchema xmlSchema;
+  private static XmlSchemaElement xmlElement;
+  private static XmlSchemaAttribute prohibitedAttribute;
+  private static XmlSchemaAttribute optionalAttribute;
+  private static XmlSchemaAttribute requiredAttribute;
+  private static XmlSchemaNamespaceContext nsContext;
+
+  private static class SaxAttribute {
+
+    SaxAttribute(String localName, String val) {
+      qName = new QName(NAMESPACE, localName);
+      qualifiedName = PREFIX + ':' + localName;
+      value = val;
+    }
+
+    final QName qName;
+    final String qualifiedName;
+    final String value;
+  }
+
+  private static class SaxAttributes implements Attributes {
+
+    SaxAttributes() {
+      attributes = new ArrayList<SaxAttribute>();
+      attrsByQualifiedName = new HashMap<String, SaxAttribute>();
+      attrsByQName = new HashMap<QName, SaxAttribute>();
+
+      indexByQualifiedName = new HashMap<String, Integer>();
+      indexByQName = new HashMap<QName, Integer>();
+    }
+
+    void add(SaxAttribute attr) {
+      attrsByQualifiedName.put(attr.qualifiedName, attr);
+      attrsByQName.put(attr.qName, attr);
+
+      indexByQualifiedName.put(attr.qualifiedName, attributes.size());
+      indexByQName.put(attr.qName, attributes.size());
+
+      attributes.add(attr);
+    }
+
+    @Override
+    public int getLength() {
+      return attributes.size();
+    }
+
+    @Override
+    public String getURI(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qName.getNamespaceURI();
+      }
+    }
+
+    @Override
+    public String getLocalName(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qName.getLocalPart();
+      }
+    }
+
+    @Override
+    public String getQName(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).qualifiedName;
+      }
+    }
+
+    @Override
+    public String getType(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return "CDATA"; // We do not know the type information.
+      }
+    }
+
+    @Override
+    public String getValue(int index) {
+      if (attributes.size() <= index) {
+        return null;
+      } else {
+        return attributes.get(index).value;
+      }
+    }
+
+    @Override
+    public int getIndex(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return -1;
+      }
+
+      final QName qName = new QName(uri, localName);
+      final Integer index = indexByQName.get(qName);
+
+      if (index == null) {
+        return -1;
+      } else {
+        return index;
+      }
+    }
+
+    @Override
+    public int getIndex(String qName) {
+      if (qName == null) {
+        return -1;
+      }
+
+      final Integer index = indexByQualifiedName.get(qName);
+      if (index == null) {
+        return -1;
+      } else {
+        return index;
+      }
+    }
+
+    @Override
+    public String getType(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return null;
+      } else {
+        final SaxAttribute attr =
+            attrsByQName.get( new QName(uri, localName) );
+        return (attr == null) ? null : "CDATA";
+      }
+    }
+
+    @Override
+    public String getType(String qName) {
+      if (qName == null) {
+        return null;
+      } else {
+        final SaxAttribute attr = attrsByQualifiedName.get(qName);
+        return (attr == null) ? null : "CDATA";
+      }
+    }
+
+    @Override
+    public String getValue(String uri, String localName) {
+      if ((uri == null) || (localName == null)) {
+        return null;
+      } else {
+        final SaxAttribute attr =
+            attrsByQName.get( new QName(uri, localName) );
+        return (attr == null) ? null : attr.value;
+      }
+    }
+
+    @Override
+    public String getValue(String qName) {
+      if (qName == null) {
+        return null;
+      } else {
+        final SaxAttribute attr = attrsByQualifiedName.get(qName);
+        return (attr == null) ? null : attr.value;
+      }
+    }
+
+    private final List<SaxAttribute> attributes;
+    private final Map<String, SaxAttribute> attrsByQualifiedName;
+    private final Map<QName, SaxAttribute> attrsByQName;
+    private final Map<String, Integer> indexByQualifiedName;
+    private final Map<QName, Integer> indexByQName;
+  }
+
+  @Test
+  public void testSaxAttributes() {
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(OPTIONAL, "123.45") );
+    saxAttributes.add( new SaxAttribute(PROHIBITED, "hello") );
+    saxAttributes.add( new SaxAttribute(REQUIRED, "true") );
+    saxAttributes.add( new SaxAttribute("test", "-73") );
+
+    assertEquals(4, saxAttributes.getLength());
+
+    for (int i = 0; i < 4; ++i) {
+      assertEquals(NAMESPACE, saxAttributes.getURI(i));
+      assertEquals("CDATA", saxAttributes.getType(i));
+    }
+    assertEquals(null, saxAttributes.getURI(5));
+    assertEquals(null, saxAttributes.getType(5));
+
+    assertEquals(OPTIONAL, saxAttributes.getLocalName(0));
+    assertEquals(PREFIX + ':' + OPTIONAL, saxAttributes.getQName(0));
+    assertEquals("123.45", saxAttributes.getValue(0));
+    assertEquals(0, saxAttributes.getIndex(NAMESPACE, OPTIONAL));
+    assertEquals(0, saxAttributes.getIndex(PREFIX + ':' + OPTIONAL));
+    assertEquals("CDATA", saxAttributes.getType(NAMESPACE, OPTIONAL));
+    assertEquals("CDATA", saxAttributes.getType(PREFIX + ':' + OPTIONAL));
+    assertEquals("123.45", saxAttributes.getValue(NAMESPACE, OPTIONAL));
+    assertEquals("123.45", saxAttributes.getValue(PREFIX + ':' + OPTIONAL));
+
+    assertEquals(PROHIBITED, saxAttributes.getLocalName(1));
+    assertEquals(PREFIX + ':' + PROHIBITED, saxAttributes.getQName(1));
+    assertEquals("hello", saxAttributes.getValue(1));
+    assertEquals(1, saxAttributes.getIndex(NAMESPACE, PROHIBITED));
+    assertEquals(1, saxAttributes.getIndex(PREFIX + ':' + PROHIBITED));
+    assertEquals("CDATA", saxAttributes.getType(NAMESPACE, PROHIBITED));
+    assertEquals("CDATA", saxAttributes.getType(PREFIX + ':' + PROHIBITED));
+    assertEquals("hello", saxAttributes.getValue(NAMESPACE, PROHIBITED));
+    assertEquals("hello", saxAttributes.getValue(PREFIX + ':' + PROHIBITED));
+
+    assertEquals(REQUIRED, saxAttributes.getLocalName(2));
+    assertEquals(PREFIX + ':' + REQUIRED, saxAttributes.getQName(2));
+    assertEquals("true", saxAttributes.getValue(2));
+    assertEquals(2, saxAttributes.getIndex(NAMESPACE, REQUIRED));
+    assertEquals(2, saxAttributes.getIndex(PREFIX + ':' + REQUIRED));
+    assertEquals("CDATA", saxAttributes.getType(NAMESPACE, REQUIRED));
+    assertEquals("CDATA", saxAttributes.getType(PREFIX + ':' + REQUIRED));
+    assertEquals("true", saxAttributes.getValue(NAMESPACE, REQUIRED));
+    assertEquals("true", saxAttributes.getValue(PREFIX + ':' + REQUIRED));
+
+    assertEquals("test", saxAttributes.getLocalName(3));
+    assertEquals(PREFIX + ":test", saxAttributes.getQName(3));
+    assertEquals("-73", saxAttributes.getValue(3));
+    assertEquals(3, saxAttributes.getIndex(NAMESPACE, "test"));
+    assertEquals(3, saxAttributes.getIndex(PREFIX + ":test"));
+    assertEquals("CDATA", saxAttributes.getType(NAMESPACE, "test"));
+    assertEquals("CDATA", saxAttributes.getType(PREFIX + ":test"));
+    assertEquals("-73", saxAttributes.getValue(NAMESPACE, "test"));
+    assertEquals("-73", saxAttributes.getValue(PREFIX + ":test"));
+  }
+
+  @BeforeClass
+  public static void setUpXmlSchema() {
+    xmlSchema = new XmlSchema();
+    xmlSchema.setTargetNamespace(NAMESPACE);
+
+    xmlElement = new XmlSchemaElement(xmlSchema, false);
+    xmlElement.setName("elem");
+
+    prohibitedAttribute =
+        new XmlSchemaAttribute(xmlSchema, false);
+    prohibitedAttribute.setUse(XmlSchemaUse.PROHIBITED);
+    prohibitedAttribute.setName(PROHIBITED);
+
+    optionalAttribute =
+        new XmlSchemaAttribute(xmlSchema, false);
+    optionalAttribute.setUse(XmlSchemaUse.OPTIONAL);
+    optionalAttribute.setName(OPTIONAL);
+
+    requiredAttribute =
+        new XmlSchemaAttribute(xmlSchema, false);
+    requiredAttribute.setUse(XmlSchemaUse.REQUIRED);
+    requiredAttribute.setName(REQUIRED);
+
+    nsContext = new XmlSchemaNamespaceContext();
+    nsContext.addNamespace(PREFIX, NAMESPACE);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testAttributesWithNothing() throws Exception {
+    XmlSchemaElementValidator.validateAttributes(null, null, null);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testAttributesWithNoState() throws Exception {
+    XmlSchemaElementValidator.validateAttributes(
+        null,
+        new SaxAttributes(),
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testAttributesWithNoAttributes() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+        null,
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testAttributesWithNoNamespaceContext() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+        new SaxAttributes(),
+        null);
+  }
+
+  @Test
+  public void testElementWithNoAttributes() throws Exception {
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            null,
+            new XmlSchemaTypeInfo(true));
+
+    XmlSchemaElementValidator.validateAttributes(
+        stateMachine,
+        new SaxAttributes(),
+        nsContext);
+
+    stateMachine =
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            Collections.<XmlSchemaStateMachineNode.Attribute>emptyList(),
+            new XmlSchemaTypeInfo(true));
+
+    XmlSchemaElementValidator.validateAttributes(
+        stateMachine,
+        new SaxAttributes(),
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testNotAnElement() throws Exception {
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(
+            XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP,
+            1,
+            1);
+
+    XmlSchemaElementValidator.validateAttributes(
+        stateMachine,
+        new SaxAttributes(),
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentWithNothing() throws Exception {
+    XmlSchemaElementValidator.validateAttributes(null, null, null);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentWithNoState() throws Exception {
+    XmlSchemaElementValidator.validateContent(
+        null,
+        "hello",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentWithNoNamespaceContext() throws Exception {
+    XmlSchemaElementValidator.validateContent(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            null,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+        "hello",
+        null);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentNotAnElement() throws Exception {
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(
+            XmlSchemaStateMachineNode.Type.SUBSTITUTION_GROUP,
+            1,
+            1);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "hello",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidUse() throws Exception {
+    XmlSchemaAttribute attr = new XmlSchemaAttribute(xmlSchema, false);
+    attr.setUse(XmlSchemaUse.NONE);
+    attr.setName("none");
+
+    XmlSchemaTypeInfo attrType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    List<XmlSchemaStateMachineNode.Attribute> attrs =
+      Collections.<XmlSchemaStateMachineNode.Attribute>singletonList(
+          new XmlSchemaStateMachineNode.Attribute(attr, attrType));
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(true));
+
+    XmlSchemaElementValidator.validateAttributes(
+        stateMachine,
+        new SaxAttributes(),
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testProhibitedAttribute() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    SaxAttributes saxAttrs = new SaxAttributes();
+
+    saxAttrs.add( new SaxAttribute(PROHIBITED, "true") );
+    saxAttrs.add( new SaxAttribute(REQUIRED, "true") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+        saxAttrs,
+        nsContext);
+  }
+
+  @Test
+  public void testEmptyProhibitedAttribute() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    SaxAttributes saxAttrs = new SaxAttributes();
+
+    saxAttrs.add( new SaxAttribute(PROHIBITED, "") );
+    saxAttrs.add( new SaxAttribute(REQUIRED, "true") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+        saxAttrs,
+        nsContext);
+  }
+
+  @Test
+  public void testOptionalAttribute() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        new ArrayList<XmlSchemaStateMachineNode.Attribute>(1);
+
+    attrs.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            optionalAttribute,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE)));
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            new SaxAttributes(),
+            nsContext);
+  }
+
+  @Test
+  public void testRequiredAttribute() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        new ArrayList<XmlSchemaStateMachineNode.Attribute>(1);
+
+    attrs.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            requiredAttribute,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE)));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "123.45") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testUnsatisfiedRequiredAttribute() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        new ArrayList<XmlSchemaStateMachineNode.Attribute>(1);
+
+    attrs.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            requiredAttribute,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE)));
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            new SaxAttributes(),
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testEmptyRequiredAttribute() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        new ArrayList<XmlSchemaStateMachineNode.Attribute>(1);
+
+    attrs.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            requiredAttribute,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE)));
+
+    SaxAttributes saxAttrs = new SaxAttributes();
+    saxAttrs.add( new SaxAttribute(REQUIRED, "") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttrs,
+            nsContext);
+  }
+
+  @Test
+  public void onlyOneAttrRequired() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "123.45") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void oneUnsatisfiedRequiredAttr() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE));
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            new SaxAttributes(),
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void optionalAttrsSetRequiredNot() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(OPTIONAL, "123.45") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void attributeHasComplexType() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(true));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "hi") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidDuration() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DURATION));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "P1D") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidDuration() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DURATION));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidDateTime() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DATETIME));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "2014-07-27T12:47:30") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidDateTime() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DATETIME));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidTime() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.TIME));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "12:47:30") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidTime() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.TIME));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidDate() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DATE));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "2014-07-27") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);    
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidDate() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DATE));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidYearMonth() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.YEARMONTH));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "2014-07") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidYearMonth() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.YEARMONTH));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidYear() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.YEAR));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "2014") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidYear() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.YEAR));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidMonthDay() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.MONTHDAY));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "--07-27") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidMonthDay() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.MONTHDAY));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidDay() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DAY));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "---27") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidDay() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DAY));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidMonth() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.MONTH));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "--07") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidMonth() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.MONTH));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidBooleanTrue() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "true") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidBooleanFalse() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "false") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidBoolean() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidBase64() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BIN_BASE64));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidHexadecimal() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BIN_HEX));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "0F00") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidHexadecimal() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BIN_HEX));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidFloat() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.FLOAT));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "12.34") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidFloat() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.FLOAT));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidDecimalWithEmptyRangeFacets() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(
+        XmlSchemaRestriction.Type.EXCLUSIVE_MAX,
+        Collections.<XmlSchemaRestriction>emptyList());
+
+    facets.put(
+        XmlSchemaRestriction.Type.EXCLUSIVE_MIN,
+        Collections.<XmlSchemaRestriction>emptyList());
+
+    facets.put(
+        XmlSchemaRestriction.Type.INCLUSIVE_MAX,
+        Collections.<XmlSchemaRestriction>emptyList());
+
+    facets.put(
+        XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+        Collections.<XmlSchemaRestriction>emptyList());
+
+    List<XmlSchemaStateMachineNode.Attribute> attrs =
+        Collections.singletonList(
+            new XmlSchemaStateMachineNode.Attribute(
+                requiredAttribute,
+                new XmlSchemaTypeInfo(
+                    XmlSchemaBaseSimpleType.DECIMAL, facets)));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "123456789.123456789") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidDecimal() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidDouble() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "12345.12345") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidDouble() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "fail!") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidQName() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.QNAME));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "avro:hi") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidQName() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.QNAME));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "test:failure") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test
+  public void testValidNotation() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.NOTATION));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "avro:one avro:two") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidNotation() throws Exception {
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attrs =
+        buildAttrs(new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.NOTATION));
+
+    SaxAttributes saxAttributes = new SaxAttributes();
+    saxAttributes.add( new SaxAttribute(REQUIRED, "test:fails test:fails") );
+
+    XmlSchemaElementValidator.validateAttributes(
+        new XmlSchemaStateMachineNode(
+            xmlElement,
+            attrs,
+            new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING)),
+            saxAttributes,
+            nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidNonMixedContentType() throws Exception {
+    XmlSchemaTypeInfo typeInfo = new XmlSchemaTypeInfo(false);
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "fail", nsContext);
+  }
+
+  @Test
+  public void testNullNonMixedContentType() throws Exception {
+    XmlSchemaTypeInfo typeInfo = new XmlSchemaTypeInfo(false);
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, null, nsContext);
+  }
+
+  @Test
+  public void testEmptyNonMixedContentType() throws Exception {
+    XmlSchemaTypeInfo typeInfo = new XmlSchemaTypeInfo(false);
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "", nsContext);
+  }
+
+  @Test
+  public void testMixedContentType() throws Exception {
+    XmlSchemaTypeInfo typeInfo = new XmlSchemaTypeInfo(true);
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, null, nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "hi!", nsContext);
+  }
+
+  @Test
+  public void testContentOfValidExclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "125", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-45", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "0", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "1", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-1", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "127", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-127", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentOfTooLowExclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "-150", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentOfLowBorderExclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "-128", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentOfTooHighExclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "150", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentOfHighBorderExclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "128", nsContext);
+  }
+
+  @Test
+  public void testContentOfValidInclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getInclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "128", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-45", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "0", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "1", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-1", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "97", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-128", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentOfTooLowInclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getInclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "-150", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testContentOfTooHighInclusiveNumericRange() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getInclusiveNumericFacets();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "150", nsContext);
+  }
+
+  @Test
+  public void testFloatAndStringBasedRangeCheck() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    ArrayList<XmlSchemaRestriction> minValueInclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    minValueInclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+            new Float(-128.0),
+            false));
+
+    ArrayList<XmlSchemaRestriction> maxValueInclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    maxValueInclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.INCLUSIVE_MAX,
+            "128",
+            false));
+
+    facets.put(XmlSchemaRestriction.Type.INCLUSIVE_MIN, minValueInclRestr);
+    facets.put(XmlSchemaRestriction.Type.INCLUSIVE_MAX, maxValueInclRestr);
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "128", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-45", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "0", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "1", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-1", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "97", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "-128", nsContext);
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testInvalidRangeType() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    ArrayList<XmlSchemaRestriction> minValueInclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    minValueInclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+            new Object(),
+            false));
+
+    facets.put(XmlSchemaRestriction.Type.INCLUSIVE_MAX, minValueInclRestr);
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "128", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidRangeValue() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    ArrayList<XmlSchemaRestriction> minValueInclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    minValueInclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+            "fail!",
+            false));
+
+    facets.put(XmlSchemaRestriction.Type.INCLUSIVE_MAX, minValueInclRestr);
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "128", nsContext);
+  }
+
+  @Test
+  public void testValidStringNoFacets() throws Exception {
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "aser921f",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "\u1234\u5432",
+        nsContext);
+  }
+
+  @Test
+  public void testValidStringLengthRange() throws Exception  {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "12", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "123", nsContext);
+    XmlSchemaElementValidator.validateContent(stateMachine, "1234", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testStringToShortForRange() throws Exception  {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "1", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testStringTooLongForRange() throws Exception  {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345",
+        nsContext);    
+  }
+
+  @Test
+  public void testValidStringLength() throws Exception  {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getLength();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "123", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testStringTooShort() throws Exception  {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getLength();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "12", nsContext);    
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testStringTooLong() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        getLength();
+
+    XmlSchemaTypeInfo typeInfo =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, typeInfo);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "1234", nsContext);    
+  }
+
+  @Test
+  public void testValidArray() throws Exception{
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "1234", nsContext);    
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1 2 3 4",
+        nsContext);  
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "1 23", nsContext);    
+  }
+
+  @Test
+  public void testValidArrayInRange() throws Exception{
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> baseFacets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, baseFacets);
+
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "97 2", nsContext);    
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "-127 0 127",
+        nsContext);    
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "-127 -64 64 127",
+        nsContext);    
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testArrayTooShort() throws Exception{
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> baseFacets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, baseFacets);
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "97", nsContext);    
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testArrayTooLong() throws Exception{
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> baseFacets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, baseFacets);
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1 2 3 4 5",
+        nsContext);    
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testArrayWithInvalidContent() throws Exception{
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> baseFacets =
+        getExclusiveNumericFacets();
+
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, baseFacets);
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLengthRange();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "-128 128",
+        nsContext);    
+  }
+
+  @Test
+  public void testArrayLength() throws Exception {
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLength();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1 2 3",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testArrayLengthTooShort() throws Exception {
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLength();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(stateMachine, "1 2", nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testArrayLengthTooLong() throws Exception {
+    XmlSchemaTypeInfo baseType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING);
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> listFacets =
+        getLength();
+
+    XmlSchemaTypeInfo listType =
+        new XmlSchemaTypeInfo(baseType, listFacets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, listType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1 2 3 4",
+        nsContext);
+  }
+
+  @Test
+  public void testTotalDigitsFacet() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.DIGITS_TOTAL, getTotalDigitsFacet(5));
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "123",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1234",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".1",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".12",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".123",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".1234",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".12345",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1.2",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12.3",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12.34",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12.345",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testTooManyDigitsFacet() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.DIGITS_TOTAL, getTotalDigitsFacet(1));
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12",
+        nsContext);
+  }
+
+  @Test
+  public void testDecimalNoFacets() throws Exception {
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "1234567890.1234567890",
+        nsContext);
+  }
+
+  @Test
+  public void testFractionDigitsFacet() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.DIGITS_FRACTION,
+               getFractionDigitsFacet(5));
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678.",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678.0",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678.01",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678.012",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678.0123",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12345678.01234",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testTooManyFractionDigitsFacet() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.DIGITS_FRACTION,
+               getFractionDigitsFacet(1));
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".12",
+        nsContext);
+  }
+
+  @Test
+  public void testValidNoFractionDigitsFacet() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.DIGITS_FRACTION,
+               getFractionDigitsFacet(0));
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12456789",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "12456789.",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidNoFractionDigitsFacet() throws Exception {
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.DIGITS_FRACTION,
+               getFractionDigitsFacet(0));
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        ".1",
+        nsContext);
+  }
+
+  @Test
+  public void testValidEnumerationFacet() throws Exception {
+    ArrayList<XmlSchemaRestriction> enumeration =
+        new ArrayList<XmlSchemaRestriction>(3);
+
+    enumeration.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "avro",
+            false) );
+
+    enumeration.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "xml",
+            false) );
+
+    enumeration.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "json",
+            false) );
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.ENUMERATION,
+               enumeration);
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "avro",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "xml",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "json",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidEnumerationFacet() throws Exception {
+    ArrayList<XmlSchemaRestriction> enumeration =
+        new ArrayList<XmlSchemaRestriction>(3);
+
+    enumeration.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "avro",
+            false) );
+
+    enumeration.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "xml",
+            false) );
+
+    enumeration.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "json",
+            false) );
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    facets.put(XmlSchemaRestriction.Type.ENUMERATION,
+               enumeration);
+
+    XmlSchemaTypeInfo type =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.STRING, facets);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, type);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "thrift",
+        nsContext);
+  }
+
+  @Test
+  public void testValidUnion() throws Exception {
+    ArrayList<XmlSchemaTypeInfo> unionTypes =
+        new ArrayList<XmlSchemaTypeInfo>(3);
+
+    unionTypes.add( new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN) );
+    unionTypes.add( new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL) );
+    unionTypes.add( new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DATE) );
+
+    XmlSchemaTypeInfo unionType = new XmlSchemaTypeInfo(unionTypes);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, unionType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "true",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "false",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "128.256",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "2014-08-14",
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidUnion() throws Exception {
+    ArrayList<XmlSchemaTypeInfo> unionTypes =
+        new ArrayList<XmlSchemaTypeInfo>(3);
+
+    unionTypes.add( new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.BOOLEAN) );
+    unionTypes.add( new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DECIMAL) );
+    unionTypes.add( new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DATE) );
+
+    XmlSchemaTypeInfo unionType = new XmlSchemaTypeInfo(unionTypes);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(xmlElement, null, unionType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "fail!",
+        nsContext);
+  }
+
+  @Test
+  public void testNillableElement() throws Exception {
+    XmlSchemaElement element = new XmlSchemaElement(xmlSchema, false);
+    element.setNillable(true);
+    element.setName("nillable");
+
+    XmlSchemaTypeInfo elemType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(element, null, elemType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        null,
+        nsContext);
+  }
+
+  @Test
+  public void testElementWithDefault() throws Exception {
+    XmlSchemaElement element = new XmlSchemaElement(xmlSchema, false);
+    element.setNillable(false);
+    element.setDefaultValue("123.456");
+    element.setName("default");
+
+    XmlSchemaTypeInfo elemType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(element, null, elemType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        null,
+        nsContext);
+  }
+
+  @Test
+  public void testFixedElement() throws Exception {
+    XmlSchemaElement element = new XmlSchemaElement(xmlSchema, false);
+    element.setNillable(false);
+    element.setFixedValue("123.456");
+    element.setName("fixed");
+
+    XmlSchemaTypeInfo elemType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(element, null, elemType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        null,
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testNonNillableNonDefaultNonFixedElement() throws Exception {
+    XmlSchemaElement element = new XmlSchemaElement(xmlSchema, false);
+    element.setNillable(false);
+    element.setName("invalid");
+
+    XmlSchemaTypeInfo elemType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(element, null, elemType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        "",
+        nsContext);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        null,
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testElementWithInvalidDefault() throws Exception {
+    XmlSchemaElement element = new XmlSchemaElement(xmlSchema, false);
+    element.setNillable(false);
+    element.setDefaultValue("fail!");
+    element.setName("invalid");
+
+    XmlSchemaTypeInfo elemType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(element, null, elemType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        null,
+        nsContext);
+  }
+
+  @Test(expected=ValidationException.class)
+  public void testInvalidFixedElement() throws Exception {
+    XmlSchemaElement element = new XmlSchemaElement(xmlSchema, false);
+    element.setNillable(false);
+    element.setFixedValue("fail!");
+    element.setName("invalid");
+
+    XmlSchemaTypeInfo elemType =
+        new XmlSchemaTypeInfo(XmlSchemaBaseSimpleType.DOUBLE);
+
+    XmlSchemaStateMachineNode stateMachine =
+        new XmlSchemaStateMachineNode(element, null, elemType);
+
+    XmlSchemaElementValidator.validateContent(
+        stateMachine,
+        null,
+        nsContext);
+  }
+
+  private static ArrayList<XmlSchemaStateMachineNode.Attribute> buildAttrs(
+      XmlSchemaTypeInfo attrType) {
+
+    ArrayList<XmlSchemaStateMachineNode.Attribute> attributes =
+        new ArrayList<XmlSchemaStateMachineNode.Attribute>(3);
+
+    attributes.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            prohibitedAttribute,
+            attrType));
+
+    attributes.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            requiredAttribute,
+            attrType));
+
+    attributes.add(
+        new XmlSchemaStateMachineNode.Attribute(
+            optionalAttribute,
+            attrType));
+
+    return attributes;
+  }
+
+  private static HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+      getExclusiveNumericFacets() {
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    ArrayList<XmlSchemaRestriction> minValueExclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    minValueExclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.EXCLUSIVE_MIN,
+            new Integer(-128),
+            false));
+
+    ArrayList<XmlSchemaRestriction> maxValueExclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    maxValueExclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.EXCLUSIVE_MAX,
+            new Double(128.0),
+            false));
+
+    facets.put(XmlSchemaRestriction.Type.EXCLUSIVE_MIN, minValueExclRestr);
+    facets.put(XmlSchemaRestriction.Type.EXCLUSIVE_MAX, maxValueExclRestr);
+
+    return facets;
+  }
+
+  private static HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+      getInclusiveNumericFacets() {
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    ArrayList<XmlSchemaRestriction> minValueInclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    minValueInclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+            new BigInteger("-128"),
+            false));
+
+    ArrayList<XmlSchemaRestriction> maxValueInclRestr =
+        new ArrayList<XmlSchemaRestriction>(1);
+
+    maxValueInclRestr.add(
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.INCLUSIVE_MAX,
+            new BigDecimal(128),
+            false));
+
+    facets.put(XmlSchemaRestriction.Type.INCLUSIVE_MIN, minValueInclRestr);
+    facets.put(XmlSchemaRestriction.Type.INCLUSIVE_MAX, maxValueInclRestr);
+
+    return facets;
+  }
+
+  private static HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+      getLengthRange() {
+
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    List<XmlSchemaRestriction> minList =
+        Collections.<XmlSchemaRestriction>singletonList(
+            new XmlSchemaRestriction(
+                XmlSchemaRestriction.Type.LENGTH_MIN,
+                "2",
+                false));
+
+    List<XmlSchemaRestriction> maxList =
+        Collections.<XmlSchemaRestriction>singletonList(
+            new XmlSchemaRestriction(
+                XmlSchemaRestriction.Type.LENGTH_MIN,
+                "4",
+                false));
+
+    facets.put(XmlSchemaRestriction.Type.LENGTH_MIN, minList);
+    facets.put(XmlSchemaRestriction.Type.LENGTH_MAX, maxList);
+
+    return facets;
+  }
+
+  private static HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>
+      getLength() {
+    
+    HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>> facets =
+        new HashMap<XmlSchemaRestriction.Type, List<XmlSchemaRestriction>>();
+
+    List<XmlSchemaRestriction> facet =
+        Collections.<XmlSchemaRestriction>singletonList(
+            new XmlSchemaRestriction(
+                XmlSchemaRestriction.Type.LENGTH,
+                "3",
+                false));
+
+    facets.put(XmlSchemaRestriction.Type.LENGTH, facet);
+
+    return facets;
+  }
+
+  private static List<XmlSchemaRestriction> getTotalDigitsFacet(int value) {
+    List<XmlSchemaRestriction> facet =
+        Collections.<XmlSchemaRestriction>singletonList(
+            new XmlSchemaRestriction(
+                XmlSchemaRestriction.Type.DIGITS_TOTAL,
+                value,
+                false));
+
+    return facet;
+  }
+
+  private static List<XmlSchemaRestriction> getFractionDigitsFacet(int value) {
+    List<XmlSchemaRestriction> facet =
+        Collections.<XmlSchemaRestriction>singletonList(
+            new XmlSchemaRestriction(
+                XmlSchemaRestriction.Type.DIGITS_FRACTION,
+                value,
+                false));
+
+    return facet;
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaNamespaceContext.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaNamespaceContext.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaNamespaceContext.java	(working copy)
@@ -0,0 +1,285 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import static org.junit.Assert.*;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.avro.xml.XmlSchemaNamespaceContext;
+import org.apache.ws.commons.schema.constants.Constants;
+import org.junit.Test;
+
+public class TestXmlSchemaNamespaceContext {
+
+  @Test
+  public void test() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+
+    assertEquals(2, nsContext.getDeclaredPrefixes().length);
+    assertArrayEquality(
+        new String[] { Constants.XML_NS_PREFIX, Constants.XMLNS_ATTRIBUTE },
+        nsContext.getDeclaredPrefixes());
+
+    Map<String, String> expPrefixToNsMap = new HashMap<String, String>();
+    expPrefixToNsMap.put(Constants.XML_NS_PREFIX, Constants.XML_NS_URI);
+    expPrefixToNsMap.put(
+        Constants.XMLNS_ATTRIBUTE,
+        Constants.XMLNS_ATTRIBUTE_NS_URI);
+
+    Map<String, String[]> expNsToPrefixMap =
+        new HashMap<String, String[]>();
+
+    expNsToPrefixMap.put(Constants.XML_NS_URI,
+        new String[] { Constants.XML_NS_PREFIX });
+
+    expNsToPrefixMap.put(
+        Constants.XMLNS_ATTRIBUTE_NS_URI,
+        new String[] { Constants.XMLNS_ATTRIBUTE });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // "avro" -> "http://avro.apache.org/AvroTest"
+    final String avroPrefix = "avro";
+    final String avroNs = "http://avro.apache.org/AvroTest";
+
+    nsContext.addNamespace(avroPrefix, avroNs);
+    expPrefixToNsMap.put(avroPrefix, avroNs);
+    expNsToPrefixMap.put(avroNs, new String[] { avroPrefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // "dei" -> "http://xbrl.sec.gov/dei/2012-01-31"
+    final String deiPrefix = "dei";
+    final String deiNs = "http://xbrl.sec.gov/dei/2012-01-31";
+
+    nsContext.addNamespace(deiPrefix, deiNs);
+    expPrefixToNsMap.put(deiPrefix, deiNs);
+    expNsToPrefixMap.put(deiNs, new String[] { deiPrefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // "iso4217" -> "http://www.xbrl.org/2003/iso4217"
+    final String iso4217Prefix = "iso4217";
+    final String iso4217Ns = "http://www.xbrl.org/2003/iso4217";
+
+    nsContext.addNamespace(iso4217Prefix, iso4217Ns);
+    expPrefixToNsMap.put(iso4217Prefix, iso4217Ns);
+    expNsToPrefixMap.put(iso4217Ns, new String[] { iso4217Prefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Attach "dei" to "http://www.xbrl.org/2003/iso4217"
+    nsContext.addNamespace(deiPrefix, iso4217Ns);
+    expPrefixToNsMap.put(deiPrefix, iso4217Ns);
+    expNsToPrefixMap.put(iso4217Ns, new String[] { iso4217Prefix, deiPrefix });
+    expNsToPrefixMap.remove(deiNs);
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Attach "iso4217" to "http://xbrl.sec.gov/dei/2012-01-31"
+    nsContext.addNamespace(iso4217Prefix, deiNs);
+    expPrefixToNsMap.put(iso4217Prefix, deiNs);
+    expNsToPrefixMap.put(deiNs, new String[] { iso4217Prefix });
+    expNsToPrefixMap.put(iso4217Ns, new String[] { deiPrefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Remove "dei" to "http://www.xbrl.org/2003/iso4217" mapping.
+    nsContext.removeNamespace(deiPrefix);
+    expPrefixToNsMap.put(deiPrefix, deiNs);
+    expNsToPrefixMap.put(deiNs, new String[] { iso4217Prefix, deiPrefix });
+    expNsToPrefixMap.remove(iso4217Ns);
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Remove "iso4217" to "http://xbrl.sec.gov/dei/2012-01-31" mapping.
+    nsContext.removeNamespace(iso4217Prefix);
+    expPrefixToNsMap.put(iso4217Prefix, iso4217Ns);
+    expNsToPrefixMap.put(deiNs, new String[] { deiPrefix });
+    expNsToPrefixMap.put(iso4217Ns, new String[] { iso4217Prefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Remove "iso4217" to "http://www.xbrl.org/2003/iso4217" mapping.
+    nsContext.removeNamespace(iso4217Prefix);
+    expPrefixToNsMap.remove(iso4217Prefix);
+    expNsToPrefixMap.remove(iso4217Ns);
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Remove "dei" to "http:///xbrl.sec.gov/dei/2012-01-31"
+    nsContext.removeNamespace(deiPrefix);
+    expPrefixToNsMap.remove(deiPrefix);
+    expNsToPrefixMap.remove(deiNs);
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Try to remove a dead prefix.
+    try {
+      nsContext.removeNamespace(deiPrefix);
+      fail("Should not have been able to remove " + deiPrefix);
+    } catch (IllegalStateException ise) {
+      // Passes.
+    }
+
+    // Add the dei namespace back in under the avro namespace.
+    nsContext.addNamespace(deiPrefix, avroNs);
+    expPrefixToNsMap.put(deiPrefix, avroNs);
+    expNsToPrefixMap.put(avroNs, new String[] { deiPrefix, avroPrefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    // Remove the "avro" to "http://avro.apache.org/AvroTest" mapping.
+    nsContext.removeNamespace(avroPrefix);
+    expPrefixToNsMap.remove(avroPrefix);
+    expNsToPrefixMap.put(avroNs, new String[] { deiPrefix });
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+
+    nsContext.removeNamespace(deiPrefix);
+    expPrefixToNsMap.remove(deiPrefix);
+    expNsToPrefixMap.remove(avroNs);
+
+    assertEquality(expPrefixToNsMap, expNsToPrefixMap, nsContext);
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testNullPrefixForNamespace() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    nsContext.getNamespaceURI(null);
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testNullNamespaceForPrefix() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    nsContext.getPrefix(null);
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testAddNullNamespaceAndPrefix() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    nsContext.addNamespace(null, null);
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testAddNullNamespaceWithPrefix() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    nsContext.addNamespace("avro", null);
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testAddEmptyNamespaceWithPrefix() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    nsContext.addNamespace("avro", "");
+  }
+
+  @Test(expected=IllegalArgumentException.class)
+  public void testGetPrefixesWithNullNamespace() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    nsContext.getPrefixes(null);
+  }
+
+  @Test
+  public void testNamespaceNotFound() {
+    XmlSchemaNamespaceContext nsContext = new XmlSchemaNamespaceContext();
+    assertNull( nsContext.getPrefix("urn:avro:test") );
+    assertEquals(Constants.NULL_NS_URI, nsContext.getNamespaceURI("avro"));
+  }
+
+  static void assertEquality(
+      Map<String, String> expPrefixToNamespace,
+      Map<String, String[]> expNsToPrefix,
+      XmlSchemaNamespaceContext actual) {
+
+    final Set<String> pfxKeys = expPrefixToNamespace.keySet();
+    final String[] prefixes = pfxKeys.toArray(new String[pfxKeys.size()]);
+
+    assertArrayEquality(prefixes, actual.getDeclaredPrefixes());
+
+    for (String prefix : prefixes) {
+      final String expNamespace = expPrefixToNamespace.get(prefix);
+
+      assertEquals(
+          expNamespace,
+          actual.getNamespaceURI(prefix));
+    }
+
+    for (String expNamespace: expNsToPrefix.keySet()) {
+      final String[] expPrefixes = expNsToPrefix.get(expNamespace);
+
+      assertArrayEquality(
+          expPrefixes,
+          actual.getPrefixes(expNamespace));
+
+      final String firstPrefix = actual.getPrefix(expNamespace);
+      boolean found = false;
+      for (int pfxIdx = 0; pfxIdx < expPrefixes.length; ++pfxIdx) {
+        if (expPrefixes[pfxIdx].equals(firstPrefix)) {
+          found = true;
+          break;
+        }
+      }
+
+      assertTrue("Could not find \""
+                 + firstPrefix
+                 + "\" in the expected prefix list.",
+                 found);
+
+    }
+  }
+
+  static void assertArrayEquality(String[] expected, String[] actual) {
+    assertEquals(expected.length, actual.length);
+
+    int found = 0;
+    for (int expIndex = 0; expIndex < expected.length; ++expIndex) {
+      for (int actIndex = 0; actIndex < actual.length; ++actIndex) {
+        if (expected[expIndex].equals(actual[actIndex])) {
+          ++found;
+          break;
+        }
+      }
+    }
+    assertEquals(expected.length, found);
+  }
+
+  static void assertArrayEquality(String[] expected, Iterator actual) {
+    HashSet<String> expSet = new HashSet<String>();
+    for (String exp : expected) {
+      expSet.add(exp);
+    }
+
+    while ( actual.hasNext() ) {
+      final String next = actual.next().toString();
+      assertTrue(
+          "Could not find " + next + " in the expected set.",
+          expSet.contains(next));
+      expSet.remove(next);
+    }
+
+    if (!expSet.isEmpty()) {
+      fail("The expected list has more elements than the actual.");
+    }
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaRestriction.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaRestriction.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/TestXmlSchemaRestriction.java	(working copy)
@@ -0,0 +1,513 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+
+import org.apache.avro.xml.XmlSchemaRestriction;
+import org.apache.avro.xml.XmlSchemaScope;
+import org.apache.ws.commons.schema.XmlSchemaEnumerationFacet;
+import org.apache.ws.commons.schema.XmlSchemaFacet;
+import org.apache.ws.commons.schema.XmlSchemaFractionDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxExclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMaxLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinExclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinInclusiveFacet;
+import org.apache.ws.commons.schema.XmlSchemaMinLengthFacet;
+import org.apache.ws.commons.schema.XmlSchemaPatternFacet;
+import org.apache.ws.commons.schema.XmlSchemaTotalDigitsFacet;
+import org.apache.ws.commons.schema.XmlSchemaWhiteSpaceFacet;
+import org.junit.Test;
+
+public class TestXmlSchemaRestriction {
+
+  @Test
+  public void testWhitespaceCollapseFixed() {
+    XmlSchemaWhiteSpaceFacet collapseFixed =
+        new XmlSchemaWhiteSpaceFacet("collapse", true);
+
+    assertEquality(
+        collapseFixed,
+        XmlSchemaRestriction.Type.WHITESPACE,
+        new XmlSchemaRestriction(collapseFixed));
+  }
+
+  @Test
+  public void tesetWhitespaceCollapseNotFixed() {
+    XmlSchemaWhiteSpaceFacet collapseNotFixed =
+        new XmlSchemaWhiteSpaceFacet("collapse", false);
+
+    assertEquality(
+        collapseNotFixed,
+        XmlSchemaRestriction.Type.WHITESPACE,
+        new XmlSchemaRestriction(collapseNotFixed));
+
+  }
+
+  @Test
+  public void testWhitespacePreserveFixed() {
+    XmlSchemaWhiteSpaceFacet preserveFixed =
+        new XmlSchemaWhiteSpaceFacet("preserve", true);
+
+    assertEquality(
+        preserveFixed,
+        XmlSchemaRestriction.Type.WHITESPACE,
+        new XmlSchemaRestriction(preserveFixed));
+  }
+
+  @Test
+  public void testWhitespacePreserveNotFixed() {
+    XmlSchemaWhiteSpaceFacet preserveNotFixed =
+        new XmlSchemaWhiteSpaceFacet("preserve", false);
+
+    assertEquality(
+        preserveNotFixed,
+        XmlSchemaRestriction.Type.WHITESPACE,
+        new XmlSchemaRestriction(preserveNotFixed));
+  }
+
+  @Test
+  public void testWhitespaceReplaceFixed() {
+
+    XmlSchemaWhiteSpaceFacet replaceFixed =
+        new XmlSchemaWhiteSpaceFacet("replace", true);
+
+    assertEquality(
+        replaceFixed,
+        XmlSchemaRestriction.Type.WHITESPACE,
+        new XmlSchemaRestriction(replaceFixed));
+  }
+
+  @Test
+  public void testWhitespaceReplaceNotFixed() {
+    XmlSchemaWhiteSpaceFacet replaceNotFixed =
+        new XmlSchemaWhiteSpaceFacet("replace", false);
+
+    assertEquality(
+        replaceNotFixed,
+        XmlSchemaRestriction.Type.WHITESPACE,
+        new XmlSchemaRestriction(replaceNotFixed));
+  }
+
+  @Test
+  public void testEnumerationFacetFixed() {
+    XmlSchemaEnumerationFacet facet =
+        new XmlSchemaEnumerationFacet("123", true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.ENUMERATION,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testEnumerationFacetNotFixed() {
+    XmlSchemaEnumerationFacet facet =
+        new XmlSchemaEnumerationFacet("avro", false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.ENUMERATION,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testExclusiveMaxFixed() {
+    XmlSchemaMaxExclusiveFacet facet =
+        new XmlSchemaMaxExclusiveFacet(new Integer(1234), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.EXCLUSIVE_MAX,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testExclusiveMaxNotFixed() {
+    XmlSchemaMaxExclusiveFacet facet =
+        new XmlSchemaMaxExclusiveFacet(new Integer(1234), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.EXCLUSIVE_MAX,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testExclusiveMinFixed() {
+    XmlSchemaMinExclusiveFacet facet =
+        new XmlSchemaMinExclusiveFacet(new Integer(1234), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.EXCLUSIVE_MIN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testExclusiveMinNotFixed() {
+    XmlSchemaMinExclusiveFacet facet =
+        new XmlSchemaMinExclusiveFacet(new Integer(1234), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.EXCLUSIVE_MIN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testInclusiveMinFixed() {
+    XmlSchemaMinInclusiveFacet facet =
+        new XmlSchemaMinInclusiveFacet(new Integer(1234), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testInclusiveMinNotFixed() {
+    XmlSchemaMinInclusiveFacet facet =
+        new XmlSchemaMinInclusiveFacet(new Integer(1234), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.INCLUSIVE_MIN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testInclusiveMaxFixed() {
+    XmlSchemaMaxInclusiveFacet facet =
+        new XmlSchemaMaxInclusiveFacet(new Integer(1234), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.INCLUSIVE_MAX,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testInclusiveMaxNotFixed() {
+    XmlSchemaMaxInclusiveFacet facet =
+        new XmlSchemaMaxInclusiveFacet(new Integer(1234), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.INCLUSIVE_MAX,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testDigitsFractionFixed() {
+    XmlSchemaFractionDigitsFacet facet =
+        new XmlSchemaFractionDigitsFacet(new Integer(0), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.DIGITS_FRACTION,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testDigitsFractionNotFixed() {
+    XmlSchemaFractionDigitsFacet facet =
+        new XmlSchemaFractionDigitsFacet(new Integer(0), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.DIGITS_FRACTION,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testDigitsTotalFixed() {
+    XmlSchemaTotalDigitsFacet facet =
+        new XmlSchemaTotalDigitsFacet(new Integer(0), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.DIGITS_TOTAL,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testDigitsTotalNotFixed() {
+    XmlSchemaTotalDigitsFacet facet =
+        new XmlSchemaTotalDigitsFacet(new Integer(0), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.DIGITS_TOTAL,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testPatternFacetFixed() {
+    XmlSchemaPatternFacet facet =
+        new XmlSchemaPatternFacet("[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*", true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.PATTERN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testPatternFacetNotFixed() {
+    XmlSchemaPatternFacet facet =
+        new XmlSchemaPatternFacet("[\\i-[:]][\\c-[:]]*", false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.PATTERN,
+        new XmlSchemaRestriction(facet));    
+  }
+
+  @Test
+  public void testLengthFacetFixed() {
+    XmlSchemaLengthFacet facet =
+        new XmlSchemaLengthFacet(new Integer(1), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.LENGTH,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testLengthFacetNotFixed() {
+    XmlSchemaLengthFacet facet =
+        new XmlSchemaLengthFacet(new Integer(1000), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.LENGTH,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testLengthMinFacetFixed() {
+    XmlSchemaMinLengthFacet facet =
+        new XmlSchemaMinLengthFacet(new Integer(1), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.LENGTH_MIN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testLengthMinFacetNotFixed() {
+    XmlSchemaMinLengthFacet facet =
+        new XmlSchemaMinLengthFacet(new Integer(10), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.LENGTH_MIN,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testLengthMaxFacetFixed() {
+    XmlSchemaMaxLengthFacet facet =
+        new XmlSchemaMaxLengthFacet(new Integer(256), true);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.LENGTH_MAX,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testLengthMaxFacetNotFixed() {
+    XmlSchemaMaxLengthFacet facet =
+        new XmlSchemaMaxLengthFacet(new Integer(128), false);
+
+    assertEquality(
+        facet,
+        XmlSchemaRestriction.Type.LENGTH_MAX,
+        new XmlSchemaRestriction(facet));
+  }
+
+  @Test
+  public void testTypeConstructor() {
+    XmlSchemaRestriction rstr =
+        new XmlSchemaRestriction(XmlSchemaRestriction.Type.DIGITS_TOTAL);
+
+    assertEquals(XmlSchemaRestriction.Type.DIGITS_TOTAL, rstr.getType());
+    assertNull( rstr.getValue() );
+    assertFalse( rstr.isFixed() );
+  }
+
+  @Test
+  public void testFullConstructor() {
+    XmlSchemaRestriction rstr =
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.PATTERN,
+            "[\\-+]?[0-9]+",
+            true);
+
+    assertEquals(XmlSchemaRestriction.Type.PATTERN, rstr.getType());
+    assertEquals("[\\-+]?[0-9]+", rstr.getValue());
+    assertTrue( rstr.isFixed() );
+  }
+
+  @Test
+  public void testSetters() {
+    XmlSchemaRestriction rstr =
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.WHITESPACE,
+            "collapse",
+            true);
+
+    assertEquals(XmlSchemaRestriction.Type.WHITESPACE, rstr.getType());
+    assertEquals("collapse", rstr.getValue());
+    assertTrue( rstr.isFixed() );
+
+    rstr.setValue("replace");
+
+    assertEquals(XmlSchemaRestriction.Type.WHITESPACE, rstr.getType());
+    assertEquals("replace", rstr.getValue());
+    assertTrue( rstr.isFixed() );
+
+    rstr.setFixed(false);
+
+    assertEquals(XmlSchemaRestriction.Type.WHITESPACE, rstr.getType());
+    assertEquals("replace", rstr.getValue());
+    assertFalse( rstr.isFixed() );
+  }
+
+  /**
+   * Enumerations are the only restriction where the value and fixedness
+   * factor into the equality check and hash code generation.  When building
+   * {@link XmlSchemaScope}s, only {@link XmlSchemaEnumerationFacet}s are
+   * allowed to have multiple values.
+   */
+  @Test
+  public void testEnumerationEqualsAndHashCode() {
+    XmlSchemaRestriction enum1 =
+        new XmlSchemaRestriction(XmlSchemaRestriction.Type.ENUMERATION);
+
+    XmlSchemaRestriction enum2 =
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.ENUMERATION,
+            "avro",
+            false);
+
+    assertFalse( enum1.equals(enum2) );
+    assertFalse(enum1.hashCode() == enum2.hashCode());
+
+    enum1.setValue("avro");
+    assertTrue( enum1.equals(enum2) );
+    assertTrue(enum1.hashCode() == enum2.hashCode());
+
+    enum2.setFixed(true);
+
+    assertFalse( enum1.equals(enum2) );
+    assertFalse(enum1.hashCode() == enum2.hashCode());
+
+    enum1.setFixed(true);
+
+    assertTrue( enum1.equals(enum2) );
+    assertTrue(enum1.hashCode() == enum2.hashCode());
+  }
+
+  public void testPatternEqualsAndHashCode() {
+    XmlSchemaRestriction pattern1 =
+        new XmlSchemaRestriction(XmlSchemaRestriction.Type.PATTERN);
+
+    XmlSchemaRestriction pattern2 =
+        new XmlSchemaRestriction(
+            XmlSchemaRestriction.Type.PATTERN,
+            "\\i\\c*",
+            false);
+
+    assertFalse( pattern1.equals(pattern2) );
+    assertFalse(pattern1.hashCode() == pattern2.hashCode());
+
+    pattern1.setValue("\\i\\c*");
+    assertTrue( pattern1.equals(pattern2) );
+    assertTrue(pattern1.hashCode() == pattern2.hashCode());
+
+    pattern2.setFixed(true);
+
+    assertFalse( pattern1.equals(pattern2) );
+    assertFalse(pattern1.hashCode() == pattern2.hashCode());
+
+    pattern1.setFixed(true);
+
+    assertTrue( pattern1.equals(pattern2) );
+    assertTrue(pattern1.hashCode() == pattern2.hashCode());
+  }
+
+  @Test
+  public void testAllOtherEqualsAndHashCode() {
+    ArrayList<XmlSchemaRestriction.Type> allOtherTypes =
+        new ArrayList<XmlSchemaRestriction.Type>(11);
+
+    allOtherTypes.add(XmlSchemaRestriction.Type.EXCLUSIVE_MAX);
+    allOtherTypes.add(XmlSchemaRestriction.Type.EXCLUSIVE_MIN);
+    allOtherTypes.add(XmlSchemaRestriction.Type.INCLUSIVE_MAX);
+    allOtherTypes.add(XmlSchemaRestriction.Type.INCLUSIVE_MIN);
+    allOtherTypes.add(XmlSchemaRestriction.Type.DIGITS_FRACTION);
+    allOtherTypes.add(XmlSchemaRestriction.Type.DIGITS_TOTAL);
+    allOtherTypes.add(XmlSchemaRestriction.Type.WHITESPACE);
+    allOtherTypes.add(XmlSchemaRestriction.Type.LENGTH);
+    allOtherTypes.add(XmlSchemaRestriction.Type.LENGTH_MIN);
+    allOtherTypes.add(XmlSchemaRestriction.Type.LENGTH_MAX);
+
+    for (XmlSchemaRestriction.Type type : allOtherTypes) {
+      XmlSchemaRestriction rstr1 = new XmlSchemaRestriction(type);
+
+      XmlSchemaRestriction rstr2 =
+          new XmlSchemaRestriction(
+              type,
+              "1234",
+              false);
+
+      assertTrue( rstr1.equals(rstr2) );
+      assertTrue(rstr1.hashCode() == rstr2.hashCode());
+
+      rstr1.setValue(new Integer(0));
+
+      assertTrue( rstr1.equals(rstr2) );
+      assertTrue(rstr1.hashCode() == rstr2.hashCode());
+    }
+  }
+
+  private static void assertEquality(
+      XmlSchemaFacet expFacet,
+      XmlSchemaRestriction.Type expType,
+      XmlSchemaRestriction actual) {
+
+    assertEquals(
+        "Expected Type: " + expType + "; Actual Type: " + actual.getType(),
+        expType,
+        actual.getType());
+
+    assertEquals(expType.toString(), expFacet.getValue(), actual.getValue());
+    assertEquals(expType.toString(), expFacet.isFixed(), actual.isFixed());
+  }
+}
Index: lang/java/xml/src/test/java/org/apache/avro/xml/UtilsForTests.java
===================================================================
--- lang/java/xml/src/test/java/org/apache/avro/xml/UtilsForTests.java	(revision 0)
+++ lang/java/xml/src/test/java/org/apache/avro/xml/UtilsForTests.java	(working copy)
@@ -0,0 +1,217 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.avro.xml;
+
+import static org.junit.Assert.*;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+
+import org.apache.avro.Schema;
+import org.custommonkey.xmlunit.DetailedDiff;
+import org.custommonkey.xmlunit.XMLUnit;
+import org.w3c.dom.Document;
+
+/**
+ * Utilities to:
+ *
+ * <ul>
+ *   <li>Compare two {@link Document}s for equivalence.</li>
+ *   <li>Compare two Avro {@link Schema}s for equivalence</li>
+ *   <li>Build a file path in a cross-platform way.</li>
+ * </ul>
+ */
+final class UtilsForTests {
+
+  static void assertEquivalent(Document expected, Document actual) {
+    XMLUnit.setIgnoreWhitespace(true);
+    XMLUnit.setIgnoreAttributeOrder(true);
+
+    DetailedDiff diff = new DetailedDiff(XMLUnit.compareXML(expected, actual));
+
+    assertTrue(
+        "Differences found: " + diff.toString(),
+        diff.similar());
+  }
+
+  static void assertEquivalent(Schema expected, Schema actual) {
+    assertEquivalent(expected, actual, new HashSet<String>());
+  }
+
+  private static void assertEquivalent(
+      Schema expected,
+      Schema actual,
+      HashSet<String> recordsSeen) {
+
+    assertEquals(expected.getFullName() + " vs. " + actual.getFullName(),
+                 expected.getType(),
+                 actual.getType());
+
+    switch ( expected.getType() ) {
+    case ARRAY:
+      assertEquivalent(
+          expected.getElementType(),
+          actual.getElementType(),
+          recordsSeen);
+      break;
+    case MAP:
+      assertEquivalent(
+          expected.getValueType(),
+          actual.getValueType(),
+          recordsSeen);
+      break;
+    case UNION:
+      {
+        List<Schema> expSchemas = expected.getTypes();
+        HashMap<String, Schema> expFullNames = new HashMap<String, Schema>();
+        for (Schema expSchema : expSchemas) {
+          expFullNames.put(expSchema.getFullName(), expSchema);
+        }
+        for (Schema actualSchema : actual.getTypes()) {
+          assertTrue(
+              "Cannot find field "
+              + actualSchema.getFullName()
+              + " in "
+              + expected.getFullName(),
+              expFullNames.containsKey( actualSchema.getFullName() ) );
+
+          Schema expSchema = expFullNames.remove( actualSchema.getFullName() );
+          assertEquivalent(expSchema, actualSchema, recordsSeen);
+        }
+        assertTrue( expFullNames.isEmpty() );
+        break;
+      }
+    case FIXED:
+      {
+        assertEquals(expected.getFullName(), actual.getFullName());
+        assertEquals(expected.getFixedSize(), actual.getFixedSize());
+        break;
+      }
+    case ENUM:
+      {
+        assertEquals(expected.getFullName(), actual.getFullName());
+        final int numActualSymbols = actual.getEnumSymbols().size();
+        final List<String> expectedSymbols = expected.getEnumSymbols();
+        assertEquals(expectedSymbols.size(), numActualSymbols);
+        for (String expSym : expectedSymbols) {
+          try {
+            actual.getEnumOrdinal(expSym);
+          } catch (Exception e) {
+            fail("Expected Symbol \""
+                 + expSym
+                 + "\" in enum "
+                 + expected.getFullName()
+                 + " has no equivalent in actual.");
+          }
+        }
+        break;
+      }
+    case RECORD:
+      {
+        assertEquals(expected.getFullName(), actual.getFullName());
+
+        // Prevents infinite recursive descent.
+        if ( !recordsSeen.contains( expected.getFullName() ) ) {
+          recordsSeen.add( expected.getFullName() );
+
+          List<Schema.Field> expFields = expected.getFields();
+
+          if (expFields.size() != actual.getFields().size()) {
+            HashSet<String> expectedFields = new HashSet<String>();
+            for (Schema.Field expField : expFields) {
+              expectedFields.add(expField.name());
+            }
+
+            HashSet<String> actualFields = new HashSet<String>();
+            for (Schema.Field actualField : actual.getFields()) {
+              actualFields.add(actualField.name());
+            }
+
+            List<String> foundExpectedFields = new ArrayList<String>();
+            for (String expField : expectedFields) {
+              if (actualFields.contains(expField)) {
+                foundExpectedFields.add(expField);
+                actualFields.remove(expField);
+              }
+            }
+            for (String foundExpectedField : foundExpectedFields) {
+              expectedFields.remove(foundExpectedField);
+            }
+
+            System.err.println("Missing Expected Fields:");
+            for (String expField : expectedFields) {
+              System.err.println('\t' + expField);
+            }
+            System.err.println("Unexpected Actual Fields:");
+            for (String actField : actualFields) {
+              System.err.println('\t' + actField);
+            }
+          }
+
+          assertEquals(
+              expected.getFullName(),
+              expFields.size(),
+              actual.getFields().size());
+
+          for (Schema.Field expField : expFields) {
+            Schema.Field actualField = actual.getField( expField.name() );
+            assertNotNull(expected.getFullName() + " field " + expField.name(),
+                          actualField);
+
+            assertEquals(expected.getFullName() + " field " + expField.name(),
+                         expField.doc(),
+                         actualField.doc());
+
+            assertEquals(expected.getFullName() + " field " + expField.name(),
+                         expField.order(),
+                         actualField.order());
+
+            assertEquals(expected.getFullName() + " field " + expField.name(),
+                         expField.defaultValue(),
+                         actualField.defaultValue());
+
+            assertEquivalent(expField.schema(),
+                             actualField.schema(),
+                             recordsSeen);
+          }
+        }
+        break;
+      }
+    default:
+      // All primitive types are equal if their types are.
+    }
+  }
+
+  static File buildFile(String... parts) {
+    File file = null;
+
+    for (String part : parts) {
+      if (file == null) {
+        file = new File(part);
+      } else {
+        file = new File(file, part);
+      }
+    }
+
+    return file;
+  }
+}
Index: lang/java/xml/src/test/resources/complex_schema.xsd
===================================================================
--- lang/java/xml/src/test/resources/complex_schema.xsd	(revision 0)
+++ lang/java/xml/src/test/resources/complex_schema.xsd	(working copy)
@@ -0,0 +1,269 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="urn:avro:complex_schema" xmlns:avro="urn:avro:complex_schema" elementFormDefault="qualified">
+	<element name="root" abstract="true" />
+	<element name="realRoot" substitutionGroup="avro:root">
+		<complexType>
+			<sequence>
+				<element ref="avro:backtrack"     />
+				<element ref="avro:allTheThings"  />
+				<element ref="avro:prohibit"      />
+				<element ref="avro:anyAndFriends" />
+				<element name="simpleExtension"   type="avro:grandchildType"           minOccurs="0" maxOccurs="1" />
+				<element name="simpleRestriction" type="avro:simpleContentRestriction" minOccurs="0" maxOccurs="1" />
+				<element name="complexExtension"  type="avro:complexExtension"         minOccurs="0" maxOccurs="1" />
+				<element ref="avro:mixedType" minOccurs="0" maxOccurs="1" />
+			</sequence>
+			<attribute name="year"  type="gYear"  fixed="2014"    />
+			<attribute name="month" type="gMonth" default="--08"  />
+			<attribute name="day"   type="gDay"   default="---12" />
+		</complexType>
+	</element>
+	<element name="backtrack">
+		<annotation>
+			<documentation>
+				This forces backtracking through the different schema options.
+				Consider the following elements:
+				&lt;backtrack&gt;
+				   &lt;qName&gt;avro:qName&lt;/qName&gt;
+				   &lt;avroEnum&gt;avro&lt;/avroEnum&gt;
+				   &lt;xmlEnum&gt;rest.li&lt;/xmlEnum&gt;
+				   &lt;xmlEnum&gt;xml&lt;/xmlEnum&gt;
+				   &lt;unsignedLongList&gt;18446744073709551615 1844674407370955 12579&lt;/unsignedLongList&gt;
+				   &lt;listOfUnion&gt;true 18446744073709551616 false -2147483648 -1234.567 avro&lt;/listOfUnion&gt;
+				&lt;/backtrack&gt;
+				The first four elements in the list can match either the first choice
+				group or the second sequence group, and by default the first branch will
+				be taken.  It is not until the last child element, &lt;listOfUnion&gt;,
+				is reached, that it becomes clear the choice group should not be followed.
+			</documentation>
+		</annotation>
+		<complexType>
+			<sequence>
+				<choice minOccurs="0" maxOccurs="2">
+					<choice minOccurs="1" maxOccurs="3">
+						<element ref="avro:qName"    />
+						<element ref="avro:avroEnum" />
+						<element ref="avro:xmlEnum"  />
+					</choice>
+					<sequence>
+						<element ref="avro:xmlEnum"          />
+						<element ref="avro:unsignedLongList" />
+					</sequence>
+				</choice>
+				<sequence>
+					<element ref="avro:qName"                 />
+					<element ref="avro:avroEnum"              />
+					<element ref="avro:xmlEnum" maxOccurs="2" />
+					<element ref="avro:unsignedLongList"      />
+					<element ref="avro:listOfUnion"           />
+				</sequence>
+			</sequence>
+		</complexType>
+	</element>
+	<element name="qName">
+		<simpleType>
+			<restriction base="QName">
+				<minLength value="1" />
+				<maxLength value="256" />
+			</restriction>
+		</simpleType>
+	</element>
+	<element name="avroEnum">
+		<simpleType>
+			<restriction base="string">
+				<enumeration value="xml"      />
+				<enumeration value="json"     />
+				<enumeration value="avro"     />
+				<enumeration value="thrift"   />
+				<enumeration value="protobuf" />
+				<enumeration value="rest_li"  />
+			</restriction>
+		</simpleType>
+	</element>
+	<element name="xmlEnum">
+		<simpleType>
+			<restriction base="string">
+				<enumeration value="xml"      />
+				<enumeration value="json"     />
+				<enumeration value="avro"     />
+				<enumeration value="thrift"   />
+				<enumeration value="protobuf" />
+				<enumeration value="rest.li"  />
+			</restriction>
+		</simpleType>
+	</element>
+	<element name="unsignedLongList">
+		<simpleType>
+			<list itemType="unsignedLong" />
+		</simpleType>
+	</element>
+	<element name="listOfUnion">
+		<simpleType>
+			<list>
+				<simpleType>
+					<union memberTypes="boolean string int positiveInteger" />
+				</simpleType>
+			</list>
+		</simpleType>
+	</element>
+	<element name="allTheThings">
+		<annotation>
+			<documentation>
+				This is a map containing a map of a union of firstMap and secondMap.
+				The maps are generated as all three have a single required attribute
+				of type ID.
+
+				The inner two maps become a union because a union of two map types is
+				not allowed.  Likewise, the map itself must become a union of two other
+				types.
+			</documentation>
+		</annotation>
+		<complexType>
+			<all>
+				<element name="firstMap">
+					<complexType>
+						<sequence>
+							<element name="value" default="1234567" nillable="true" minOccurs="1" maxOccurs="2">
+								<simpleType>
+									<restriction base="decimal">
+										<fractionDigits value="0"></fractionDigits>
+									</restriction>
+								</simpleType>
+							</element>
+						</sequence>
+						<attribute name="id" type="ID" use="required" />
+					</complexType>
+				</element>
+				<element name="secondMap">
+					<complexType>
+						<attribute name="id" type="ID" use="required" />
+						<attribute name="value" type="string" use="required" />
+					</complexType>
+				</element>
+			</all>
+			<attribute name="id" type="ID" use="required" />
+			<attribute name="listOfNumbers" default="127 -32768 18446744073709551615 -18446744073709551616">
+				<simpleType>
+					<list>
+						<simpleType>
+							<union memberTypes="byte unsignedLong int negativeInteger" />
+						</simpleType>
+					</list>
+				</simpleType>
+			</attribute>
+			<attribute name="truth" type="boolean" fixed="true" />
+		</complexType>
+	</element>
+	<complexType name="baseType">
+		<sequence>
+			<element name="fixed" type="integer" fixed="100" />
+		</sequence>
+		<attribute name="optional" type="string" use="optional" />
+		<anyAttribute namespace="##targetNamespace" />
+	</complexType>
+	<element name="prohibit">
+		<complexType>
+			<complexContent>
+				<restriction base="avro:baseType">
+					<sequence>
+						<element name="fixed" type="integer" fixed="100" />
+					</sequence>
+					<attribute name="optional" type="string" use="prohibited" />
+				</restriction>
+			</complexContent>
+		</complexType>
+	</element>
+	<element name="anyAndFriends">
+		<complexType mixed="true">
+			<sequence>
+				<any />
+        <any namespace="##any"   />
+        <any namespace="##other" />
+        <any namespace="http://avro.apache.org/AvroTest" />
+        <any namespace="http://avro.apache.org/AvroTest urn:avro:complex_schema" />
+        <any namespace="##targetNamespace http://avro.apache.org/AvroTest" />
+			</sequence>
+		</complexType>
+	</element>
+  <simpleType name="baseUnion">
+    <union memberTypes="boolean negativeInteger" />
+  </simpleType>
+  <simpleType name="restriction">
+  	<restriction base="avro:baseUnion">
+  		<enumeration value="true"  />
+  		<enumeration value="false" />
+  		<enumeration value="-123"  />
+  	</restriction>
+  </simpleType>
+  <complexType name="simpleTypeWithAttributes">
+  	<simpleContent>
+  		<extension base="avro:restriction">
+  			<attributeGroup ref="avro:derivedAttrGroup" />
+	  	</extension>
+  	</simpleContent>
+  </complexType>
+  <attributeGroup name="baseAttrGroup">
+  	<attribute name="default" type="string"        default="hello" />
+  	<attribute name="fixed"   type="unsignedShort" fixed="65534"   />
+  </attributeGroup>
+  <attributeGroup name="derivedAttrGroup">
+  	<attributeGroup ref="avro:baseAttrGroup" />
+  </attributeGroup>
+  <complexType name="derivedTypeWithAttributes">
+  	<complexContent>
+  		<extension base="avro:simpleTypeWithAttributes">
+			<anyAttribute namespace="http://avro.apache.org/AvroTest" />
+  		</extension>
+  	</complexContent>
+  </complexType>
+  <complexType name="grandchildType">
+  	<complexContent>
+  		<extension base="avro:derivedTypeWithAttributes">
+			<anyAttribute namespace="##targetNamespace" />
+  		</extension>
+  	</complexContent>
+  </complexType>
+  <complexType name="simpleContentRestriction">
+  	<simpleContent>
+  		<restriction base="avro:simpleTypeWithAttributes">
+	  		<enumeration value="true"  />
+  			<enumeration value="false" />
+  		</restriction>
+  	</simpleContent>
+  </complexType>
+  <complexType name="complexExtension">
+  	<complexContent>
+  		<extension base="avro:baseType">
+  			<choice>
+  				<element ref="avro:listOfUnion" />
+  				<element ref="avro:unsignedLongList" />
+  			</choice>
+  			<attribute name="defaulted" type="normalizedString" default="hello" />
+  		</extension>
+  	</complexContent>
+  </complexType>
+  <element name="mixedType">
+  	<complexType mixed="true">
+  		<sequence>
+  			<element ref="avro:listOfUnion" />
+  			<element ref="avro:unsignedLongList" />
+  		</sequence>
+  	</complexType>
+  </element>
+</schema>
\ No newline at end of file
Index: lang/java/xml/src/test/resources/complex_test1.xml
===================================================================
--- lang/java/xml/src/test/resources/complex_test1.xml	(revision 0)
+++ lang/java/xml/src/test/resources/complex_test1.xml	(working copy)
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<avro:realRoot day="---12" month="--08" xmlns:avro="urn:avro:complex_schema" xmlns:test="http://avro.apache.org/AvroTest" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:avro:complex_schema complex_schema.xsd http://avro.apache.org/AvroTest test_schema.xsd"  year="2014">
+  <avro:backtrack>
+    <avro:qName xmlns:iso4217="http://www.xbrl.org/2003/iso4217">iso4217:USD</avro:qName>
+    <avro:avroEnum>avro</avro:avroEnum>
+    <avro:xmlEnum>thrift</avro:xmlEnum>
+    <avro:xmlEnum>rest.li</avro:xmlEnum>
+    <avro:unsignedLongList>1 2 345 67890 1234567890 12345678901234567890</avro:unsignedLongList>
+    <avro:listOfUnion>true false hello goodbye 1234567890 -2147483648 2147483649</avro:listOfUnion>
+  </avro:backtrack>
+  <avro:allTheThings id="idvalue0">
+    <avro:secondMap id="idvalue2" value="Second Map Value"/>
+    <avro:firstMap id="idvalue1">
+      <avro:value />
+      <avro:value xsi:nil="true" />
+    </avro:firstMap>
+  </avro:allTheThings>
+  <avro:prohibit>
+    <avro:fixed/>
+  </avro:prohibit>
+  <avro:anyAndFriends>
+    This is a mixed element
+  	<test:list>
+  		<test:record>
+  			<test:primitive>float</test:primitive>
+  		</test:record>
+  	</test:list>
+  	interspersed with wildcard elements.
+  	<test:primitive>null</test:primitive>
+  	Since the wildcard elements are filtered
+  	<test:primitive>boolean</test:primitive>
+  	away, the final Avro document should
+  	<test:primitive>int</test:primitive>
+  	only contain this text.
+  	<avro:xmlEnum>json</avro:xmlEnum>
+  	<avro:avroEnum>json</avro:avroEnum>
+  	(If I did it right.)
+  </avro:anyAndFriends>
+  <avro:simpleExtension default="named">true</avro:simpleExtension>
+  <avro:simpleRestriction>false</avro:simpleRestriction>
+  <avro:complexExtension>
+  	<avro:fixed />
+  	<avro:unsignedLongList>1 2 4 5 6</avro:unsignedLongList>
+  </avro:complexExtension>
+  <avro:mixedType>
+  	Hello, my name is
+  	<avro:listOfUnion>Mike and I</avro:listOfUnion>
+  	welcome you to this mixed element with
+  	<avro:unsignedLongList>2</avro:unsignedLongList>
+  	sub-elements.
+  </avro:mixedType>
+</avro:realRoot>
Index: lang/java/xml/src/test/resources/complex_test1_out.xml
===================================================================
--- lang/java/xml/src/test/resources/complex_test1_out.xml	(revision 0)
+++ lang/java/xml/src/test/resources/complex_test1_out.xml	(working copy)
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<ns0:realRoot xmlns:ns0="urn:avro:complex_schema" day="---12" month="--08" xmlns:ns1="http://www.w3.org/2001/XMLSchema-instance" ns1:schemaLocation="urn:avro:complex_schema complex_schema.xsd http://avro.apache.org/AvroTest test_schema.xsd" year="2014">
+  <ns0:backtrack>
+    <ns0:qName xmlns:ns1="http://www.xbrl.org/2003/iso4217">ns1:USD</ns0:qName>
+    <ns0:avroEnum>avro</ns0:avroEnum>
+    <ns0:xmlEnum>thrift</ns0:xmlEnum>
+    <ns0:xmlEnum>rest.li</ns0:xmlEnum>
+    <ns0:unsignedLongList>1 2 345 67890 1234567890 12345678901234567890</ns0:unsignedLongList>
+    <ns0:listOfUnion>true false hello goodbye 1234567890 -2147483648 2147483649</ns0:listOfUnion>
+  </ns0:backtrack>
+  <ns0:allTheThings id="idvalue0" listOfNumbers="127 -32768 18446744073709551615 -18446744073709551616" truth="true">
+    <ns0:secondMap id="idvalue2" value="Second Map Value"/>
+    <ns0:firstMap id="idvalue1">
+      <ns0:value>1234567</ns0:value>
+      <ns0:value ns1:nil="true" />
+    </ns0:firstMap>
+  </ns0:allTheThings>
+  <ns0:prohibit>
+    <ns0:fixed>100</ns0:fixed>
+  </ns0:prohibit>
+  <ns0:anyAndFriends>
+    This is a mixed element
+  	
+  	interspersed with wildcard elements.
+  	
+  	Since the wildcard elements are filtered
+  	
+  	away, the final Avro document should
+  	
+  	only contain this text.
+  	
+  	
+  	(If I did it right.)
+  </ns0:anyAndFriends>
+  <ns0:simpleExtension default="named" fixed="65534">true</ns0:simpleExtension>
+  <ns0:simpleRestriction default="hello" fixed="65534">false</ns0:simpleRestriction>
+  <ns0:complexExtension defaulted="hello">
+    <ns0:fixed>100</ns0:fixed>
+    <ns0:unsignedLongList>1 2 4 5 6</ns0:unsignedLongList>
+  </ns0:complexExtension>
+  <ns0:mixedType>
+  	Hello, my name is
+  	<ns0:listOfUnion>Mike and I</ns0:listOfUnion>
+  	welcome you to this mixed element with
+  	<ns0:unsignedLongList>2</ns0:unsignedLongList>
+  	sub-elements.
+  </ns0:mixedType>
+</ns0:realRoot>
\ No newline at end of file
Index: lang/java/xml/src/test/resources/test1_root.xml
===================================================================
--- lang/java/xml/src/test/resources/test1_root.xml	(revision 0)
+++ lang/java/xml/src/test/resources/test1_root.xml	(working copy)
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<avro:root
+  anyURI="http://tempuri.org"
+  base64Binary="MA=="
+  boolean="true"
+  byte="57"
+  date="2014-07-27"
+  dateTime="2014-07-27T12:47:30"
+  decimal="65536"
+  double="32768.32768"
+  duration="P1D"
+  float="0.0"
+  gDay="---27"
+  gMonth="--07"
+  gMonthDay="--07-27"
+  gYear="2014"
+  gYearMonth="2014-07"
+  hexBinary="0F00"
+  id="idvalue0"
+  idref="idvalue0"
+  idrefs="idvalue0"
+  int="2147483647"
+  integer="9223372036854775808"
+  language="EN"
+  long="9223372036854775807"
+  name="Name"
+  ncName="NCName"
+  negativeInteger="-9223372036854775808"
+  nmtoken="NMTOKEN"
+  nmtokens="NMTOKENS"
+  nonNegativeInteger="9223372036854775808"
+  nonPositiveInteger="-9223372036854775808"
+  normalizedString="xmlIsFun"
+  positiveInteger="9223372036854775808"
+  qname="QName"
+  short="-32768"
+  string="hello"
+  time="12:47:30"
+  token="xmlSchema"
+  unsignedByte="255"
+  unsignedInt="4294967295"
+  unsignedLong="18446744073709551615"
+  unsignedShort="65535"
+  xmlns:avro="http://avro.apache.org/AvroTest"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://avro.apache.org/AvroTest test_schema.xsd ">
+
+</avro:root>
Index: lang/java/xml/src/test/resources/test2_children.xml
===================================================================
--- lang/java/xml/src/test/resources/test2_children.xml	(revision 0)
+++ lang/java/xml/src/test/resources/test2_children.xml	(working copy)
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<avro:root
+  anyURI="http://tempuri.org"
+  base64Binary="MA=="
+  boolean="true"
+  byte="57"
+  date="2014-07-27"
+  dateTime="2014-07-27T12:47:30"
+  decimal="65536"
+  double="32768.32768"
+  duration="P1D"
+  float="0.0"
+  gDay="---27"
+  gMonth="--07"
+  gMonthDay="--07-27"
+  gYear="2014"
+  gYearMonth="2014-07"
+  hexBinary="0F00"
+  id="idvalue0"
+  idref="idvalue0"
+  idrefs="idvalue0"
+  int="2147483647"
+  integer="9223372036854775808"
+  language="EN"
+  long="9223372036854775807"
+  name="Name"
+  ncName="NCName"
+  negativeInteger="-9223372036854775808"
+  nmtoken="NMTOKEN"
+  nmtokens="NMTOKENS"
+  nonNegativeInteger="9223372036854775808"
+  nonPositiveInteger="-9223372036854775808"
+  normalizedString="xmlIsFun"
+  positiveInteger="9223372036854775808"
+  qname="QName"
+  short="-32768"
+  string=""
+  time="12:47:30"
+  token="xmlSchema"
+  unsignedByte="255"
+  unsignedInt="4294967295"
+  unsignedLong="18446744073709551615"
+  unsignedShort="65535"
+  xmlns:avro="http://avro.apache.org/AvroTest"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://avro.apache.org/AvroTest test_schema.xsd ">
+
+	<avro:primitive>null</avro:primitive>
+	<avro:primitive>boolean</avro:primitive>
+	<avro:primitive>int</avro:primitive>
+	<avro:primitive>long</avro:primitive>
+	<avro:primitive>float</avro:primitive>
+	<avro:primitive>double</avro:primitive>
+	<avro:primitive>decimal</avro:primitive>
+	<avro:primitive>bytes</avro:primitive>
+	<avro:primitive>string</avro:primitive>
+	<avro:nonNullPrimitive>boolean</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>int</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>long</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>float</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>double</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>decimal</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>bytes</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>string</avro:nonNullPrimitive>
+</avro:root>
Index: lang/java/xml/src/test/resources/test3_grandchildren.xml
===================================================================
--- lang/java/xml/src/test/resources/test3_grandchildren.xml	(revision 0)
+++ lang/java/xml/src/test/resources/test3_grandchildren.xml	(working copy)
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<avro:root
+  xmlns:avro="http://avro.apache.org/AvroTest"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://avro.apache.org/AvroTest test_schema.xsd ">
+
+	<avro:primitive>decimal</avro:primitive>
+	<avro:nonNullPrimitive>int</avro:nonNullPrimitive>
+	<avro:map avro:mapId="id1">
+		<avro:primitive>double</avro:primitive>
+		<avro:nonNullPrimitive>float</avro:nonNullPrimitive>
+	</avro:map>
+	<avro:map avro:mapId="id2">
+		<avro:primitive>null</avro:primitive>
+	</avro:map>
+	<avro:record>
+		<avro:nonNullPrimitive>decimal</avro:nonNullPrimitive>
+	</avro:record>
+	<avro:map avro:mapId="id3">
+		<avro:primitive>string</avro:primitive>
+		<avro:map avro:mapId="id4">
+			<avro:nonNullPrimitive>string</avro:nonNullPrimitive>
+		</avro:map>
+		<avro:map avro:mapId="id5">
+			<avro:primitive>long</avro:primitive>
+		</avro:map>
+	</avro:map>
+	<avro:nonNullPrimitive>long</avro:nonNullPrimitive>
+	<avro:nonNullPrimitive>boolean</avro:nonNullPrimitive>
+</avro:root>
Index: lang/java/xml/src/test/resources/test_schema.xsd
===================================================================
--- lang/java/xml/src/test/resources/test_schema.xsd	(revision 0)
+++ lang/java/xml/src/test/resources/test_schema.xsd	(working copy)
@@ -0,0 +1,184 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<xsd:schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://avro.apache.org/AvroTest" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:avro="http://avro.apache.org/AvroTest">
+	<xsd:attributeGroup name="attrGroup" id="attrGroup">
+		<xsd:annotation>
+			<xsd:documentation>An attribute group with attributes of all simple types.</xsd:documentation>
+		</xsd:annotation>
+		<xsd:attribute name="anySimpleType"        type="xsd:anySimpleType"      use="optional" />
+		<xsd:attribute name="duration"             type="xsd:duration"           use="optional" />
+		<xsd:attribute name="dateTime"             type="xsd:dateTime"           use="optional" />
+		<xsd:attribute name="date"                 type="xsd:date"               use="optional" />
+		<xsd:attribute name="time"                 type="xsd:time"               use="optional" />
+		<xsd:attribute name="gYearMonth"           type="xsd:gYearMonth"         use="optional" />
+		<xsd:attribute name="gYear"                type="xsd:gYear"              use="optional" />
+		<xsd:attribute name="gMonthDay"            type="xsd:gMonthDay"          use="optional" />
+		<xsd:attribute name="gDay"                 type="xsd:gDay"               use="optional" />
+		<xsd:attribute name="gMonth"               type="xsd:gMonth"             use="optional" />
+		<xsd:attribute name="string"               type="xsd:string"             use="optional" />
+		<xsd:attribute name="boolean"              type="xsd:boolean"            use="optional" />
+		<xsd:attribute name="base64Binary"         type="xsd:base64Binary"       use="optional" />
+		<xsd:attribute name="hexBinary"            type="xsd:hexBinary"          use="optional" />
+		<xsd:attribute name="float"                type="xsd:float"              use="optional" />
+		<xsd:attribute name="decimal"              use="optional">
+			<xsd:simpleType>
+				<xsd:restriction base="xsd:decimal">
+					<xsd:fractionDigits value="0"></xsd:fractionDigits>
+				</xsd:restriction>
+			</xsd:simpleType>
+		</xsd:attribute>
+		<xsd:attribute name="double"               type="xsd:double"             use="optional" />
+		<xsd:attribute name="anyURI"               type="xsd:anyURI"             use="optional" />
+		<xsd:attribute name="qname"                type="xsd:QName"              use="optional" />
+		<xsd:attribute name="normalizedString"     type="xsd:normalizedString"   use="optional" />
+		<xsd:attribute name="token"                type="xsd:token"              use="optional" />
+		<xsd:attribute name="language"             type="xsd:language"           use="optional" />
+		<xsd:attribute name="name"                 type="xsd:Name"               use="optional" />
+		<xsd:attribute name="ncName"               type="xsd:NCName"             use="optional" />
+		<xsd:attribute name="nmtoken"              type="xsd:NMTOKEN"            use="optional" />
+		<xsd:attribute name="nmtokens"             type="xsd:NMTOKENS"           use="optional" />
+		<xsd:attribute name="id"                   type="xsd:ID"                 use="optional" />
+		<xsd:attribute name="idref"                type="xsd:IDREF"              use="optional" />
+		<xsd:attribute name="idrefs"               type="xsd:IDREFS"             use="optional" />
+		<xsd:attribute name="entity"               type="xsd:ENTITY"             use="optional" />
+		<xsd:attribute name="entities"             type="xsd:ENTITIES"           use="optional" />
+		<xsd:attribute name="integer"              type="xsd:integer"            use="optional" />
+		<xsd:attribute name="nonPositiveInteger"   type="xsd:nonPositiveInteger" use="optional" />
+		<xsd:attribute name="nonNegativeInteger"   type="xsd:nonNegativeInteger" use="optional" />
+		<xsd:attribute name="positiveInteger"      type="xsd:positiveInteger"    use="optional" />
+		<xsd:attribute name="negativeInteger"      type="xsd:negativeInteger"    use="optional" />
+		<xsd:attribute name="long"                 type="xsd:long"               use="optional" />
+		<xsd:attribute name="int"                  type="xsd:int"                use="optional" />
+		<xsd:attribute name="short"                type="xsd:short"              use="optional" />
+		<xsd:attribute name="byte"                 type="xsd:byte"               use="optional" />
+		<xsd:attribute name="unsignedLong"         type="xsd:unsignedLong"       use="optional" />
+		<xsd:attribute name="unsignedInt"          type="xsd:unsignedInt"        use="optional" />
+		<xsd:attribute name="unsignedShort"        type="xsd:unsignedShort"      use="optional" />
+		<xsd:attribute name="unsignedByte"         type="xsd:unsignedByte"       use="optional" />
+	</xsd:attributeGroup>
+	<xsd:attribute name="size">
+		<xsd:simpleType>
+			<xsd:restriction base="xsd:nonNegativeInteger">
+				<xsd:maxExclusive value="100" />
+			</xsd:restriction>
+		</xsd:simpleType>
+	</xsd:attribute>
+	<xsd:attribute name="mapId">
+		<xsd:simpleType>
+			<xsd:restriction base="xsd:ID">
+				<xsd:minLength value="1" />
+			</xsd:restriction>
+		</xsd:simpleType>
+	</xsd:attribute>
+	<xsd:group name="groupOfAll">
+		<xsd:annotation>
+			<xsd:documentation>An All Group</xsd:documentation>
+		</xsd:annotation>
+		<xsd:all>
+			<xsd:element ref="avro:primitive"        />
+			<xsd:element ref="avro:nonNullPrimitive" />
+			<xsd:element ref="avro:record"           />
+			<xsd:element ref="avro:list"             />
+		</xsd:all>
+	</xsd:group>
+	<xsd:group name="group">
+		<xsd:annotation>
+			<xsd:documentation>A group of nested sequences, choices, and elements.</xsd:documentation>
+		</xsd:annotation>
+		<xsd:sequence>
+			<xsd:choice minOccurs="0" maxOccurs="unbounded">
+				<xsd:element ref="avro:primitive"        />
+				<xsd:element ref="avro:nonNullPrimitive" />
+				<xsd:element ref="avro:record"           />
+				<xsd:element ref="avro:list"             />
+				<xsd:element ref="avro:tuple"            />
+			</xsd:choice>
+		</xsd:sequence>
+	</xsd:group>
+	<xsd:simpleType name="primitiveType">
+		<xsd:restriction base="xsd:NMTOKEN">
+			<xsd:enumeration value="null" />
+			<xsd:enumeration value="boolean" />
+			<xsd:enumeration value="int" />
+			<xsd:enumeration value="long" />
+			<xsd:enumeration value="float" />
+			<xsd:enumeration value="double" />
+			<xsd:enumeration value="decimal" />
+			<xsd:enumeration value="bytes" />
+			<xsd:enumeration value="string" />
+		</xsd:restriction>
+	</xsd:simpleType>
+	<xsd:simpleType name="nonNullPrimitiveType">
+		<xsd:restriction base="avro:primitiveType">
+			<xsd:enumeration value="boolean" />
+			<xsd:enumeration value="int" />
+			<xsd:enumeration value="long" />
+			<xsd:enumeration value="float" />
+			<xsd:enumeration value="double" />
+			<xsd:enumeration value="decimal" />
+			<xsd:enumeration value="bytes" />
+			<xsd:enumeration value="string" />
+		</xsd:restriction>
+	</xsd:simpleType>
+	<xsd:element name="root">
+		<xsd:complexType>
+			<xsd:group ref="avro:group" />
+			<xsd:attributeGroup ref="avro:attrGroup" />
+		</xsd:complexType>
+	</xsd:element>
+	<xsd:element name="primitive" type="avro:primitiveType" />
+	<xsd:element name="nonNullPrimitive" type="avro:nonNullPrimitiveType" />
+	<xsd:complexType name="recordType">
+		<xsd:group ref="avro:group" />
+	</xsd:complexType>
+	<xsd:element name="record" type="avro:recordType" />
+	<xsd:element name="map" substitutionGroup="avro:record">
+		<xsd:complexType>
+			<xsd:complexContent>
+				<xsd:extension base="avro:recordType">
+					<xsd:attribute ref="avro:mapId" use="required" />
+				</xsd:extension>
+			</xsd:complexContent>
+		</xsd:complexType>
+	</xsd:element>
+	<xsd:element name="list">
+		<xsd:complexType>
+			<xsd:choice>
+				<xsd:element ref="avro:primitive" minOccurs="1" maxOccurs="100" />
+				<xsd:element ref="avro:record"    minOccurs="1" maxOccurs="100" />
+			</xsd:choice>
+			<xsd:attribute ref="avro:size" />
+		</xsd:complexType>
+	</xsd:element>
+	<xsd:element name="tuple">
+		<xsd:complexType>
+			<xsd:group ref="avro:groupOfAll" />
+		</xsd:complexType>
+	</xsd:element>
+	<xsd:element name="nonNullRecord">
+		<xsd:complexType>
+			<xsd:complexContent>
+				<xsd:restriction base="avro:recordType">
+					<xsd:sequence>
+						<xsd:element ref="avro:nonNullPrimitive" />
+					</xsd:sequence>
+				</xsd:restriction>
+			</xsd:complexContent>
+		</xsd:complexType>
+	</xsd:element>
+</xsd:schema>
\ No newline at end of file
